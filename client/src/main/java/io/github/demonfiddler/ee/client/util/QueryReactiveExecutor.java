/*----------------------------------------------------------------------------------------------------------------------
 * Evidence Engine: A system for managing evidence on arbitrary scientific topics.
 * Comprises an SQL database, GraphQL public API, Java app server, Java and web clients.
 * Copyright Â© 2024-25 Adrian Price. All rights reserved.
 *
 * This file is part of Evidence Engine.
 *
 * Evidence Engine is free software: you can redistribute it and/or modify it under the terms of the
 * GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * Evidence Engine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License along with Evidence Engine.
 * If not, see <https://www.gnu.org/licenses/>. 
 *--------------------------------------------------------------------------------------------------------------------*/

package io.github.demonfiddler.ee.client.util;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.graphql.client.GraphQlClient;
import org.springframework.stereotype.Component;

import com.graphql_java_generator.annotation.GraphQLNonScalar;
import com.graphql_java_generator.annotation.GraphQLScalar;
import com.graphql_java_generator.annotation.RequestType;
import com.graphql_java_generator.client.GraphQLQueryReactiveExecutor;
import com.graphql_java_generator.client.GraphqlClientUtils;
import com.graphql_java_generator.client.request.Builder;
import com.graphql_java_generator.client.request.InputParameter;
import com.graphql_java_generator.client.request.InputParameter.InputParameterType;
import com.graphql_java_generator.client.request.ObjectResponse;
import com.graphql_java_generator.customscalars.GraphQLScalarTypeDate;
import com.graphql_java_generator.exception.GraphQLRequestExecutionException;
import com.graphql_java_generator.exception.GraphQLRequestPreparationException;
import com.graphql_java_generator.util.GraphqlUtils;

import io.github.demonfiddler.ee.client.Claim;
import io.github.demonfiddler.ee.client.ClaimPage;
import io.github.demonfiddler.ee.client.Declaration;
import io.github.demonfiddler.ee.client.DeclarationPage;
import io.github.demonfiddler.ee.client.EntityKind;
import io.github.demonfiddler.ee.client.Journal;
import io.github.demonfiddler.ee.client.JournalPage;
import io.github.demonfiddler.ee.client.LogPage;
import io.github.demonfiddler.ee.client.LogQueryFilter;
import io.github.demonfiddler.ee.client.PageableInput;
import io.github.demonfiddler.ee.client.Person;
import io.github.demonfiddler.ee.client.PersonPage;
import io.github.demonfiddler.ee.client.Publication;
import io.github.demonfiddler.ee.client.PublicationPage;
import io.github.demonfiddler.ee.client.Publisher;
import io.github.demonfiddler.ee.client.PublisherPage;
import io.github.demonfiddler.ee.client.Query;
import io.github.demonfiddler.ee.client.Quotation;
import io.github.demonfiddler.ee.client.QuotationPage;
import io.github.demonfiddler.ee.client.Topic;
import io.github.demonfiddler.ee.client.TopicPage;
import io.github.demonfiddler.ee.client.TopicQueryFilter;
import io.github.demonfiddler.ee.client.TopicRef;
import io.github.demonfiddler.ee.client.TopicRefPage;
import io.github.demonfiddler.ee.client.TopicRefQueryFilter;
import io.github.demonfiddler.ee.client.TopicalEntityQueryFilter;
import io.github.demonfiddler.ee.client.TrackedEntityQueryFilter;
import io.github.demonfiddler.ee.client.User;
import io.github.demonfiddler.ee.client.UserPage;
import io.github.demonfiddler.ee.client.__Schema;
import io.github.demonfiddler.ee.client.__Type;
import reactor.core.publisher.Mono;

/**
 * Available queries. <BR/>
 * This class contains the methods that allows the execution of the queries or mutations that are defined in the Query
 * of the GraphQL schema. All the methods for this executor are in spring reactive, that is: they return a
 * {@link Mono}.<BR/>
 * These methods allows:
 * <UL>
 * <LI>Preparation of full requests</LI>
 * <LI>Execution of prepared full requests</LI>
 * <LI>Execution of direct full direct requests</LI>
 * <LI>Preparation of partial requests</LI>
 * <LI>Execution of prepared partial requests</LI>
 * <LI>Execution of direct partial requests</LI>
 * </UL>
 * You'll find all the documentation on the
 * <A HREF="https://github.com/graphql-java-generator/graphql-maven-plugin-project/wiki/client_spring">client page
 * doc</A>.
 * @author generated by graphql-java-generator
 */
@Component

public class QueryReactiveExecutor implements GraphQLQueryReactiveExecutor {

	/** Logger for this class */
	private static Logger logger = LoggerFactory.getLogger(QueryReactiveExecutor.class);

	@Autowired
	@Qualifier("httpGraphQlClient")
	GraphQlClient graphQlClient;

	GraphqlUtils graphqlUtils = GraphqlUtils.graphqlUtils; // must be set that way, to be used in the constructor

	@Autowired
	GraphqlClientUtils graphqlClientUtils;

	public QueryReactiveExecutor() {
		if (!"2.8".equals(this.graphqlUtils.getRuntimeVersion())) { //$NON-NLS-1$
			throw new RuntimeException(
				"The GraphQL runtime version doesn't match the GraphQL plugin version. The runtime's version is '" //$NON-NLS-1$
					+ this.graphqlUtils.getRuntimeVersion() + "' whereas the GraphQL plugin version is '2.8'"); //$NON-NLS-1$
		}
		CustomScalarRegistryInitializer.initCustomScalarRegistry();
		DirectiveRegistryInitializer.initDirectiveRegistry();
	}

	/**
	 * This method takes a <B>full request</B> definition, and executes it against the GraphQL server. As this class is
	 * a query executor, the provided request must be a query full request. This request will be executed in reactive
	 * mode, that is: it returns a {@link Mono}<Query><BR/>
	 * This method offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace
	 * mode).<BR/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 *     @Autowired
	 *     QueryExecutor executor;
	 * 
	 *     void myMethod() {
	 * 	        Map<String, Object> params = new HashMap<>();
	 *          params.put("param", paramValue);   // param is optional, as it is marked by a "?" in the request
	 *          params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 *          
	 *          Mono<Query> mono = executor.execWithBindValues(
	 *              "query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}",
	 *              callback,
	 *              params);
	 *          Query query = mono.block();
	 *          FieldType field = query.getSampleQueryOrMutationField();
	 *
	 *          .... do something with this field's value
	 *     }
	 * }
	 * 
	 * 
	 * 
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("heroParam", heroParamValue);
	 * params.put("skip", Boolean.FALSE);
	 * 
	 * Mono<Query> mono = myQueryType.execWithBindValues(
	 * 		"{hero(param:?heroParam) @include(if:true) {id name @skip(if: ?skip) appearsIn friends {id name}}}",
	 * 		params);
	 * ...
	 * Query response = mono.block();
	 * Character c = response.getHero();
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above). It
	 * must ommit the query/mutation/subscription keyword, and start by the first { that follows.It may contain
	 * directives, as explained in the GraphQL specs.
	 * @param parameters The map of values, for the bind variables defined in the query. If there is no bind variable in
	 * the defined Query, this argument may be null or an empty {@link Map}. The key is the parameter name, as defined
	 * in the query (in the above sample: heroParam is an optional parameter and skip is a mandatory one). The value is
	 * the parameter vale in its Java type (for instance a {@link Date} for the {@link GraphQLScalarTypeDate}). The
	 * parameters which value is missing in this map will no be transmitted toward the GraphQL server.
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	public Mono<Query> execWithBindValues(String queryResponseDef, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return execWithBindValues(objectResponse, parameters);
	}

	/**
	 * This method takes a <B>full request</B> definition, and executes it against the GraphQL server. As this class is
	 * a query executor, the provided request must be a query full request. This request will be executed in reactive
	 * mode, that is: it returns a {@link Mono}<Query><BR/>
	 * This method offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace
	 * mode).<BR/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 *     @Autowired
	 *     QueryExecutor executor;
	 * 
	 *     void myMethod() {
	 *          Mono<Query> mono = executor.exec(
	 *              "query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}",
	 *              "param", paramValue,   // param is optional, as it is marked by a "?" in the request
	 *              "skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 *              );
	 *          Query query = mono.block();
	 *          FieldType field = query.getSampleQueryOrMutationField();
	 *
	 *          .... do something with this field's value
	 *     }
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above). It
	 * must ommit the query/mutation/subscription keyword, and start by the first { that follows.It may contain
	 * directives, as explained in the GraphQL specs.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	public Mono<Query> exec(String queryResponseDef, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return execWithBindValues(objectResponse,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method takes a <B>full request</B> definition, and executes it against the GraphQL server. As this class is
	 * a query executor, the provided request must be a query full request. This request will be executed in reactive
	 * mode, that is: it returns a {@link Mono}<Query><BR/>
	 * This method offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace
	 * mode).<BR/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 *     &#64;Autowired
	 *     QueryExecutor executor;
	 *     
	 *     GraphQLRequest preparedRequest;
	 *     
	 *     @PostConstruct
	 *     public void setup() {
	 *         // Preparation of the query, so that it is prepared once then executed several times
	 *         preparedRequest = executor
	 *             .getResponseBuilder()
	 *             .withQueryResponseDef("query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}")
	 *             .build();
	 *     }
	 * 
	 *     void myMethod() {
	 * 	        Map<String, Object> params = new HashMap<>();
	 *          params.put("param", paramValue);   // param is optional, as it is marked by a "?" in the request
	 *          params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 *          
	 *          Mono<Query> mono = executor.execWithBindValues(
	 *              preparedRequest,
	 *              params);
	 *          Query query = mono.block();
	 *          FieldType field = query.getSampleQueryOrMutationField();
	 *
	 *          .... do something with this field's value
	 *     }
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGraphQLRequest(String)} method or one of the <code>getXxxxGraphQLRequest(String)</code> methods.
	 * @param parameters The list of values, for the bind variables defined in the query. If there is no bind variable
	 * in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */

	public Mono<Query> execWithBindValues(ObjectResponse objectResponse, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			if (parameters == null) {
				logger.trace("Executing query without parameters"); //$NON-NLS-1$
			} else {
				StringBuilder sb = new StringBuilder("Executing root query with parameters: "); //$NON-NLS-1$
				boolean addComma = false;
				for (String key : parameters.keySet()) {
					sb.append(key).append(":").append(parameters.get(key)); //$NON-NLS-1$
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
				logger.trace(sb.toString());
			}
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'Query'"); //$NON-NLS-1$
		}

		return objectResponse.execReactive(Query.class, (parameters != null) ? parameters : new HashMap<>());
	}

	/**
	 * This method takes a <B>full request</B> definition, and executes it against the GraphQL server. As this class is
	 * a query executor, the provided request must be a query full request. This request will be executed in reactive
	 * mode, that is: it returns a {@link Mono}<Query><BR/>
	 * This method offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace
	 * mode).<BR/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 *     &#64;Autowired
	 *     QueryExecutor executor;
	 *     
	 *     GraphQLRequest preparedRequest;
	 *     
	 *     @PostConstruct
	 *     public void setup() {
	 *         // Preparation of the query, so that it is prepared once then executed several times
	 *         preparedRequest = executor
	 *             .getResponseBuilder()
	 *             .withQueryResponseDef("query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}")
	 *             .build();
	 *     }
	 * 
	 *     void myMethod() {
	 *          Mono<Query> mono = executor.exec(
	 *              preparedRequest,
	 *              "param", paramValue,   // param is optional, as it is marked by a "?" in the request
	 *              "skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 *              );
	 *          Query query = mono.block();
	 *          FieldType field = query.getSampleQueryOrMutationField();
	 *
	 *          .... do something with this field's value
	 *     }
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGraphQLRequest(String)} method or one of the <code>getXxxxGraphQLRequest(String)</code> methods.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	public Mono<Query> exec(ObjectResponse objectResponse, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return execWithBindValues(objectResponse,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Get the {@link Builder} for a <B>full request</B>, as expected by the exec and execWithBindValues methods.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class);
	}

	/**
	 * Get the {@link GraphQLReactiveRequest} for <B>full request</B>. For instance:
	 * 
	 * <PRE>
	 * GraphQLReactiveRequest request = new GraphQLRequest(fullRequest);
	 * </PRE>
	 * 
	 * @param fullRequest The full GraphQL Request, as specified in the GraphQL specification
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */

	public GraphQLReactiveRequest getGraphQLRequest(String fullRequest) throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(fullRequest);
	}

	/**
	 * Returns a paged list of claims. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<ClaimPage> mono = executor.claimsWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for claims's filter input parameter
	 * 			pageSort, // A value for claims's pageSort input parameter
	 * 			params);
	 * 		ClaimPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "claims", graphQLTypeSimpleName = "ClaimPage", javaClass = ClaimPage.class)
	public Mono<Optional<ClaimPage>> claimsWithBindValues(String queryResponseDef, TopicalEntityQueryFilter filter,
		PageableInput pageSort, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'claims': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getClaimsResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return claimsWithBindValues(objectResponse, filter, pageSort, parameters);
	}

	/**
	 * Returns a paged list of claims.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<ClaimPage> mono = executor.claims(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for claims's filter input parameter
	 * 			pageSort, // A value for claims's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		ClaimPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "claims", graphQLTypeSimpleName = "ClaimPage", javaClass = ClaimPage.class)
	public Mono<Optional<ClaimPage>> claims(String queryResponseDef, TopicalEntityQueryFilter filter,
		PageableInput pageSort, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'claims': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getClaimsResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return claimsWithBindValues(objectResponse, filter, pageSort,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a paged list of claims.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getClaimsGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<ClaimPage> mono = executor.claimsWithBindValues(preparedRequest, filter, // A value for claims's
	 * 																						// filter input parameter
	 * 			pageSort, // A value for claims's pageSort input parameter
	 * 			params);
	 * 		ClaimPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getClaimsGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "claims", graphQLTypeSimpleName = "ClaimPage", javaClass = ClaimPage.class)

	public Mono<Optional<ClaimPage>> claimsWithBindValues(ObjectResponse objectResponse,
		TopicalEntityQueryFilter filter, PageableInput pageSort, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'claims' with parameters: {}, {} ", filter, pageSort); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'claims'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryClaimsFilter", filter); //$NON-NLS-1$
		parametersLocal.put("queryClaimsPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getClaims() == null) ? Optional.empty() : Optional.of(t.getClaims()));
	}

	/**
	 * Returns a paged list of claims.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getClaimsGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<ClaimPage> mono = executor.claims(preparedRequest, filter, // A value for claims's filter input
	 * 																		// parameter
	 * 			pageSort, // A value for claims's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		ClaimPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getClaimsGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "claims", graphQLTypeSimpleName = "ClaimPage", javaClass = ClaimPage.class)
	public Mono<Optional<ClaimPage>> claims(ObjectResponse objectResponse, TopicalEntityQueryFilter filter,
		PageableInput pageSort, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'claims' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'claims' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryClaimsFilter", filter); //$NON-NLS-1$
		parameters.put("queryClaimsPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getClaims() == null) ? Optional.empty() : Optional.of(t.getClaims()));
	}

	/**
	 * Returns a paged list of claims.<br/>
	 * Get the {@link Builder} for the ClaimPage, as expected by the claims query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getClaimsResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "claims", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryClaimsFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TopicalEntityQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryClaimsPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a paged list of claims.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the claims REACTIVE_EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getClaimsGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "claims" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryClaimsFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TopicalEntityQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryClaimsPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a claim given its identifier. This method executes a partial query against the GraphQL server. That is,
	 * the query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part
	 * of the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Claim> mono = executor.claimByIdWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			id, // A value for claimById's id input parameter
	 * 			params);
	 * 		Claim field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param id Parameter for the claimById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "claimById", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Mono<Optional<Claim>> claimByIdWithBindValues(String queryResponseDef, Long id,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'claimById': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getClaimByIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return claimByIdWithBindValues(objectResponse, id, parameters);
	}

	/**
	 * Returns a claim given its identifier.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Claim> mono = executor.claimById(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			id, // A value for claimById's id input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Claim field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param id Parameter for the claimById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "claimById", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Mono<Optional<Claim>> claimById(String queryResponseDef, Long id, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'claimById': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getClaimByIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return claimByIdWithBindValues(objectResponse, id,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a claim given its identifier.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getClaimByIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Claim> mono = executor.claimByIdWithBindValues(preparedRequest, id, // A value for claimById's id
	 * 																					// input parameter
	 * 			params);
	 * 		Claim field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getClaimByIdGraphQLRequest(String)} method.
	 * @param id Parameter for the claimById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "claimById", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)

	public Mono<Optional<Claim>> claimByIdWithBindValues(ObjectResponse objectResponse, Long id,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'claimById' with parameters: {} ", id); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'claimById'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryClaimByIdId", id); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getClaimById() == null) ? Optional.empty() : Optional.of(t.getClaimById()));
	}

	/**
	 * Returns a claim given its identifier.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getClaimByIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Claim> mono = executor.claimById(preparedRequest, id, // A value for claimById's id input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Claim field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getClaimByIdGraphQLRequest(String)} method.
	 * @param id Parameter for the claimById field of Query, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "claimById", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Mono<Optional<Claim>> claimById(ObjectResponse objectResponse, Long id, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'claimById' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'claimById' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryClaimByIdId", id); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getClaimById() == null) ? Optional.empty() : Optional.of(t.getClaimById()));
	}

	/**
	 * Returns a claim given its identifier.<br/>
	 * Get the {@link Builder} for the Claim, as expected by the claimById query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getClaimByIdResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "claimById", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "id", "queryClaimByIdId", InputParameterType.MANDATORY, "ID", true, 0, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				false));
	}

	/**
	 * Returns a claim given its identifier.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the claimById REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getClaimByIdGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "claimById" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "id", "queryClaimByIdId", InputParameterType.MANDATORY, "ID", true, 0, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				false));
	}

	/**
	 * Returns a paged list of declarations. This method executes a partial query against the GraphQL server. That is,
	 * the query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part
	 * of the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<DeclarationPage> mono = executor.declarationsWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for declarations's filter input parameter
	 * 			pageSort, // A value for declarations's pageSort input parameter
	 * 			params);
	 * 		DeclarationPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "declarations", graphQLTypeSimpleName = "DeclarationPage",
		javaClass = DeclarationPage.class)
	public Mono<Optional<DeclarationPage>> declarationsWithBindValues(String queryResponseDef,
		TopicalEntityQueryFilter filter, PageableInput pageSort, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'declarations': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getDeclarationsResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return declarationsWithBindValues(objectResponse, filter, pageSort, parameters);
	}

	/**
	 * Returns a paged list of declarations.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<DeclarationPage> mono = executor.declarations(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for declarations's filter input parameter
	 * 			pageSort, // A value for declarations's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		DeclarationPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "declarations", graphQLTypeSimpleName = "DeclarationPage",
		javaClass = DeclarationPage.class)
	public Mono<Optional<DeclarationPage>> declarations(String queryResponseDef, TopicalEntityQueryFilter filter,
		PageableInput pageSort, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'declarations': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getDeclarationsResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return declarationsWithBindValues(objectResponse, filter, pageSort,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a paged list of declarations.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeclarationsGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<DeclarationPage> mono = executor.declarationsWithBindValues(preparedRequest, filter, // A value for
	 * 																									// declarations's
	 * 																									// filter
	 * 																									// input
	 * 																									// parameter
	 * 			pageSort, // A value for declarations's pageSort input parameter
	 * 			params);
	 * 		DeclarationPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeclarationsGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "declarations", graphQLTypeSimpleName = "DeclarationPage",
		javaClass = DeclarationPage.class)

	public Mono<Optional<DeclarationPage>> declarationsWithBindValues(ObjectResponse objectResponse,
		TopicalEntityQueryFilter filter, PageableInput pageSort, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'declarations' with parameters: {}, {} ", filter, pageSort); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'declarations'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryDeclarationsFilter", filter); //$NON-NLS-1$
		parametersLocal.put("queryDeclarationsPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getDeclarations() == null) ? Optional.empty() : Optional.of(t.getDeclarations()));
	}

	/**
	 * Returns a paged list of declarations.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeclarationsGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<DeclarationPage> mono = executor.declarations(preparedRequest, filter, // A value for declarations's
	 * 																					// filter input parameter
	 * 			pageSort, // A value for declarations's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		DeclarationPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeclarationsGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "declarations", graphQLTypeSimpleName = "DeclarationPage",
		javaClass = DeclarationPage.class)
	public Mono<Optional<DeclarationPage>> declarations(ObjectResponse objectResponse, TopicalEntityQueryFilter filter,
		PageableInput pageSort, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'declarations' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'declarations' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryDeclarationsFilter", filter); //$NON-NLS-1$
		parameters.put("queryDeclarationsPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getDeclarations() == null) ? Optional.empty() : Optional.of(t.getDeclarations()));
	}

	/**
	 * Returns a paged list of declarations.<br/>
	 * Get the {@link Builder} for the DeclarationPage, as expected by the declarations query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeclarationsResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "declarations", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryDeclarationsFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TopicalEntityQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryDeclarationsPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a paged list of declarations.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the declarations REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeclarationsGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "declarations" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryDeclarationsFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TopicalEntityQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryDeclarationsPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a declaration given its identifier. This method executes a partial query against the GraphQL server. That
	 * is, the query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the
	 * part of the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Declaration> mono = executor.declarationByIdWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			id, // A value for declarationById's id input parameter
	 * 			params);
	 * 		Declaration field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param id Parameter for the declarationById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "declarationById", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Mono<Optional<Declaration>> declarationByIdWithBindValues(String queryResponseDef, Long id,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'declarationById': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getDeclarationByIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return declarationByIdWithBindValues(objectResponse, id, parameters);
	}

	/**
	 * Returns a declaration given its identifier.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Declaration> mono = executor.declarationById(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			id, // A value for declarationById's id input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Declaration field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param id Parameter for the declarationById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "declarationById", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Mono<Optional<Declaration>> declarationById(String queryResponseDef, Long id, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'declarationById': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getDeclarationByIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return declarationByIdWithBindValues(objectResponse, id,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a declaration given its identifier.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeclarationByIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Declaration> mono = executor.declarationByIdWithBindValues(preparedRequest, id, // A value for
	 * 																								// declarationById's
	 * 																								// id input
	 * 																								// parameter
	 * 			params);
	 * 		Declaration field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeclarationByIdGraphQLRequest(String)} method.
	 * @param id Parameter for the declarationById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "declarationById", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)

	public Mono<Optional<Declaration>> declarationByIdWithBindValues(ObjectResponse objectResponse, Long id,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'declarationById' with parameters: {} ", id); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'declarationById'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryDeclarationByIdId", id); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getDeclarationById() == null) ? Optional.empty() : Optional.of(t.getDeclarationById()));
	}

	/**
	 * Returns a declaration given its identifier.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeclarationByIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Declaration> mono = executor.declarationById(preparedRequest, id, // A value for declarationById's
	 * 																				// id input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Declaration field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeclarationByIdGraphQLRequest(String)} method.
	 * @param id Parameter for the declarationById field of Query, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "declarationById", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Mono<Optional<Declaration>> declarationById(ObjectResponse objectResponse, Long id,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'declarationById' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'declarationById' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryDeclarationByIdId", id); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getDeclarationById() == null) ? Optional.empty() : Optional.of(t.getDeclarationById()));
	}

	/**
	 * Returns a declaration given its identifier.<br/>
	 * Get the {@link Builder} for the Declaration, as expected by the declarationById query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeclarationByIdResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "declarationById", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "id", "queryDeclarationByIdId", InputParameterType.MANDATORY, "ID", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				true, 0, false));
	}

	/**
	 * Returns a declaration given its identifier.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the declarationById REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeclarationByIdGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "declarationById" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "id", "queryDeclarationByIdId", InputParameterType.MANDATORY, "ID", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				true, 0, false));
	}

	/**
	 * Returns a paged list of journals. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<JournalPage> mono = executor.journalsWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for journals's filter input parameter
	 * 			pageSort, // A value for journals's pageSort input parameter
	 * 			params);
	 * 		JournalPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "journals", graphQLTypeSimpleName = "JournalPage", javaClass = JournalPage.class)
	public Mono<Optional<JournalPage>> journalsWithBindValues(String queryResponseDef, TrackedEntityQueryFilter filter,
		PageableInput pageSort, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'journals': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getJournalsResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return journalsWithBindValues(objectResponse, filter, pageSort, parameters);
	}

	/**
	 * Returns a paged list of journals.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<JournalPage> mono = executor.journals(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for journals's filter input parameter
	 * 			pageSort, // A value for journals's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		JournalPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "journals", graphQLTypeSimpleName = "JournalPage", javaClass = JournalPage.class)
	public Mono<Optional<JournalPage>> journals(String queryResponseDef, TrackedEntityQueryFilter filter,
		PageableInput pageSort, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'journals': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getJournalsResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return journalsWithBindValues(objectResponse, filter, pageSort,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a paged list of journals.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getJournalsGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<JournalPage> mono = executor.journalsWithBindValues(preparedRequest, filter, // A value for
	 * 																							// journals's filter
	 * 																							// input parameter
	 * 			pageSort, // A value for journals's pageSort input parameter
	 * 			params);
	 * 		JournalPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getJournalsGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "journals", graphQLTypeSimpleName = "JournalPage", javaClass = JournalPage.class)

	public Mono<Optional<JournalPage>> journalsWithBindValues(ObjectResponse objectResponse,
		TrackedEntityQueryFilter filter, PageableInput pageSort, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'journals' with parameters: {}, {} ", filter, pageSort); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'journals'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryJournalsFilter", filter); //$NON-NLS-1$
		parametersLocal.put("queryJournalsPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getJournals() == null) ? Optional.empty() : Optional.of(t.getJournals()));
	}

	/**
	 * Returns a paged list of journals.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getJournalsGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<JournalPage> mono = executor.journals(preparedRequest, filter, // A value for journals's filter
	 * 																			// input parameter
	 * 			pageSort, // A value for journals's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		JournalPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getJournalsGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "journals", graphQLTypeSimpleName = "JournalPage", javaClass = JournalPage.class)
	public Mono<Optional<JournalPage>> journals(ObjectResponse objectResponse, TrackedEntityQueryFilter filter,
		PageableInput pageSort, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'journals' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'journals' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryJournalsFilter", filter); //$NON-NLS-1$
		parameters.put("queryJournalsPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getJournals() == null) ? Optional.empty() : Optional.of(t.getJournals()));
	}

	/**
	 * Returns a paged list of journals.<br/>
	 * Get the {@link Builder} for the JournalPage, as expected by the journals query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getJournalsResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "journals", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryJournalsFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TrackedEntityQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryJournalsPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a paged list of journals.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the journals REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getJournalsGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "journals" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryJournalsFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TrackedEntityQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryJournalsPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a journal given its identifier. This method executes a partial query against the GraphQL server. That is,
	 * the query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part
	 * of the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Journal> mono = executor.journalByIdWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			id, // A value for journalById's id input parameter
	 * 			params);
	 * 		Journal field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param id Parameter for the journalById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "journalById", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Mono<Optional<Journal>> journalByIdWithBindValues(String queryResponseDef, Long id,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'journalById': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getJournalByIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return journalByIdWithBindValues(objectResponse, id, parameters);
	}

	/**
	 * Returns a journal given its identifier.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Journal> mono = executor.journalById(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			id, // A value for journalById's id input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Journal field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param id Parameter for the journalById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "journalById", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Mono<Optional<Journal>> journalById(String queryResponseDef, Long id, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'journalById': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getJournalByIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return journalByIdWithBindValues(objectResponse, id,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a journal given its identifier.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getJournalByIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Journal> mono = executor.journalByIdWithBindValues(preparedRequest, id, // A value for journalById's
	 * 																						// id input parameter
	 * 			params);
	 * 		Journal field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getJournalByIdGraphQLRequest(String)} method.
	 * @param id Parameter for the journalById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "journalById", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)

	public Mono<Optional<Journal>> journalByIdWithBindValues(ObjectResponse objectResponse, Long id,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'journalById' with parameters: {} ", id); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'journalById'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryJournalByIdId", id); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getJournalById() == null) ? Optional.empty() : Optional.of(t.getJournalById()));
	}

	/**
	 * Returns a journal given its identifier.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getJournalByIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Journal> mono = executor.journalById(preparedRequest, id, // A value for journalById's id input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Journal field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getJournalByIdGraphQLRequest(String)} method.
	 * @param id Parameter for the journalById field of Query, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "journalById", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Mono<Optional<Journal>> journalById(ObjectResponse objectResponse, Long id, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'journalById' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'journalById' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryJournalByIdId", id); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getJournalById() == null) ? Optional.empty() : Optional.of(t.getJournalById()));
	}

	/**
	 * Returns a journal given its identifier.<br/>
	 * Get the {@link Builder} for the Journal, as expected by the journalById query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getJournalByIdResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "journalById", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "id", "queryJournalByIdId", InputParameterType.MANDATORY, "ID", true, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				0, false));
	}

	/**
	 * Returns a journal given its identifier.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the journalById REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getJournalByIdGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "journalById" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "id", "queryJournalByIdId", InputParameterType.MANDATORY, "ID", true, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				0, false));
	}

	/**
	 * Returns a paged list of log entries. This method executes a partial query against the GraphQL server. That is,
	 * the query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part
	 * of the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<LogPage> mono = executor.logWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for log's filter input parameter
	 * 			pageSort, // A value for log's pageSort input parameter
	 * 			params);
	 * 		LogPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "log", graphQLTypeSimpleName = "LogPage", javaClass = LogPage.class)
	public Mono<Optional<LogPage>> logWithBindValues(String queryResponseDef, LogQueryFilter filter,
		PageableInput pageSort, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'log': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getLogResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return logWithBindValues(objectResponse, filter, pageSort, parameters);
	}

	/**
	 * Returns a paged list of log entries.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<LogPage> mono = executor.log(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for log's filter input parameter
	 * 			pageSort, // A value for log's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		LogPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "log", graphQLTypeSimpleName = "LogPage", javaClass = LogPage.class)
	public Mono<Optional<LogPage>> log(String queryResponseDef, LogQueryFilter filter, PageableInput pageSort,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'log': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getLogResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return logWithBindValues(objectResponse, filter, pageSort,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a paged list of log entries.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getLogGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<LogPage> mono = executor.logWithBindValues(preparedRequest, filter, // A value for log's filter
	 * 																					// input parameter
	 * 			pageSort, // A value for log's pageSort input parameter
	 * 			params);
	 * 		LogPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getLogGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "log", graphQLTypeSimpleName = "LogPage", javaClass = LogPage.class)

	public Mono<Optional<LogPage>> logWithBindValues(ObjectResponse objectResponse, LogQueryFilter filter,
		PageableInput pageSort, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'log' with parameters: {}, {} ", filter, pageSort); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'log'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryLogFilter", filter); //$NON-NLS-1$
		parametersLocal.put("queryLogPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getLog() == null) ? Optional.empty() : Optional.of(t.getLog()));
	}

	/**
	 * Returns a paged list of log entries.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getLogGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<LogPage> mono = executor.log(preparedRequest, filter, // A value for log's filter input parameter
	 * 			pageSort, // A value for log's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		LogPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getLogGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "log", graphQLTypeSimpleName = "LogPage", javaClass = LogPage.class)
	public Mono<Optional<LogPage>> log(ObjectResponse objectResponse, LogQueryFilter filter, PageableInput pageSort,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'log' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'log' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryLogFilter", filter); //$NON-NLS-1$
		parameters.put("queryLogPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getLog() == null) ? Optional.empty() : Optional.of(t.getLog()));
	}

	/**
	 * Returns a paged list of log entries.<br/>
	 * Get the {@link Builder} for the LogPage, as expected by the log query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getLogResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "log", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryLogFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"LogQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryLogPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a paged list of log entries.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the log REACTIVE_EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getLogGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "log" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryLogFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"LogQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryLogPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a paged list of persons. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<PersonPage> mono = executor.personsWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for persons's filter input parameter
	 * 			pageSort, // A value for persons's pageSort input parameter
	 * 			params);
	 * 		PersonPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "persons", graphQLTypeSimpleName = "PersonPage", javaClass = PersonPage.class)
	public Mono<Optional<PersonPage>> personsWithBindValues(String queryResponseDef, TopicalEntityQueryFilter filter,
		PageableInput pageSort, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'persons': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getPersonsResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return personsWithBindValues(objectResponse, filter, pageSort, parameters);
	}

	/**
	 * Returns a paged list of persons.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<PersonPage> mono = executor.persons(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for persons's filter input parameter
	 * 			pageSort, // A value for persons's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		PersonPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "persons", graphQLTypeSimpleName = "PersonPage", javaClass = PersonPage.class)
	public Mono<Optional<PersonPage>> persons(String queryResponseDef, TopicalEntityQueryFilter filter,
		PageableInput pageSort, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'persons': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getPersonsResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return personsWithBindValues(objectResponse, filter, pageSort,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a paged list of persons.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getPersonsGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<PersonPage> mono = executor.personsWithBindValues(preparedRequest, filter, // A value for persons's
	 * 																						// filter input parameter
	 * 			pageSort, // A value for persons's pageSort input parameter
	 * 			params);
	 * 		PersonPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getPersonsGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "persons", graphQLTypeSimpleName = "PersonPage", javaClass = PersonPage.class)

	public Mono<Optional<PersonPage>> personsWithBindValues(ObjectResponse objectResponse,
		TopicalEntityQueryFilter filter, PageableInput pageSort, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'persons' with parameters: {}, {} ", filter, pageSort); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'persons'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryPersonsFilter", filter); //$NON-NLS-1$
		parametersLocal.put("queryPersonsPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getPersons() == null) ? Optional.empty() : Optional.of(t.getPersons()));
	}

	/**
	 * Returns a paged list of persons.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getPersonsGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<PersonPage> mono = executor.persons(preparedRequest, filter, // A value for persons's filter input
	 * 																			// parameter
	 * 			pageSort, // A value for persons's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		PersonPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getPersonsGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "persons", graphQLTypeSimpleName = "PersonPage", javaClass = PersonPage.class)
	public Mono<Optional<PersonPage>> persons(ObjectResponse objectResponse, TopicalEntityQueryFilter filter,
		PageableInput pageSort, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'persons' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'persons' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryPersonsFilter", filter); //$NON-NLS-1$
		parameters.put("queryPersonsPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getPersons() == null) ? Optional.empty() : Optional.of(t.getPersons()));
	}

	/**
	 * Returns a paged list of persons.<br/>
	 * Get the {@link Builder} for the PersonPage, as expected by the persons query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getPersonsResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "persons", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryPersonsFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TopicalEntityQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryPersonsPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a paged list of persons.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the persons REACTIVE_EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getPersonsGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "persons" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryPersonsFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TopicalEntityQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryPersonsPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a person given its identifier. This method executes a partial query against the GraphQL server. That is,
	 * the query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part
	 * of the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Person> mono = executor.personByIdWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			id, // A value for personById's id input parameter
	 * 			params);
	 * 		Person field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param id Parameter for the personById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "personById", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Mono<Optional<Person>> personByIdWithBindValues(String queryResponseDef, Long id,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'personById': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getPersonByIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return personByIdWithBindValues(objectResponse, id, parameters);
	}

	/**
	 * Returns a person given its identifier.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Person> mono = executor.personById(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			id, // A value for personById's id input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Person field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param id Parameter for the personById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "personById", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Mono<Optional<Person>> personById(String queryResponseDef, Long id, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'personById': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getPersonByIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return personByIdWithBindValues(objectResponse, id,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a person given its identifier.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getPersonByIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Person> mono = executor.personByIdWithBindValues(preparedRequest, id, // A value for personById's id
	 * 																					// input parameter
	 * 			params);
	 * 		Person field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getPersonByIdGraphQLRequest(String)} method.
	 * @param id Parameter for the personById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "personById", graphQLTypeSimpleName = "Person", javaClass = Person.class)

	public Mono<Optional<Person>> personByIdWithBindValues(ObjectResponse objectResponse, Long id,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'personById' with parameters: {} ", id); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'personById'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryPersonByIdId", id); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getPersonById() == null) ? Optional.empty() : Optional.of(t.getPersonById()));
	}

	/**
	 * Returns a person given its identifier.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getPersonByIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Person> mono = executor.personById(preparedRequest, id, // A value for personById's id input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Person field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getPersonByIdGraphQLRequest(String)} method.
	 * @param id Parameter for the personById field of Query, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "personById", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Mono<Optional<Person>> personById(ObjectResponse objectResponse, Long id, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'personById' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'personById' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryPersonByIdId", id); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getPersonById() == null) ? Optional.empty() : Optional.of(t.getPersonById()));
	}

	/**
	 * Returns a person given its identifier.<br/>
	 * Get the {@link Builder} for the Person, as expected by the personById query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getPersonByIdResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "personById", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "id", "queryPersonByIdId", InputParameterType.MANDATORY, "ID", true, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				0, false));
	}

	/**
	 * Returns a person given its identifier.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the personById REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getPersonByIdGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "personById" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "id", "queryPersonByIdId", InputParameterType.MANDATORY, "ID", true, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				0, false));
	}

	/**
	 * Returns a paged list of publications. This method executes a partial query against the GraphQL server. That is,
	 * the query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part
	 * of the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<PublicationPage> mono = executor.publicationsWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for publications's filter input parameter
	 * 			pageSort, // A value for publications's pageSort input parameter
	 * 			params);
	 * 		PublicationPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "publications", graphQLTypeSimpleName = "PublicationPage",
		javaClass = PublicationPage.class)
	public Mono<Optional<PublicationPage>> publicationsWithBindValues(String queryResponseDef,
		TopicalEntityQueryFilter filter, PageableInput pageSort, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'publications': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getPublicationsResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return publicationsWithBindValues(objectResponse, filter, pageSort, parameters);
	}

	/**
	 * Returns a paged list of publications.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<PublicationPage> mono = executor.publications(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for publications's filter input parameter
	 * 			pageSort, // A value for publications's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		PublicationPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "publications", graphQLTypeSimpleName = "PublicationPage",
		javaClass = PublicationPage.class)
	public Mono<Optional<PublicationPage>> publications(String queryResponseDef, TopicalEntityQueryFilter filter,
		PageableInput pageSort, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'publications': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getPublicationsResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return publicationsWithBindValues(objectResponse, filter, pageSort,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a paged list of publications.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getPublicationsGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<PublicationPage> mono = executor.publicationsWithBindValues(preparedRequest, filter, // A value for
	 * 																									// publications's
	 * 																									// filter
	 * 																									// input
	 * 																									// parameter
	 * 			pageSort, // A value for publications's pageSort input parameter
	 * 			params);
	 * 		PublicationPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getPublicationsGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "publications", graphQLTypeSimpleName = "PublicationPage",
		javaClass = PublicationPage.class)

	public Mono<Optional<PublicationPage>> publicationsWithBindValues(ObjectResponse objectResponse,
		TopicalEntityQueryFilter filter, PageableInput pageSort, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'publications' with parameters: {}, {} ", filter, pageSort); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'publications'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryPublicationsFilter", filter); //$NON-NLS-1$
		parametersLocal.put("queryPublicationsPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getPublications() == null) ? Optional.empty() : Optional.of(t.getPublications()));
	}

	/**
	 * Returns a paged list of publications.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getPublicationsGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<PublicationPage> mono = executor.publications(preparedRequest, filter, // A value for publications's
	 * 																					// filter input parameter
	 * 			pageSort, // A value for publications's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		PublicationPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getPublicationsGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "publications", graphQLTypeSimpleName = "PublicationPage",
		javaClass = PublicationPage.class)
	public Mono<Optional<PublicationPage>> publications(ObjectResponse objectResponse, TopicalEntityQueryFilter filter,
		PageableInput pageSort, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'publications' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'publications' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryPublicationsFilter", filter); //$NON-NLS-1$
		parameters.put("queryPublicationsPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getPublications() == null) ? Optional.empty() : Optional.of(t.getPublications()));
	}

	/**
	 * Returns a paged list of publications.<br/>
	 * Get the {@link Builder} for the PublicationPage, as expected by the publications query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getPublicationsResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "publications", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryPublicationsFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TopicalEntityQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryPublicationsPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a paged list of publications.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the publications REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getPublicationsGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "publications" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryPublicationsFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TopicalEntityQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryPublicationsPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a publication given its identifier. This method executes a partial query against the GraphQL server. That
	 * is, the query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the
	 * part of the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Publication> mono = executor.publicationByIdWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			id, // A value for publicationById's id input parameter
	 * 			params);
	 * 		Publication field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param id Parameter for the publicationById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "publicationById", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Mono<Optional<Publication>> publicationByIdWithBindValues(String queryResponseDef, Long id,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'publicationById': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getPublicationByIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return publicationByIdWithBindValues(objectResponse, id, parameters);
	}

	/**
	 * Returns a publication given its identifier.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.publicationById(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			id, // A value for publicationById's id input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publication field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param id Parameter for the publicationById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "publicationById", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Mono<Optional<Publication>> publicationById(String queryResponseDef, Long id, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'publicationById': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getPublicationByIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return publicationByIdWithBindValues(objectResponse, id,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a publication given its identifier.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getPublicationByIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.publicationByIdWithBindValues(preparedRequest, id, // A value for
	 * 																								// publicationById's
	 * 																								// id input
	 * 																								// parameter
	 * 			params);
	 * 		Publication field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getPublicationByIdGraphQLRequest(String)} method.
	 * @param id Parameter for the publicationById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "publicationById", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)

	public Mono<Optional<Publication>> publicationByIdWithBindValues(ObjectResponse objectResponse, Long id,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'publicationById' with parameters: {} ", id); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'publicationById'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryPublicationByIdId", id); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getPublicationById() == null) ? Optional.empty() : Optional.of(t.getPublicationById()));
	}

	/**
	 * Returns a publication given its identifier.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getPublicationByIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.publicationById(preparedRequest, id, // A value for publicationById's
	 * 																				// id input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publication field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getPublicationByIdGraphQLRequest(String)} method.
	 * @param id Parameter for the publicationById field of Query, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "publicationById", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Mono<Optional<Publication>> publicationById(ObjectResponse objectResponse, Long id,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'publicationById' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'publicationById' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryPublicationByIdId", id); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getPublicationById() == null) ? Optional.empty() : Optional.of(t.getPublicationById()));
	}

	/**
	 * Returns a publication given its identifier.<br/>
	 * Get the {@link Builder} for the Publication, as expected by the publicationById query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getPublicationByIdResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "publicationById", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "id", "queryPublicationByIdId", InputParameterType.MANDATORY, "ID", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				true, 0, false));
	}

	/**
	 * Returns a publication given its identifier.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the publicationById REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getPublicationByIdGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "publicationById" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "id", "queryPublicationByIdId", InputParameterType.MANDATORY, "ID", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				true, 0, false));
	}

	/**
	 * Returns a paged list of publishers. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<PublisherPage> mono = executor.publishersWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for publishers's filter input parameter
	 * 			pageSort, // A value for publishers's pageSort input parameter
	 * 			params);
	 * 		PublisherPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "publishers", graphQLTypeSimpleName = "PublisherPage",
		javaClass = PublisherPage.class)
	public Mono<Optional<PublisherPage>> publishersWithBindValues(String queryResponseDef,
		TrackedEntityQueryFilter filter, PageableInput pageSort, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'publishers': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getPublishersResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return publishersWithBindValues(objectResponse, filter, pageSort, parameters);
	}

	/**
	 * Returns a paged list of publishers.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<PublisherPage> mono = executor.publishers(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for publishers's filter input parameter
	 * 			pageSort, // A value for publishers's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		PublisherPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "publishers", graphQLTypeSimpleName = "PublisherPage",
		javaClass = PublisherPage.class)
	public Mono<Optional<PublisherPage>> publishers(String queryResponseDef, TrackedEntityQueryFilter filter,
		PageableInput pageSort, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'publishers': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getPublishersResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return publishersWithBindValues(objectResponse, filter, pageSort,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a paged list of publishers.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getPublishersGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<PublisherPage> mono = executor.publishersWithBindValues(preparedRequest, filter, // A value for
	 * 																								// publishers's
	 * 																								// filter input
	 * 																								// parameter
	 * 			pageSort, // A value for publishers's pageSort input parameter
	 * 			params);
	 * 		PublisherPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getPublishersGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "publishers", graphQLTypeSimpleName = "PublisherPage",
		javaClass = PublisherPage.class)

	public Mono<Optional<PublisherPage>> publishersWithBindValues(ObjectResponse objectResponse,
		TrackedEntityQueryFilter filter, PageableInput pageSort, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'publishers' with parameters: {}, {} ", filter, pageSort); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'publishers'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryPublishersFilter", filter); //$NON-NLS-1$
		parametersLocal.put("queryPublishersPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getPublishers() == null) ? Optional.empty() : Optional.of(t.getPublishers()));
	}

	/**
	 * Returns a paged list of publishers.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getPublishersGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<PublisherPage> mono = executor.publishers(preparedRequest, filter, // A value for publishers's
	 * 																				// filter input parameter
	 * 			pageSort, // A value for publishers's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		PublisherPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getPublishersGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "publishers", graphQLTypeSimpleName = "PublisherPage",
		javaClass = PublisherPage.class)
	public Mono<Optional<PublisherPage>> publishers(ObjectResponse objectResponse, TrackedEntityQueryFilter filter,
		PageableInput pageSort, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'publishers' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'publishers' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryPublishersFilter", filter); //$NON-NLS-1$
		parameters.put("queryPublishersPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getPublishers() == null) ? Optional.empty() : Optional.of(t.getPublishers()));
	}

	/**
	 * Returns a paged list of publishers.<br/>
	 * Get the {@link Builder} for the PublisherPage, as expected by the publishers query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getPublishersResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "publishers", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryPublishersFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TrackedEntityQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryPublishersPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a paged list of publishers.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the publishers REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getPublishersGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "publishers" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryPublishersFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TrackedEntityQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryPublishersPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a publisher given its identifier. This method executes a partial query against the GraphQL server. That
	 * is, the query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the
	 * part of the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Publisher> mono = executor.publisherByIdWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			id, // A value for publisherById's id input parameter
	 * 			params);
	 * 		Publisher field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param id Parameter for the publisherById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "publisherById", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Mono<Optional<Publisher>> publisherByIdWithBindValues(String queryResponseDef, Long id,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'publisherById': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getPublisherByIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return publisherByIdWithBindValues(objectResponse, id, parameters);
	}

	/**
	 * Returns a publisher given its identifier.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publisher> mono = executor.publisherById(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			id, // A value for publisherById's id input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publisher field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param id Parameter for the publisherById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "publisherById", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Mono<Optional<Publisher>> publisherById(String queryResponseDef, Long id, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'publisherById': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getPublisherByIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return publisherByIdWithBindValues(objectResponse, id,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a publisher given its identifier.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getPublisherByIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publisher> mono = executor.publisherByIdWithBindValues(preparedRequest, id, // A value for
	 * 																							// publisherById's id
	 * 																							// input parameter
	 * 			params);
	 * 		Publisher field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getPublisherByIdGraphQLRequest(String)} method.
	 * @param id Parameter for the publisherById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "publisherById", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)

	public Mono<Optional<Publisher>> publisherByIdWithBindValues(ObjectResponse objectResponse, Long id,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'publisherById' with parameters: {} ", id); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'publisherById'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryPublisherByIdId", id); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getPublisherById() == null) ? Optional.empty() : Optional.of(t.getPublisherById()));
	}

	/**
	 * Returns a publisher given its identifier.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getPublisherByIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publisher> mono = executor.publisherById(preparedRequest, id, // A value for publisherById's id
	 * 																			// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publisher field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getPublisherByIdGraphQLRequest(String)} method.
	 * @param id Parameter for the publisherById field of Query, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "publisherById", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Mono<Optional<Publisher>> publisherById(ObjectResponse objectResponse, Long id, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'publisherById' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'publisherById' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryPublisherByIdId", id); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getPublisherById() == null) ? Optional.empty() : Optional.of(t.getPublisherById()));
	}

	/**
	 * Returns a publisher given its identifier.<br/>
	 * Get the {@link Builder} for the Publisher, as expected by the publisherById query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getPublisherByIdResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "publisherById", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "id", "queryPublisherByIdId", InputParameterType.MANDATORY, "ID", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				true, 0, false));
	}

	/**
	 * Returns a publisher given its identifier.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the publisherById REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getPublisherByIdGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "publisherById" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "id", "queryPublisherByIdId", InputParameterType.MANDATORY, "ID", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				true, 0, false));
	}

	/**
	 * Returns a paged list of quotations. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<QuotationPage> mono = executor.quotationsWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for quotations's filter input parameter
	 * 			pageSort, // A value for quotations's pageSort input parameter
	 * 			params);
	 * 		QuotationPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "quotations", graphQLTypeSimpleName = "QuotationPage",
		javaClass = QuotationPage.class)
	public Mono<Optional<QuotationPage>> quotationsWithBindValues(String queryResponseDef,
		TopicalEntityQueryFilter filter, PageableInput pageSort, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'quotations': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getQuotationsResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return quotationsWithBindValues(objectResponse, filter, pageSort, parameters);
	}

	/**
	 * Returns a paged list of quotations.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<QuotationPage> mono = executor.quotations(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for quotations's filter input parameter
	 * 			pageSort, // A value for quotations's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		QuotationPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "quotations", graphQLTypeSimpleName = "QuotationPage",
		javaClass = QuotationPage.class)
	public Mono<Optional<QuotationPage>> quotations(String queryResponseDef, TopicalEntityQueryFilter filter,
		PageableInput pageSort, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'quotations': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getQuotationsResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return quotationsWithBindValues(objectResponse, filter, pageSort,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a paged list of quotations.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getQuotationsGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<QuotationPage> mono = executor.quotationsWithBindValues(preparedRequest, filter, // A value for
	 * 																								// quotations's
	 * 																								// filter input
	 * 																								// parameter
	 * 			pageSort, // A value for quotations's pageSort input parameter
	 * 			params);
	 * 		QuotationPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getQuotationsGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "quotations", graphQLTypeSimpleName = "QuotationPage",
		javaClass = QuotationPage.class)

	public Mono<Optional<QuotationPage>> quotationsWithBindValues(ObjectResponse objectResponse,
		TopicalEntityQueryFilter filter, PageableInput pageSort, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'quotations' with parameters: {}, {} ", filter, pageSort); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'quotations'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryQuotationsFilter", filter); //$NON-NLS-1$
		parametersLocal.put("queryQuotationsPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getQuotations() == null) ? Optional.empty() : Optional.of(t.getQuotations()));
	}

	/**
	 * Returns a paged list of quotations.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getQuotationsGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<QuotationPage> mono = executor.quotations(preparedRequest, filter, // A value for quotations's
	 * 																				// filter input parameter
	 * 			pageSort, // A value for quotations's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		QuotationPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getQuotationsGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "quotations", graphQLTypeSimpleName = "QuotationPage",
		javaClass = QuotationPage.class)
	public Mono<Optional<QuotationPage>> quotations(ObjectResponse objectResponse, TopicalEntityQueryFilter filter,
		PageableInput pageSort, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'quotations' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'quotations' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryQuotationsFilter", filter); //$NON-NLS-1$
		parameters.put("queryQuotationsPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getQuotations() == null) ? Optional.empty() : Optional.of(t.getQuotations()));
	}

	/**
	 * Returns a paged list of quotations.<br/>
	 * Get the {@link Builder} for the QuotationPage, as expected by the quotations query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getQuotationsResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "quotations", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryQuotationsFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TopicalEntityQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryQuotationsPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a paged list of quotations.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the quotations REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getQuotationsGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "quotations" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryQuotationsFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TopicalEntityQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryQuotationsPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a quotation given its identifier. This method executes a partial query against the GraphQL server. That
	 * is, the query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the
	 * part of the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Quotation> mono = executor.quotationByIdWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			id, // A value for quotationById's id input parameter
	 * 			params);
	 * 		Quotation field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param id Parameter for the quotationById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "quotationById", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Mono<Optional<Quotation>> quotationByIdWithBindValues(String queryResponseDef, Long id,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'quotationById': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getQuotationByIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return quotationByIdWithBindValues(objectResponse, id, parameters);
	}

	/**
	 * Returns a quotation given its identifier.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Quotation> mono = executor.quotationById(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			id, // A value for quotationById's id input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Quotation field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param id Parameter for the quotationById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "quotationById", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Mono<Optional<Quotation>> quotationById(String queryResponseDef, Long id, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'quotationById': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getQuotationByIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return quotationByIdWithBindValues(objectResponse, id,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a quotation given its identifier.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getQuotationByIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Quotation> mono = executor.quotationByIdWithBindValues(preparedRequest, id, // A value for
	 * 																							// quotationById's id
	 * 																							// input parameter
	 * 			params);
	 * 		Quotation field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getQuotationByIdGraphQLRequest(String)} method.
	 * @param id Parameter for the quotationById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "quotationById", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)

	public Mono<Optional<Quotation>> quotationByIdWithBindValues(ObjectResponse objectResponse, Long id,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'quotationById' with parameters: {} ", id); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'quotationById'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryQuotationByIdId", id); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getQuotationById() == null) ? Optional.empty() : Optional.of(t.getQuotationById()));
	}

	/**
	 * Returns a quotation given its identifier.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getQuotationByIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Quotation> mono = executor.quotationById(preparedRequest, id, // A value for quotationById's id
	 * 																			// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Quotation field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getQuotationByIdGraphQLRequest(String)} method.
	 * @param id Parameter for the quotationById field of Query, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "quotationById", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Mono<Optional<Quotation>> quotationById(ObjectResponse objectResponse, Long id, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'quotationById' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'quotationById' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryQuotationByIdId", id); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getQuotationById() == null) ? Optional.empty() : Optional.of(t.getQuotationById()));
	}

	/**
	 * Returns a quotation given its identifier.<br/>
	 * Get the {@link Builder} for the Quotation, as expected by the quotationById query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getQuotationByIdResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "quotationById", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "id", "queryQuotationByIdId", InputParameterType.MANDATORY, "ID", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				true, 0, false));
	}

	/**
	 * Returns a quotation given its identifier.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the quotationById REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getQuotationByIdGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "quotationById" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "id", "queryQuotationByIdId", InputParameterType.MANDATORY, "ID", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				true, 0, false));
	}

	/**
	 * Returns a paged list of topics or sub-topics. This method executes a partial query against the GraphQL server.
	 * That is, the query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains
	 * the part of the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<TopicPage> mono = executor.topicsWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for topics's filter input parameter
	 * 			pageSort, // A value for topics's pageSort input parameter
	 * 			params);
	 * 		TopicPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "topics", graphQLTypeSimpleName = "TopicPage", javaClass = TopicPage.class)
	public Mono<Optional<TopicPage>> topicsWithBindValues(String queryResponseDef, TopicQueryFilter filter,
		PageableInput pageSort, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'topics': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getTopicsResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return topicsWithBindValues(objectResponse, filter, pageSort, parameters);
	}

	/**
	 * Returns a paged list of topics or sub-topics.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<TopicPage> mono = executor.topics(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for topics's filter input parameter
	 * 			pageSort, // A value for topics's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		TopicPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "topics", graphQLTypeSimpleName = "TopicPage", javaClass = TopicPage.class)
	public Mono<Optional<TopicPage>> topics(String queryResponseDef, TopicQueryFilter filter, PageableInput pageSort,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'topics': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getTopicsResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return topicsWithBindValues(objectResponse, filter, pageSort,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a paged list of topics or sub-topics.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getTopicsGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<TopicPage> mono = executor.topicsWithBindValues(preparedRequest, filter, // A value for topics's
	 * 																						// filter input parameter
	 * 			pageSort, // A value for topics's pageSort input parameter
	 * 			params);
	 * 		TopicPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getTopicsGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "topics", graphQLTypeSimpleName = "TopicPage", javaClass = TopicPage.class)

	public Mono<Optional<TopicPage>> topicsWithBindValues(ObjectResponse objectResponse, TopicQueryFilter filter,
		PageableInput pageSort, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'topics' with parameters: {}, {} ", filter, pageSort); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'topics'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryTopicsFilter", filter); //$NON-NLS-1$
		parametersLocal.put("queryTopicsPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getTopics() == null) ? Optional.empty() : Optional.of(t.getTopics()));
	}

	/**
	 * Returns a paged list of topics or sub-topics.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getTopicsGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<TopicPage> mono = executor.topics(preparedRequest, filter, // A value for topics's filter input
	 * 																		// parameter
	 * 			pageSort, // A value for topics's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		TopicPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getTopicsGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "topics", graphQLTypeSimpleName = "TopicPage", javaClass = TopicPage.class)
	public Mono<Optional<TopicPage>> topics(ObjectResponse objectResponse, TopicQueryFilter filter,
		PageableInput pageSort, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'topics' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'topics' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryTopicsFilter", filter); //$NON-NLS-1$
		parameters.put("queryTopicsPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getTopics() == null) ? Optional.empty() : Optional.of(t.getTopics()));
	}

	/**
	 * Returns a paged list of topics or sub-topics.<br/>
	 * Get the {@link Builder} for the TopicPage, as expected by the topics query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getTopicsResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "topics", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryTopicsFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TopicQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryTopicsPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a paged list of topics or sub-topics.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the topics REACTIVE_EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getTopicsGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "topics" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryTopicsFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TopicQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryTopicsPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a topic given its identifier. This method executes a partial query against the GraphQL server. That is,
	 * the query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part
	 * of the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Topic> mono = executor.topicByIdWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			id, // A value for topicById's id input parameter
	 * 			params);
	 * 		Topic field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param id Parameter for the topicById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "topicById", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Mono<Optional<Topic>> topicByIdWithBindValues(String queryResponseDef, Long id,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'topicById': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getTopicByIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return topicByIdWithBindValues(objectResponse, id, parameters);
	}

	/**
	 * Returns a topic given its identifier.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Topic> mono = executor.topicById(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			id, // A value for topicById's id input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Topic field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param id Parameter for the topicById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "topicById", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Mono<Optional<Topic>> topicById(String queryResponseDef, Long id, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'topicById': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getTopicByIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return topicByIdWithBindValues(objectResponse, id,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a topic given its identifier.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getTopicByIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Topic> mono = executor.topicByIdWithBindValues(preparedRequest, id, // A value for topicById's id
	 * 																					// input parameter
	 * 			params);
	 * 		Topic field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getTopicByIdGraphQLRequest(String)} method.
	 * @param id Parameter for the topicById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "topicById", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)

	public Mono<Optional<Topic>> topicByIdWithBindValues(ObjectResponse objectResponse, Long id,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'topicById' with parameters: {} ", id); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'topicById'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryTopicByIdId", id); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getTopicById() == null) ? Optional.empty() : Optional.of(t.getTopicById()));
	}

	/**
	 * Returns a topic given its identifier.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getTopicByIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Topic> mono = executor.topicById(preparedRequest, id, // A value for topicById's id input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Topic field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getTopicByIdGraphQLRequest(String)} method.
	 * @param id Parameter for the topicById field of Query, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "topicById", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Mono<Optional<Topic>> topicById(ObjectResponse objectResponse, Long id, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'topicById' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'topicById' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryTopicByIdId", id); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getTopicById() == null) ? Optional.empty() : Optional.of(t.getTopicById()));
	}

	/**
	 * Returns a topic given its identifier.<br/>
	 * Get the {@link Builder} for the Topic, as expected by the topicById query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getTopicByIdResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "topicById", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "id", "queryTopicByIdId", InputParameterType.MANDATORY, "ID", true, 0, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				false));
	}

	/**
	 * Returns a topic given its identifier.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the topicById REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getTopicByIdGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "topicById" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "id", "queryTopicByIdId", InputParameterType.MANDATORY, "ID", true, 0, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				false));
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<TopicRefPage> mono = executor.topicRefsWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for topicRefs's filter input parameter
	 * 			pageSort, // A value for topicRefs's pageSort input parameter
	 * 			params);
	 * 		TopicRefPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and paginates results
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "topicRefs", graphQLTypeSimpleName = "TopicRefPage", javaClass = TopicRefPage.class)
	public Mono<Optional<TopicRefPage>> topicRefsWithBindValues(String queryResponseDef, TopicRefQueryFilter filter,
		PageableInput pageSort, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'topicRefs': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getTopicRefsResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return topicRefsWithBindValues(objectResponse, filter, pageSort, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<TopicRefPage> mono = executor.topicRefs(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for topicRefs's filter input parameter
	 * 			pageSort, // A value for topicRefs's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		TopicRefPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and paginates results
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "topicRefs", graphQLTypeSimpleName = "TopicRefPage", javaClass = TopicRefPage.class)
	public Mono<Optional<TopicRefPage>> topicRefs(String queryResponseDef, TopicRefQueryFilter filter,
		PageableInput pageSort, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'topicRefs': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getTopicRefsResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return topicRefsWithBindValues(objectResponse, filter, pageSort,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getTopicRefsGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<TopicRefPage> mono = executor.topicRefsWithBindValues(preparedRequest, filter, // A value for
	 * 																							// topicRefs's filter
	 * 																							// input parameter
	 * 			pageSort, // A value for topicRefs's pageSort input parameter
	 * 			params);
	 * 		TopicRefPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getTopicRefsGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and paginates results
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "topicRefs", graphQLTypeSimpleName = "TopicRefPage", javaClass = TopicRefPage.class)

	public Mono<Optional<TopicRefPage>> topicRefsWithBindValues(ObjectResponse objectResponse,
		TopicRefQueryFilter filter, PageableInput pageSort, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'topicRefs' with parameters: {}, {} ", filter, pageSort); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'topicRefs'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryTopicRefsFilter", filter); //$NON-NLS-1$
		parametersLocal.put("queryTopicRefsPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getTopicRefs() == null) ? Optional.empty() : Optional.of(t.getTopicRefs()));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getTopicRefsGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<TopicRefPage> mono = executor.topicRefs(preparedRequest, filter, // A value for topicRefs's filter
	 * 																				// input parameter
	 * 			pageSort, // A value for topicRefs's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		TopicRefPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getTopicRefsGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and paginates results
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "topicRefs", graphQLTypeSimpleName = "TopicRefPage", javaClass = TopicRefPage.class)
	public Mono<Optional<TopicRefPage>> topicRefs(ObjectResponse objectResponse, TopicRefQueryFilter filter,
		PageableInput pageSort, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'topicRefs' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'topicRefs' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryTopicRefsFilter", filter); //$NON-NLS-1$
		parameters.put("queryTopicRefsPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getTopicRefs() == null) ? Optional.empty() : Optional.of(t.getTopicRefs()));
	}

	/**
	 * Get the {@link Builder} for the TopicRefPage, as expected by the topicRefs query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getTopicRefsResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "topicRefs", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryTopicRefsFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TopicRefQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryTopicRefsPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Get the {@link GraphQLReactiveRequest} for the topicRefs REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getTopicRefsGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "topicRefs" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryTopicRefsFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TopicRefQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryTopicRefsPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a topic reference given its identifier. This method executes a partial query against the GraphQL server.
	 * That is, the query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains
	 * the part of the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<TopicRef> mono = executor.topicRefByIdWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			id, // A value for topicRefById's id input parameter
	 * 			params);
	 * 		TopicRef field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param id Parameter for the topicRefById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "topicRefById", graphQLTypeSimpleName = "TopicRef", javaClass = TopicRef.class)
	public Mono<Optional<TopicRef>> topicRefByIdWithBindValues(String queryResponseDef, Long id, EntityKind entityKind,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'topicRefById': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getTopicRefByIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return topicRefByIdWithBindValues(objectResponse, id, entityKind, parameters);
	}

	/**
	 * Returns a topic reference given its identifier.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<TopicRef> mono = executor.topicRefById(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			id, // A value for topicRefById's id input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		TopicRef field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param id Parameter for the topicRefById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "topicRefById", graphQLTypeSimpleName = "TopicRef", javaClass = TopicRef.class)
	public Mono<Optional<TopicRef>> topicRefById(String queryResponseDef, Long id, EntityKind entityKind,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'topicRefById': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getTopicRefByIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return topicRefByIdWithBindValues(objectResponse, id, entityKind,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a topic reference given its identifier.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getTopicRefByIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<TopicRef> mono = executor.topicRefByIdWithBindValues(preparedRequest, id, // A value for
	 * 																						// topicRefById's id
	 * 																						// input parameter
	 * 			params);
	 * 		TopicRef field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getTopicRefByIdGraphQLRequest(String)} method.
	 * @param id Parameter for the topicRefById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "topicRefById", graphQLTypeSimpleName = "TopicRef", javaClass = TopicRef.class)
	public Mono<Optional<TopicRef>> topicRefByIdWithBindValues(ObjectResponse objectResponse, Long id,
		EntityKind entityKind, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'topicRefById' with parameters: {}, {} ", id, entityKind); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'topicRefById'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryTopicRefByIdId", id); //$NON-NLS-1$
		parametersLocal.put("queryTopicRefByIdEntityKind", entityKind); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getTopicRefById() == null) ? Optional.empty() : Optional.of(t.getTopicRefById()));
	}

	/**
	 * Returns a topic reference given its identifier.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getTopicRefByIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<TopicRef> mono = executor.topicRefById(preparedRequest, id, // A value for topicRefById's id input
	 * 																			// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		TopicRef field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getTopicRefByIdGraphQLRequest(String)} method.
	 * @param id Parameter for the topicRefById field of Query, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "topicRefById", graphQLTypeSimpleName = "TopicRef", javaClass = TopicRef.class)
	public Mono<Optional<TopicRef>> topicRefById(ObjectResponse objectResponse, Long id, EntityKind entityKind,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'topicRefById' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'topicRefById' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryTopicRefByIdId", id); //$NON-NLS-1$
		parameters.put("queryTopicRefByIdEntityKind", entityKind); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getTopicRefById() == null) ? Optional.empty() : Optional.of(t.getTopicRefById()));
	}

	/**
	 * Returns a topic reference given its identifier.<br/>
	 * Get the {@link Builder} for the TopicRef, as expected by the topicRefById query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getTopicRefByIdResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "topicRefById", RequestType.query, //$NON-NLS-1$
			InputParameter.newBindParameter("", "id", "queryTopicRefByIdId", InputParameterType.MANDATORY, "ID", true, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				0, false),
			InputParameter.newBindParameter("", "entityKind", "queryTopicRefByIdEntityKind", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "EntityKind", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a topic reference given its identifier.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the topicRefById REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getTopicRefByIdGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "topicRefById", //$NON-NLS-1$
			InputParameter.newBindParameter("", "id", "queryTopicRefByIdId", InputParameterType.MANDATORY, "ID", true, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				0, false),
			InputParameter.newBindParameter("", "entityKind", "queryTopicRefByIdEntityKind", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "EntityKind", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a topic reference given its topic and entity identifiers. This method executes a partial query against
	 * the GraphQL server. That is, the query that is one of the queries defined in the GraphQL query object. The
	 * queryResponseDef contains the part of the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<TopicRef> mono = executor.topicRefByEntityIdWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topicId, // A value for topicRefByEntityId's topicId input parameter
	 * 			entityId, // A value for topicRefByEntityId's entityId input parameter
	 * 			entityKind, // A value for topicRefByEntityId's entityKind input parameter
	 * 			params);
	 * 		TopicRef field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topicId Parameter for the topicRefByEntityId field of Query, as defined in the GraphQL schema
	 * @param entityId Parameter for the topicRefByEntityId field of Query, as defined in the GraphQL schema
	 * @param entityKind Parameter for the topicRefByEntityId field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "topicRefByEntityId", graphQLTypeSimpleName = "TopicRef", javaClass = TopicRef.class)
	public Mono<Optional<TopicRef>> topicRefByEntityIdWithBindValues(String queryResponseDef, Long topicId,
		Long entityId, EntityKind entityKind, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'topicRefByEntityId': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getTopicRefByEntityIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return topicRefByEntityIdWithBindValues(objectResponse, topicId, entityId, entityKind, parameters);
	}

	/**
	 * Returns a topic reference given its topic and entity identifiers.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<TopicRef> mono = executor.topicRefByEntityId(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topicId, // A value for topicRefByEntityId's topicId input parameter
	 * 			entityId, // A value for topicRefByEntityId's entityId input parameter
	 * 			entityKind, // A value for topicRefByEntityId's entityKind input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		TopicRef field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param topicId Parameter for the topicRefByEntityId field of Query, as defined in the GraphQL schema
	 * @param entityId Parameter for the topicRefByEntityId field of Query, as defined in the GraphQL schema
	 * @param entityKind Parameter for the topicRefByEntityId field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "topicRefByEntityId", graphQLTypeSimpleName = "TopicRef", javaClass = TopicRef.class)
	public Mono<Optional<TopicRef>> topicRefByEntityId(String queryResponseDef, Long topicId, Long entityId,
		EntityKind entityKind, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'topicRefByEntityId': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getTopicRefByEntityIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return topicRefByEntityIdWithBindValues(objectResponse, topicId, entityId, entityKind,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a topic reference given its topic and entity identifiers.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getTopicRefByEntityIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<TopicRef> mono = executor.topicRefByEntityIdWithBindValues(preparedRequest, topicId, // A value for
	 * 																									// topicRefByEntityId's
	 * 																									// topicId
	 * 																									// input
	 * 																									// parameter
	 * 			entityId, // A value for topicRefByEntityId's entityId input parameter
	 * 			entityKind, // A value for topicRefByEntityId's entityKind input parameter
	 * 			params);
	 * 		TopicRef field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getTopicRefByEntityIdGraphQLRequest(String)} method.
	 * @param topicId Parameter for the topicRefByEntityId field of Query, as defined in the GraphQL schema
	 * @param entityId Parameter for the topicRefByEntityId field of Query, as defined in the GraphQL schema
	 * @param entityKind Parameter for the topicRefByEntityId field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "topicRefByEntityId", graphQLTypeSimpleName = "TopicRef", javaClass = TopicRef.class)
	public Mono<Optional<TopicRef>> topicRefByEntityIdWithBindValues(ObjectResponse objectResponse, Long topicId,
		Long entityId, EntityKind entityKind, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'topicRefByEntityId' with parameters: {}, {}, {} ", topicId, entityId, //$NON-NLS-1$
				entityKind);
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'topicRefByEntityId'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryTopicRefByEntityIdTopicId", topicId); //$NON-NLS-1$
		parametersLocal.put("queryTopicRefByEntityIdEntityId", entityId); //$NON-NLS-1$
		parametersLocal.put("queryTopicRefByEntityIdEntityKind", entityKind); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getTopicRefByEntityId() == null) ? Optional.empty() : Optional.of(t.getTopicRefByEntityId()));
	}

	/**
	 * Returns a topic reference given its topic and entity identifiers.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getTopicRefByEntityIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<TopicRef> mono = executor.topicRefByEntityId(preparedRequest, topicId, // A value for
	 * 																					// topicRefByEntityId's
	 * 																					// topicId input parameter
	 * 			entityId, // A value for topicRefByEntityId's entityId input parameter
	 * 			entityKind, // A value for topicRefByEntityId's entityKind input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		TopicRef field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getTopicRefByEntityIdGraphQLRequest(String)} method.
	 * @param topicId Parameter for the topicRefByEntityId field of Query, as defined in the GraphQL schema
	 * @param entityId Parameter for the topicRefByEntityId field of Query, as defined in the GraphQL schema
	 * @param entityKind Parameter for the topicRefByEntityId field of Query, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "topicRefByEntityId", graphQLTypeSimpleName = "TopicRef", javaClass = TopicRef.class)
	public Mono<Optional<TopicRef>> topicRefByEntityId(ObjectResponse objectResponse, Long topicId, Long entityId,
		EntityKind entityKind, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'topicRefByEntityId' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'topicRefByEntityId' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryTopicRefByEntityIdTopicId", topicId); //$NON-NLS-1$
		parameters.put("queryTopicRefByEntityIdEntityId", entityId); //$NON-NLS-1$
		parameters.put("queryTopicRefByEntityIdEntityKind", entityKind); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getTopicRefByEntityId() == null) ? Optional.empty() : Optional.of(t.getTopicRefByEntityId()));
	}

	/**
	 * Returns a topic reference given its topic and entity identifiers.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the TopicRef, as expected by the
	 * topicRefByEntityId query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getTopicRefByEntityIdResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "topicRefByEntityId", RequestType.query, //$NON-NLS-1$
			InputParameter.newBindParameter("", "topicId", "queryTopicRefByEntityIdTopicId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false), //$NON-NLS-1$
			InputParameter.newBindParameter("", "entityId", "queryTopicRefByEntityIdEntityId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false), //$NON-NLS-1$
			InputParameter.newBindParameter("", "entityKind", "queryTopicRefByEntityIdEntityKind", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "EntityKind", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a topic reference given its topic and entity identifiers.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the topicRefByEntityId REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getTopicRefByEntityIdGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "topicRefByEntityId", //$NON-NLS-1$
			InputParameter.newBindParameter("", "topicId", "queryTopicRefByEntityIdTopicId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false), //$NON-NLS-1$
			InputParameter.newBindParameter("", "entityId", "queryTopicRefByEntityIdEntityId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false), //$NON-NLS-1$
			InputParameter.newBindParameter("", "entityKind", "queryTopicRefByEntityIdEntityKind", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "EntityKind", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a paged list of users. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<UserPage> mono = executor.usersWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for users's filter input parameter
	 * 			pageSort, // A value for users's pageSort input parameter
	 * 			params);
	 * 		UserPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "users", graphQLTypeSimpleName = "UserPage", javaClass = UserPage.class)
	public Mono<Optional<UserPage>> usersWithBindValues(String queryResponseDef, TrackedEntityQueryFilter filter,
		PageableInput pageSort, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'users': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getUsersResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return usersWithBindValues(objectResponse, filter, pageSort, parameters);
	}

	/**
	 * Returns a paged list of users.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<UserPage> mono = executor.users(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			filter, // A value for users's filter input parameter
	 * 			pageSort, // A value for users's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		UserPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "users", graphQLTypeSimpleName = "UserPage", javaClass = UserPage.class)
	public Mono<Optional<UserPage>> users(String queryResponseDef, TrackedEntityQueryFilter filter,
		PageableInput pageSort, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'users': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getUsersResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return usersWithBindValues(objectResponse, filter, pageSort,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a paged list of users.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUsersGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<UserPage> mono = executor.usersWithBindValues(preparedRequest, filter, // A value for users's filter
	 * 																					// input parameter
	 * 			pageSort, // A value for users's pageSort input parameter
	 * 			params);
	 * 		UserPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUsersGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "users", graphQLTypeSimpleName = "UserPage", javaClass = UserPage.class)

	public Mono<Optional<UserPage>> usersWithBindValues(ObjectResponse objectResponse, TrackedEntityQueryFilter filter,
		PageableInput pageSort, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'users' with parameters: {}, {} ", filter, pageSort); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'users'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryUsersFilter", filter); //$NON-NLS-1$
		parametersLocal.put("queryUsersPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getUsers() == null) ? Optional.empty() : Optional.of(t.getUsers()));
	}

	/**
	 * Returns a paged list of users.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUsersGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<UserPage> mono = executor.users(preparedRequest, filter, // A value for users's filter input
	 * 																		// parameter
	 * 			pageSort, // A value for users's pageSort input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		UserPage field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUsersGraphQLRequest(String)} method.
	 * @param filter Filters results.
	 * @param pageSort Sorts and/or paginates results.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "users", graphQLTypeSimpleName = "UserPage", javaClass = UserPage.class)
	public Mono<Optional<UserPage>> users(ObjectResponse objectResponse, TrackedEntityQueryFilter filter,
		PageableInput pageSort, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'users' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'users' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryUsersFilter", filter); //$NON-NLS-1$
		parameters.put("queryUsersPageSort", pageSort); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getUsers() == null) ? Optional.empty() : Optional.of(t.getUsers()));
	}

	/**
	 * Returns a paged list of users.<br/>
	 * Get the {@link Builder} for the UserPage, as expected by the users query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUsersResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "users", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryUsersFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TrackedEntityQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryUsersPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a paged list of users.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the users REACTIVE_EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUsersGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "users" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "filter", "queryUsersFilter", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TrackedEntityQueryFilter", false, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "pageSort", "queryUsersPageSort", InputParameterType.OPTIONAL, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PageableInput", false, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a user given its identifier. This method executes a partial query against the GraphQL server. That is,
	 * the query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part
	 * of the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<User> mono = executor.userByIdWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			id, // A value for userById's id input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param id Parameter for the userById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "userById", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> userByIdWithBindValues(String queryResponseDef, Long id, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'userById': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getUserByIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return userByIdWithBindValues(objectResponse, id, parameters);
	}

	/**
	 * Returns a user given its identifier.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.userById(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			id, // A value for userById's id input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param id Parameter for the userById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "userById", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> userById(String queryResponseDef, Long id, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'userById': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getUserByIdResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return userByIdWithBindValues(objectResponse, id,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a user given its identifier.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUserByIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.userByIdWithBindValues(preparedRequest, id, // A value for userById's id input
	 * 																				// parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUserByIdGraphQLRequest(String)} method.
	 * @param id Parameter for the userById field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "userById", graphQLTypeSimpleName = "User", javaClass = User.class)

	public Mono<Optional<User>> userByIdWithBindValues(ObjectResponse objectResponse, Long id,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'userById' with parameters: {} ", id); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'userById'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryUserByIdId", id); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getUserById() == null) ? Optional.empty() : Optional.of(t.getUserById()));
	}

	/**
	 * Returns a user given its identifier.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUserByIdGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.userById(preparedRequest, id, // A value for userById's id input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUserByIdGraphQLRequest(String)} method.
	 * @param id Parameter for the userById field of Query, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "userById", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> userById(ObjectResponse objectResponse, Long id, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'userById' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'userById' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryUserByIdId", id); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getUserById() == null) ? Optional.empty() : Optional.of(t.getUserById()));
	}

	/**
	 * Returns a user given its identifier.<br/>
	 * Get the {@link Builder} for the User, as expected by the userById query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUserByIdResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "userById", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "id", "queryUserByIdId", InputParameterType.MANDATORY, "ID", true, 0, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				false));
	}

	/**
	 * Returns a user given its identifier.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the userById REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUserByIdGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "userById" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "id", "queryUserByIdId", InputParameterType.MANDATORY, "ID", true, 0, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				false));
	}

	/**
	 * Returns a user given its username. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<User> mono = executor.userByUsernameWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			username, // A value for userByUsername's username input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param username Parameter for the userByUsername field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "userByUsername", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> userByUsernameWithBindValues(String queryResponseDef, String username,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'userByUsername': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getUserByUsernameResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return userByUsernameWithBindValues(objectResponse, username, parameters);
	}

	/**
	 * Returns a user given its username.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.userByUsername(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			username, // A value for userByUsername's username input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param username Parameter for the userByUsername field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "userByUsername", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> userByUsername(String queryResponseDef, String username, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query 'userByUsername': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getUserByUsernameResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return userByUsernameWithBindValues(objectResponse, username,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Returns a user given its username.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUserByUsernameGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.userByUsernameWithBindValues(preparedRequest, username, // A value for userByUsername's
	 * 																						// username input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUserByUsernameGraphQLRequest(String)} method.
	 * @param username Parameter for the userByUsername field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "userByUsername", graphQLTypeSimpleName = "User", javaClass = User.class)

	public Mono<Optional<User>> userByUsernameWithBindValues(ObjectResponse objectResponse, String username,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query 'userByUsername' with parameters: {} ", username); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'userByUsername'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("queryUserByUsernameUsername", username); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.getUserByUsername() == null) ? Optional.empty() : Optional.of(t.getUserByUsername()));
	}

	/**
	 * Returns a user given its username.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUserByUsernameGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.userByUsername(preparedRequest, username, // A value for userByUsername's username input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUserByUsernameGraphQLRequest(String)} method.
	 * @param username Parameter for the userByUsername field of Query, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "userByUsername", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> userByUsername(ObjectResponse objectResponse, String username, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query 'userByUsername' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query 'userByUsername' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("queryUserByUsernameUsername", username); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.getUserByUsername() == null) ? Optional.empty() : Optional.of(t.getUserByUsername()));
	}

	/**
	 * Returns a user given its username.<br/>
	 * Get the {@link Builder} for the User, as expected by the userByUsername query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUserByUsernameResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "userByUsername", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "username", "queryUserByUsernameUsername", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"String", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Returns a user given its username.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the userByUsername REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUserByUsernameGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "userByUsername" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "username", "queryUserByUsernameUsername", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"String", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<__Schema> mono = executor.__schemaWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			params);
	 * 		__Schema field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "__schema", graphQLTypeSimpleName = "__Schema", javaClass = __Schema.class)
	public Mono<Optional<__Schema>> __schemaWithBindValues(String queryResponseDef, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query '__schema': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = get__schemaResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return __schemaWithBindValues(objectResponse, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<__Schema> mono = executor.__schema(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		__Schema field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "__schema", graphQLTypeSimpleName = "__Schema", javaClass = __Schema.class)
	public Mono<Optional<__Schema>> __schema(String queryResponseDef, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query '__schema': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = get__schemaResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return __schemaWithBindValues(objectResponse,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.get__schemaGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<__Schema> mono = executor.__schemaWithBindValues(preparedRequest, params);
	 * 		__Schema field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link get__schemaGraphQLRequest(String)} method.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "__schema", graphQLTypeSimpleName = "__Schema", javaClass = __Schema.class)

	public Mono<Optional<__Schema>> __schemaWithBindValues(ObjectResponse objectResponse,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query '__schema' with parameters: "); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query '__schema'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.get__schema() == null) ? Optional.empty() : Optional.of(t.get__schema()));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.get__schemaGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<__Schema> mono = executor.__schema(preparedRequest, "param", paramValue, // param is optional, as it
	 * 																						// is marked by a "?" in
	 * 																						// the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		__Schema field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link get__schemaGraphQLRequest(String)} method.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "__schema", graphQLTypeSimpleName = "__Schema", javaClass = __Schema.class)
	public Mono<Optional<__Schema>> __schema(ObjectResponse objectResponse, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query '__schema' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query '__schema' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.get__schema() == null) ? Optional.empty() : Optional.of(t.get__schema()));
	}

	/**
	 * Get the {@link Builder} for the __Schema, as expected by the __schema query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder get__schemaResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "__schema", RequestType.query //$NON-NLS-1$
		);
	}

	/**
	 * Get the {@link GraphQLReactiveRequest} for the __schema REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest get__schemaGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "__schema" //$NON-NLS-1$
		);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<__Type> mono = executor.__typeWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			name, // A value for __type's name input parameter
	 * 			params);
	 * 		__Type field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param name Parameter for the __type field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "__type", graphQLTypeSimpleName = "__Type", javaClass = __Type.class)
	public Mono<Optional<__Type>> __typeWithBindValues(String queryResponseDef, String name,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query '__type': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = get__typeResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return __typeWithBindValues(objectResponse, name, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<__Type> mono = executor.__type(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			name, // A value for __type's name input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		__Type field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param name Parameter for the __type field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "__type", graphQLTypeSimpleName = "__Type", javaClass = __Type.class)
	public Mono<Optional<__Type>> __type(String queryResponseDef, String name, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query '__type': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = get__typeResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return __typeWithBindValues(objectResponse, name,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.get__typeGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<__Type> mono = executor.__typeWithBindValues(preparedRequest, name, // A value for __type's name
	 * 																					// input parameter
	 * 			params);
	 * 		__Type field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link get__typeGraphQLRequest(String)} method.
	 * @param name Parameter for the __type field of Query, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "__type", graphQLTypeSimpleName = "__Type", javaClass = __Type.class)

	public Mono<Optional<__Type>> __typeWithBindValues(ObjectResponse objectResponse, String name,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query '__type' with parameters: {} ", name); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query '__type'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("query__typeName", name); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.get__type() == null) ? Optional.empty() : Optional.of(t.get__type()));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.get__typeGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<__Type> mono = executor.__type(preparedRequest, name, // A value for __type's name input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		__Type field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link get__typeGraphQLRequest(String)} method.
	 * @param name Parameter for the __type field of Query, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "__type", graphQLTypeSimpleName = "__Type", javaClass = __Type.class)
	public Mono<Optional<__Type>> __type(ObjectResponse objectResponse, String name, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query '__type' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query '__type' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("query__typeName", name); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.get__type() == null) ? Optional.empty() : Optional.of(t.get__type()));
	}

	/**
	 * Get the {@link Builder} for the __Type, as expected by the __type query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder get__typeResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "__type", RequestType.query //$NON-NLS-1$
			, InputParameter.newBindParameter("", "name", "query__typeName", InputParameterType.MANDATORY, "String", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				true, 0, false));
	}

	/**
	 * Get the {@link GraphQLReactiveRequest} for the __type REACTIVE_EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest get__typeGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "__type" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "name", "query__typeName", InputParameterType.MANDATORY, "String", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
				true, 0, false));
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<String> mono = executor.__typenameWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			params);
	 * 		String field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "__typename", graphQLTypeSimpleName = "String", javaClass = String.class)
	public Mono<Optional<String>> __typenameWithBindValues(String queryResponseDef, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query '__typename': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = get__typenameResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return __typenameWithBindValues(objectResponse, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<String> mono = executor.__typename(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		String field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "__typename", graphQLTypeSimpleName = "String", javaClass = String.class)
	public Mono<Optional<String>> __typename(String queryResponseDef, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing query '__typename': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = get__typenameResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return __typenameWithBindValues(objectResponse,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.get__typenameGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<String> mono = executor.__typenameWithBindValues(preparedRequest, params);
	 * 		String field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link get__typenameGraphQLRequest(String)} method.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "__typename", graphQLTypeSimpleName = "String", javaClass = String.class)

	public Mono<Optional<String>> __typenameWithBindValues(ObjectResponse objectResponse,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing query '__typename' with parameters: "); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query '__typename'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();

		return objectResponse //
			.execReactive(Query.class, parametersLocal) //
			.map(t -> (t.get__typename() == null) ? Optional.empty() : Optional.of(t.get__typename()));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	QueryExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.get__typenameGraphQLRequest(
	 * 			"query { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<String> mono = executor.__typename(preparedRequest, "param", paramValue, // param is optional, as it
	 * 																						// is marked by a "?" in
	 * 																						// the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		String field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link get__typenameGraphQLRequest(String)} method.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "__typename", graphQLTypeSimpleName = "String", javaClass = String.class)
	public Mono<Optional<String>> __typename(ObjectResponse objectResponse, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing query '__typename' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing query '__typename' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);

		return objectResponse //
			.execReactive(Query.class, parameters) //
			.map(t -> (t.get__typename() == null) ? Optional.empty() : Optional.of(t.get__typename()));
	}

	/**
	 * Get the {@link Builder} for the String, as expected by the __typename query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder get__typenameResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "__typename", RequestType.query //$NON-NLS-1$
		);
	}

	/**
	 * Get the {@link GraphQLReactiveRequest} for the __typename REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest get__typenameGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.query, "__typename" //$NON-NLS-1$
		);
	}

}
