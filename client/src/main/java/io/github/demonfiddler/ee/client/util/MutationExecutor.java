/*----------------------------------------------------------------------------------------------------------------------
 * Evidence Engine: A system for managing evidence on arbitrary scientific topics.
 * Comprises an SQL database, GraphQL public API, Java app server, Java and web clients.
 * Copyright Â© 2024-25 Adrian Price. All rights reserved.
 *
 * This file is part of Evidence Engine.
 *
 * Evidence Engine is free software: you can redistribute it and/or modify it under the terms of the
 * GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * Evidence Engine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License along with Evidence Engine.
 * If not, see <https://www.gnu.org/licenses/>. 
 *--------------------------------------------------------------------------------------------------------------------*/

package io.github.demonfiddler.ee.client.util;

import static com.graphql_java_generator.client.request.InputParameter.InputParameterType.MANDATORY;

import java.util.List;
import java.util.Map;
import java.util.Optional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.graphql.client.GraphQlClient;
import org.springframework.stereotype.Component;

import com.graphql_java_generator.annotation.GraphQLDirective;
import com.graphql_java_generator.annotation.GraphQLNonScalar;
import com.graphql_java_generator.annotation.GraphQLScalar;
import com.graphql_java_generator.annotation.RequestType;
import com.graphql_java_generator.client.GraphQLMutationExecutor;
import com.graphql_java_generator.client.request.Builder;
import com.graphql_java_generator.client.request.InputParameter;
import com.graphql_java_generator.client.request.InputParameter.InputParameterType;
import com.graphql_java_generator.client.request.ObjectResponse;
import com.graphql_java_generator.customscalars.GraphQLScalarTypeDate;
import com.graphql_java_generator.exception.GraphQLRequestExecutionException;
import com.graphql_java_generator.exception.GraphQLRequestExecutionUncheckedException;
import com.graphql_java_generator.exception.GraphQLRequestPreparationException;
import com.graphql_java_generator.util.GraphqlUtils;

import io.github.demonfiddler.ee.client.Claim;
import io.github.demonfiddler.ee.client.ClaimInput;
import io.github.demonfiddler.ee.client.Comment;
import io.github.demonfiddler.ee.client.CommentInput;
import io.github.demonfiddler.ee.client.Declaration;
import io.github.demonfiddler.ee.client.DeclarationInput;
import io.github.demonfiddler.ee.client.EntityLink;
import io.github.demonfiddler.ee.client.EntityLinkInput;
import io.github.demonfiddler.ee.client.Group;
import io.github.demonfiddler.ee.client.GroupInput;
import io.github.demonfiddler.ee.client.Journal;
import io.github.demonfiddler.ee.client.JournalInput;
import io.github.demonfiddler.ee.client.Mutation;
import io.github.demonfiddler.ee.client.AuthPayload;
import io.github.demonfiddler.ee.client.AuthorityKind;
import io.github.demonfiddler.ee.client.Person;
import io.github.demonfiddler.ee.client.PersonInput;
import io.github.demonfiddler.ee.client.Publication;
import io.github.demonfiddler.ee.client.PublicationInput;
import io.github.demonfiddler.ee.client.Publisher;
import io.github.demonfiddler.ee.client.PublisherInput;
import io.github.demonfiddler.ee.client.Quotation;
import io.github.demonfiddler.ee.client.QuotationInput;
import io.github.demonfiddler.ee.client.StatusKind;
import io.github.demonfiddler.ee.client.Topic;
import io.github.demonfiddler.ee.client.TopicInput;
import io.github.demonfiddler.ee.client.User;
import io.github.demonfiddler.ee.client.UserInput;
import io.github.demonfiddler.ee.client.UserPasswordInput;
import io.github.demonfiddler.ee.client.UserProfileInput;
import reactor.core.publisher.Mono;

/**
 * Available mutations. <br/>
 * This class contains the methods that allows the execution of the queries or mutations that are defined in the
 * Mutation of the GraphQL schema.<br/>
 * These methods allows:
 * <UL>
 * <LI>Preparation of full requests</LI>
 * <LI>Execution of prepared full requests</LI>
 * <LI>Execution of direct full direct requests</LI>
 * <LI>Preparation of partial requests</LI>
 * <LI>Execution of prepared partial requests</LI>
 * <LI>Execution of direct partial requests</LI>
 * </UL>
 * You'll find all the documentation on the
 * <A HREF="https://github.com/graphql-java-generator/graphql-maven-plugin-project/wiki/client_spring">client page
 * doc</A>.
 * @author generated by graphql-java-generator
 */
@Component
public class MutationExecutor implements GraphQLMutationExecutor {

	/** Logger for this class */
	@SuppressWarnings("unused")
	private static final Logger LOGGER = LoggerFactory.getLogger(MutationExecutor.class);

	@Autowired
	@Qualifier("httpGraphQlClient")
	GraphQlClient graphQlClient;

	@Autowired
	GraphqlClientUtilsEx graphqlClientUtils;

	@Autowired
	@Qualifier("mutationReactiveExecutor")
	MutationReactiveExecutor mutationReactiveExecutor;

	GraphqlUtils graphqlUtils = GraphqlUtils.graphqlUtils; // must be set that way, to be used in the constructor

	public MutationExecutor() {
		if (!"2.8".equals(this.graphqlUtils.getRuntimeVersion())) {
			throw new RuntimeException(
				"The GraphQL runtime version doesn't match the GraphQL plugin version. The runtime's version is '"
					+ this.graphqlUtils.getRuntimeVersion() + "' whereas the GraphQL plugin version is '2.8'");
		}
		CustomScalarRegistryInitializer.initCustomScalarRegistry();
		DirectiveRegistryInitializer.initDirectiveRegistry();
	}

	/**
	 * This method takes a <B>full request</B> definition, and executes it against the GraphQL server. As this class is
	 * a mutation executor, the provided request must be a mutation full request.<br/>
	 * This method offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace
	 * mode).<br/>
	 * Here is a sample on how to use it: This method takes a <B>full request</B> definition, and executes it against
	 * the GraphQL server. That is, the query contains the full string that <B><U>follows</U></B> the mutation
	 * keyword.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 *     @Autowired
	 *     MutationExecutor executor;
	 * 
	 *     void myMethod() {
	 * 	        Map<String, Object> params = new HashMap<>();
	 *          params.put("param", paramValue);   // param is optional, as it is marked by a "?" in the request
	 *          params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 *          
	 *          Mutation mutation = executor.execWithBindValues(
	 *              "mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}",
	 *              callback,
	 *              params);
	 *          FieldType field = mutation.getSampleQueryOrMutationField();
	 *
	 *          .... do something with this field's value
	 *     }
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the mutation, in the native GraphQL format (see here above).
	 * It must omit the mutation keyword, and start by the first { that follows. It may contain directives, as explained
	 * in the GraphQL specs.
	 * @param parameters The map of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}. The key is the parameter
	 * name, as declared in the request you defined (in the above sample: param is an optional parameter and skip is a
	 * mandatory one). The value is the parameter value in its Java type (for instance a {@link java.util.Date} for the
	 * {@link GraphQLScalarTypeDate}). The parameters which value is missing in this map will be ignored.
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	public Mutation execWithBindValues(String queryResponseDef, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMono(this.mutationReactiveExecutor.execWithBindValues(queryResponseDef, parameters));
	}

	/**
	 * This method takes a <B>full request</B> definition, and executes it against the GraphQL server. As this class is
	 * a mutation executor, the provided request must be a mutation full request.<br/>
	 * This method offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace
	 * mode).<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 *     @Autowired
	 *     MutationExecutor executor;
	 * 
	 *     void myMethod() {
	 *          Mutation mutation = executor.exec(
	 *              "mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}",
	 *              "param", paramValue,   // param is optional, as it is marked by a "?" in the request
	 *              "skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 *              );
	 *          FieldType field = mutation.getSampleQueryOrMutationField();
	 *
	 *          .... do something with this field's value
	 *     }
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above). It
	 * must omit the mutation keyword, and start by the first { that follows. It may contain directives, as explained in
	 * the GraphQL specs.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	public Mutation exec(String queryResponseDef, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMono(this.mutationReactiveExecutor.exec(queryResponseDef, paramsAndValues));
	}

	/**
	 * This method takes a <B>full request</B> definition, and executes it against the GraphQL server. As this class is
	 * a mutation executor, the provided request must be a mutation full request.<br/>
	 * This method offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace
	 * mode).<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 *     &#64;Autowired
	 *     MutationExecutor executor;
	 *     
	 *     GraphQLRequest preparedRequest;
	 *     
	 *     @PostConstruct
	 *     public void setup() {
	 *         // Preparation of the query, so that it is prepared once then executed several times
	 *         preparedRequest = executor
	 *             .getResponseBuilder()
	 *             .withQueryResponseDef("mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}")
	 *             .build();
	 *     }
	 * 
	 *     void myMethod() {
	 * 	        Map<String, Object> params = new HashMap<>();
	 *          params.put("param", paramValue);   // param is optional, as it is marked by a "?" in the request
	 *          params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 *          
	 *          Mutation mutation = executor.execWithBindValues(
	 *              preparedRequest,
	 *              params);
	 *          FieldType field = mutation.getSampleQueryOrMutationField();
	 *
	 *          .... do something with this field's value
	 *     }
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGraphQLRequest(String)} method or one of the <code>getXxxxGraphQLRequest(String)</code> methods.
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	public Mutation execWithBindValues(ObjectResponse objectResponse, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {

		return getValueFromMono(this.mutationReactiveExecutor.execWithBindValues(objectResponse, parameters));
	}

	/**
	 * This method takes a <B>full request</B> definition, and executes it against the GraphQL server. As this class is
	 * a mutation executor, the provided request must be a mutation full request.<br/>
	 * This method offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace
	 * mode).<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 *     &#64;Autowired
	 *     MutationExecutor executor;
	 *     
	 *     GraphQLRequest preparedRequest;
	 *     
	 *     @PostConstruct
	 *     public void setup() {
	 *         // Preparation of the query, so that it is prepared once then executed several times
	 *         preparedRequest = executor
	 *             .getResponseBuilder()
	 *             .withQueryResponseDef("mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}")
	 *             .build();
	 *     }
	 * 
	 *     void myMethod() {
	 *          Mutation mutation = executor.exec(
	 *              preparedRequest,
	 *              "param", paramValue,   // param is optional, as it is marked by a "?" in the request
	 *              "skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 *              );
	 *          FieldType field = mutation.getSampleQueryOrMutationField();
	 *
	 *          .... do something with this field's value
	 *     }
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGraphQLRequest(String)} method or one of the <code>getXxxxGraphQLRequest(String)</code>
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	public Mutation exec(ObjectResponse objectResponse, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMono(this.mutationReactiveExecutor.exec(objectResponse, paramsAndValues));
	}

	/**
	 * Get the {@link Builder} for a <B>full request</B>, as expected by the exec and execWithBindValues methods.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getResponseBuilder();
	}

	/**
	 * Get the {@link GraphQLRequest} for <B>full request</B>. For instance:
	 * 
	 * <PRE>
	 * 
	 * GraphQLRequest request = new GraphQLRequest(fullRequest);
	 * </PRE>
	 * 
	 * @param fullRequest The full GraphQL Request, as specified in the GraphQL specification
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getGraphQLRequest(String fullRequest) throws GraphQLRequestPreparationException {
		return new GraphQLRequest(fullRequest);
	}

	/**
	 * Authenticates the client using JSON Web Token (JWT).<br/>
	 * This method executes a partial query on the login mutation against the GraphQL server. That is, the mutation is
	 * one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains the part of
	 * the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>login</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a scalar.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		AuthPayload login = executor.loginWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			username, // A value for login's username input parameter
	 * 			password, // A value for login's password input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param username Parameter for the login field of Mutation, as defined in the GraphQL schema
	 * @param password Parameter for the login field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "login", graphQLTypeSimpleName = "AuthPayload", javaClass = AuthPayload.class)
	public AuthPayload loginWithBindValues(String queryResponseDef, String username, String password,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.loginWithBindValues(queryResponseDef, username, password, parameters));
	}

	/**
	 * Authenticates the client using JSON Web Token (JWT).<br/>
	 * This method executes a partial query on the login mutation against the GraphQL server. That is, the mutation is
	 * one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains the part of
	 * the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>login</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a scalar.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		AuthPayload login = executor.login(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			username, // A value for login's username input parameter
	 * 			password, // A value for login's password input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param username Parameter for the login field of Mutation, as defined in the GraphQL schema
	 * @param password Parameter for the login field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "login", graphQLTypeSimpleName = "AuthPayload", javaClass = AuthPayload.class)
	public AuthPayload login(String queryResponseDef, String username, String password, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.login(queryResponseDef, username, password, paramsAndValues));
	}

	/**
	 * Authenticates the client using JSON Web Token (JWT).<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getLoginGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		AuthPayload login = executor.loginWithBindValues(preparedRequest, username, // A value for login's
	 * 																					// username input parameter
	 * 			password, // A value for login's password input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getLoginGraphQLRequest(String)} method.
	 * @param username Parameter for the login field of Mutation, as defined in the GraphQL schema
	 * @param password Parameter for the login field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "login", graphQLTypeSimpleName = "AuthPayload", javaClass = AuthPayload.class)
	public AuthPayload loginWithBindValues(ObjectResponse objectResponse, String username, String password,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.loginWithBindValues(objectResponse, username, password, parameters));
	}

	/**
	 * Authenticates the client using JSON Web Token (JWT).<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getLoginGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		AuthPayload login = executor.login(preparedRequest, username, // A value for login's username input
	 * 																		// parameter
	 * 			password, // A value for login's password input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getLoginGraphQLRequest(String)} method.
	 * @param username Parameter for the login field of Mutation, as defined in the GraphQL schema
	 * @param password Parameter for the login field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "login", graphQLTypeSimpleName = "AuthPayload", javaClass = AuthPayload.class)
	public AuthPayload login(ObjectResponse objectResponse, String username, String password, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.login(objectResponse, username, password, paramsAndValues));
	}

	/**
	 * Authenticates the client using JSON Web Token (JWT).<br/>
	 * Get the {@link Builder} for the AuthPayload, as expected by the login query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getLoginResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getLoginResponseBuilder();
	}

	/**
	 * Authenticates the client using JSON Web Token (JWT).<br/>
	 * Get the {@link GraphQLRequest} for the login EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getLoginGraphQLRequest(String partialRequest) throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "login",
			InputParameter.newBindParameter("", "username", "mutationLoginUsername", InputParameterType.MANDATORY,
				"String", true, 0, false),
			InputParameter.newBindParameter("", "password", "mutationLoginPassword", InputParameterType.MANDATORY,
				"String", true, 0, false));
	}

	/**
	 * Creates a new claim.<br/>
	 * This method executes a partial query on the createClaim mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createClaim</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Claim createClaim = executor.createClaimWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claim, // A value for createClaim's claim input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param claim Parameter for the createClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Claim createClaimWithBindValues(String queryResponseDef, ClaimInput claim, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createClaimWithBindValues(queryResponseDef, claim, parameters));
	}

	/**
	 * Creates a new claim.<br/>
	 * This method executes a partial query on the createClaim mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createClaim</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Claim createClaim = executor.createClaim(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claim, // A value for createClaim's claim input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param claim Parameter for the createClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Claim createClaim(String queryResponseDef, ClaimInput claim, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createClaim(queryResponseDef, claim, paramsAndValues));
	}

	/**
	 * Creates a new claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Claim createClaim = executor.createClaimWithBindValues(preparedRequest, claim, // A value for
	 * 																						// createClaim's claim
	 * 																						// input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateClaimGraphQLRequest(String)} method.
	 * @param claim Parameter for the createClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Claim createClaimWithBindValues(ObjectResponse objectResponse, ClaimInput claim,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createClaimWithBindValues(objectResponse, claim, parameters));
	}

	/**
	 * Creates a new claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Claim createClaim = executor.createClaim(preparedRequest, claim, // A value for createClaim's claim input
	 * 																			// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateClaimGraphQLRequest(String)} method.
	 * @param claim Parameter for the createClaim field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Claim createClaim(ObjectResponse objectResponse, ClaimInput claim, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createClaim(objectResponse, claim, paramsAndValues));
	}

	/**
	 * Creates a new claim.<br/>
	 * Get the {@link Builder} for the Claim, as expected by the createClaim query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreateClaimResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getCreateClaimResponseBuilder();
	}

	/**
	 * Creates a new claim.<br/>
	 * Get the {@link GraphQLRequest} for the createClaim EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getCreateClaimGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createClaim",
			InputParameter.newBindParameter("", "claim", "mutationCreateClaimClaim", MANDATORY, "ClaimInput", true, 0,
				false));
	}

	/**
	 * Updates an existing claim.<br/>
	 * This method executes a partial query on the updateClaim mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateClaim</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Claim updateClaim = executor.updateClaimWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claim, // A value for updateClaim's claim input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param claim Parameter for the updateClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Claim updateClaimWithBindValues(String queryResponseDef, ClaimInput claim, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateClaimWithBindValues(queryResponseDef, claim, parameters));
	}

	/**
	 * Updates an existing claim.<br/>
	 * This method executes a partial query on the updateClaim mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateClaim</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Claim updateClaim = executor.updateClaim(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claim, // A value for updateClaim's claim input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param claim Parameter for the updateClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Claim updateClaim(String queryResponseDef, ClaimInput claim, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateClaim(queryResponseDef, claim, paramsAndValues));
	}

	/**
	 * Updates an existing claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Claim updateClaim = executor.updateClaimWithBindValues(preparedRequest, claim, // A value for
	 * 																						// updateClaim's claim
	 * 																						// input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateClaimGraphQLRequest(String)} method.
	 * @param claim Parameter for the updateClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Claim updateClaimWithBindValues(ObjectResponse objectResponse, ClaimInput claim,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateClaimWithBindValues(objectResponse, claim, parameters));
	}

	/**
	 * Updates an existing claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Claim updateClaim = executor.updateClaim(preparedRequest, claim, // A value for updateClaim's claim input
	 * 																			// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateClaimGraphQLRequest(String)} method.
	 * @param claim Parameter for the updateClaim field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Claim updateClaim(ObjectResponse objectResponse, ClaimInput claim, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateClaim(objectResponse, claim, paramsAndValues));
	}

	/**
	 * Updates an existing claim.<br/>
	 * Get the {@link Builder} for the Claim, as expected by the updateClaim query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdateClaimResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdateClaimResponseBuilder();
	}

	/**
	 * Updates an existing claim.<br/>
	 * Get the {@link GraphQLRequest} for the updateClaim EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdateClaimGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateClaim",
			InputParameter.newBindParameter("", "claim", "mutationUpdateClaimClaim", MANDATORY, "ClaimInput", true, 0,
				false));
	}

	/**
	 * Deletes an existing claim.<br/>
	 * This method executes a partial query on the deleteClaim mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteClaim</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Claim deleteClaim = executor.deleteClaimWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claimId, // A value for deleteClaim's claimId input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param claimId Parameter for the deleteClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Claim deleteClaimWithBindValues(String queryResponseDef, Long claimId, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteClaimWithBindValues(queryResponseDef, claimId, parameters));
	}

	/**
	 * Deletes an existing claim.<br/>
	 * This method executes a partial query on the deleteClaim mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteClaim</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Claim deleteClaim = executor.deleteClaim(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claimId, // A value for deleteClaim's claimId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param claimId Parameter for the deleteClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Claim deleteClaim(String queryResponseDef, Long claimId, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteClaim(queryResponseDef, claimId, paramsAndValues));
	}

	/**
	 * Deletes an existing claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Claim deleteClaim = executor.deleteClaimWithBindValues(preparedRequest, claimId, // A value for
	 * 																							// deleteClaim's
	 * 																							// claimId input
	 * 																							// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteClaimGraphQLRequest(String)} method.
	 * @param claimId Parameter for the deleteClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Claim deleteClaimWithBindValues(ObjectResponse objectResponse, Long claimId, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteClaimWithBindValues(objectResponse, claimId, parameters));
	}

	/**
	 * Deletes an existing claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Claim deleteClaim = executor.deleteClaim(preparedRequest, claimId, // A value for deleteClaim's claimId
	 * 																			// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteClaimGraphQLRequest(String)} method.
	 * @param claimId Parameter for the deleteClaim field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Claim deleteClaim(ObjectResponse objectResponse, Long claimId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteClaim(objectResponse, claimId, paramsAndValues));
	}

	/**
	 * Deletes an existing claim.<br/>
	 * Get the {@link Builder} for the Claim, as expected by the deleteClaim query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeleteClaimResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getDeleteClaimResponseBuilder();
	}

	/**
	 * Deletes an existing claim.<br/>
	 * Get the {@link GraphQLRequest} for the deleteClaim EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDeleteClaimGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteClaim",
			InputParameter.newBindParameter("", "claimId", "mutationDeleteClaimClaimId", MANDATORY, "ID", true, 0,
				false));
	}

	/**
	 * Creates a new comment.<br/>
	 * This method executes a partial query on the createComment mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createComment</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Comment createComment = executor.createCommentWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			comment, // A value for createComment's comment input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param comment Parameter for the createComment field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createComment", graphQLTypeSimpleName = "Comment", javaClass = Comment.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[COM]" })
	public Comment createCommentWithBindValues(String queryResponseDef, CommentInput comment,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createCommentWithBindValues(queryResponseDef, comment, parameters));
	}

	/**
	 * Creates a new comment.<br/>
	 * This method executes a partial query on the createComment mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createComment</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Comment createComment = executor.createComment(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			comment, // A value for createComment's comment input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param comment Parameter for the createComment field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createComment", graphQLTypeSimpleName = "Comment", javaClass = Comment.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[COM]" })
	public Comment createComment(String queryResponseDef, CommentInput comment, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createComment(queryResponseDef, comment, paramsAndValues));
	}

	/**
	 * Creates a new comment.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateCommentGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Comment createComment = executor.createCommentWithBindValues(preparedRequest, comment, // A value for
	 * 																								// createComment's
	 * 																								// comment input
	 * 																								// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateCommentGraphQLRequest(String)} method.
	 * @param comment Parameter for the createComment field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createComment", graphQLTypeSimpleName = "Comment", javaClass = Comment.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[COM]" })
	public Comment createCommentWithBindValues(ObjectResponse objectResponse, CommentInput comment,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createCommentWithBindValues(objectResponse, comment, parameters));
	}

	/**
	 * Creates a new comment.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateCommentGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Comment createComment = executor.createComment(preparedRequest, comment, // A value for createComment's
	 * 																					// comment input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateCommentGraphQLRequest(String)} method.
	 * @param comment Parameter for the createComment field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createComment", graphQLTypeSimpleName = "Comment", javaClass = Comment.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[COM]" })
	public Comment createComment(ObjectResponse objectResponse, CommentInput comment, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createComment(objectResponse, comment, paramsAndValues));
	}

	/**
	 * Creates a new comment.<br/>
	 * Get the {@link Builder} for the Comment, as expected by the createComment query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreateCommentResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getCreateCommentResponseBuilder();
	}

	/**
	 * Creates a new comment.<br/>
	 * Get the {@link GraphQLRequest} for the createComment EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getCreateCommentGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createComment",
			InputParameter.newBindParameter("", "comment", "mutationCreateCommentComment", InputParameterType.MANDATORY,
				"CommentInput", true, 0, false));
	}

	/**
	 * Updates an existing comment.<br/>
	 * This method executes a partial query on the updateComment mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateComment</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Comment updateComment = executor.updateCommentWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			comment, // A value for updateComment's comment input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param comment Parameter for the updateComment field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateComment", graphQLTypeSimpleName = "Comment", javaClass = Comment.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[COM]" })
	public Comment updateCommentWithBindValues(String queryResponseDef, CommentInput comment,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateCommentWithBindValues(queryResponseDef, comment, parameters));
	}

	/**
	 * Updates an existing comment.<br/>
	 * This method executes a partial query on the updateComment mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateComment</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Comment updateComment = executor.updateComment(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			comment, // A value for updateComment's comment input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param comment Parameter for the updateComment field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateComment", graphQLTypeSimpleName = "Comment", javaClass = Comment.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[COM]" })
	public Comment updateComment(String queryResponseDef, CommentInput comment, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateComment(queryResponseDef, comment, paramsAndValues));
	}

	/**
	 * Updates an existing comment.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateCommentGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Comment updateComment = executor.updateCommentWithBindValues(preparedRequest, comment, // A value for
	 * 																								// updateComment's
	 * 																								// comment input
	 * 																								// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateCommentGraphQLRequest(String)} method.
	 * @param comment Parameter for the updateComment field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateComment", graphQLTypeSimpleName = "Comment", javaClass = Comment.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[COM]" })
	public Comment updateCommentWithBindValues(ObjectResponse objectResponse, CommentInput comment,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateCommentWithBindValues(objectResponse, comment, parameters));
	}

	/**
	 * Updates an existing comment.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateCommentGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Comment updateComment = executor.updateComment(preparedRequest, comment, // A value for updateComment's
	 * 																					// comment input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateCommentGraphQLRequest(String)} method.
	 * @param comment Parameter for the updateComment field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateComment", graphQLTypeSimpleName = "Comment", javaClass = Comment.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[COM]" })
	public Comment updateComment(ObjectResponse objectResponse, CommentInput comment, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateComment(objectResponse, comment, paramsAndValues));
	}

	/**
	 * Updates an existing comment.<br/>
	 * Get the {@link Builder} for the Comment, as expected by the updateComment query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdateCommentResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdateCommentResponseBuilder();
	}

	/**
	 * Updates an existing comment.<br/>
	 * Get the {@link GraphQLRequest} for the updateComment EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdateCommentGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateComment",
			InputParameter.newBindParameter("", "comment", "mutationUpdateCommentComment", InputParameterType.MANDATORY,
				"CommentInput", true, 0, false));
	}

	/**
	 * Deletes an existing comment.<br/>
	 * This method executes a partial query on the deleteComment mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteComment</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Comment deleteComment = executor.deleteCommentWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			commentId, // A value for deleteComment's commentId input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param commentId Parameter for the deleteComment field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "deleteComment", graphQLTypeSimpleName = "Comment", javaClass = Comment.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[COM]" })
	public Comment deleteCommentWithBindValues(String queryResponseDef, Long commentId, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteCommentWithBindValues(queryResponseDef, commentId, parameters));
	}

	/**
	 * Deletes an existing comment.<br/>
	 * This method executes a partial query on the deleteComment mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteComment</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Comment deleteComment = executor.deleteComment(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			commentId, // A value for deleteComment's commentId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param commentId Parameter for the deleteComment field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "deleteComment", graphQLTypeSimpleName = "Comment", javaClass = Comment.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[COM]" })
	public Comment deleteComment(String queryResponseDef, Long commentId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteComment(queryResponseDef, commentId, paramsAndValues));
	}

	/**
	 * Deletes an existing comment.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteCommentGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Comment deleteComment = executor.deleteCommentWithBindValues(preparedRequest, commentId, // A value for
	 * 																									// deleteComment's
	 * 																									// commentId
	 * 																									// input
	 * 																									// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteCommentGraphQLRequest(String)} method.
	 * @param commentId Parameter for the deleteComment field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "deleteComment", graphQLTypeSimpleName = "Comment", javaClass = Comment.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[COM]" })
	public Comment deleteCommentWithBindValues(ObjectResponse objectResponse, Long commentId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteCommentWithBindValues(objectResponse, commentId, parameters));
	}

	/**
	 * Deletes an existing comment.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteCommentGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Comment deleteComment = executor.deleteComment(preparedRequest, commentId, // A value for deleteComment's
	 * 																					// commentId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteCommentGraphQLRequest(String)} method.
	 * @param commentId Parameter for the deleteComment field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "deleteComment", graphQLTypeSimpleName = "Comment", javaClass = Comment.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[COM]" })
	public Comment deleteComment(ObjectResponse objectResponse, Long commentId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteComment(objectResponse, commentId, paramsAndValues));
	}

	/**
	 * Deletes an existing comment.<br/>
	 * Get the {@link Builder} for the Comment, as expected by the deleteComment query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeleteCommentResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getDeleteCommentResponseBuilder();
	}

	/**
	 * Deletes an existing comment.<br/>
	 * Get the {@link GraphQLRequest} for the deleteComment EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDeleteCommentGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteComment",
			InputParameter.newBindParameter("", "commentId", "mutationDeleteCommentCommentId",
				InputParameterType.MANDATORY, "ID", true, 0, false));
	}

	/**
	 * Creates a new declaration.<br/>
	 * This method executes a partial query on the createDeclaration mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createDeclaration</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Declaration createDeclaration = executor.createDeclarationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declaration, // A value for createDeclaration's declaration input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param declaration Parameter for the createDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Declaration createDeclarationWithBindValues(String queryResponseDef, DeclarationInput declaration,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createDeclarationWithBindValues(queryResponseDef, declaration, parameters));
	}

	/**
	 * Creates a new declaration.<br/>
	 * This method executes a partial query on the createDeclaration mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createDeclaration</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Declaration createDeclaration = executor.createDeclaration(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declaration, // A value for createDeclaration's declaration input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param declaration Parameter for the createDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Declaration createDeclaration(String queryResponseDef, DeclarationInput declaration,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createDeclaration(queryResponseDef, declaration, paramsAndValues));
	}

	/**
	 * Creates a new declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Declaration createDeclaration = executor.createDeclarationWithBindValues(preparedRequest, declaration, // A
	 * 																												// value
	 * 																												// for
	 * 																												// createDeclaration's
	 * 																												// declaration
	 * 																												// input
	 * 																												// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateDeclarationGraphQLRequest(String)} method.
	 * @param declaration Parameter for the createDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Declaration createDeclarationWithBindValues(ObjectResponse objectResponse, DeclarationInput declaration,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createDeclarationWithBindValues(objectResponse, declaration, parameters));
	}

	/**
	 * Creates a new declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Declaration createDeclaration = executor.createDeclaration(preparedRequest, declaration, // A value for
	 * 																									// createDeclaration's
	 * 																									// declaration
	 * 																									// input
	 * 																									// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateDeclarationGraphQLRequest(String)} method.
	 * @param declaration Parameter for the createDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Declaration createDeclaration(ObjectResponse objectResponse, DeclarationInput declaration,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createDeclaration(objectResponse, declaration, paramsAndValues));
	}

	/**
	 * Creates a new declaration.<br/>
	 * Get the {@link Builder} for the Declaration, as expected by the createDeclaration query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreateDeclarationResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getCreateDeclarationResponseBuilder();
	}

	/**
	 * Creates a new declaration.<br/>
	 * Get the {@link GraphQLRequest} for the createDeclaration EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getCreateDeclarationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createDeclaration",
			InputParameter.newBindParameter("", "declaration", "mutationCreateDeclarationDeclaration", MANDATORY,
				"DeclarationInput", true, 0, false));
	}

	/**
	 * Updates an existing declaration.<br/>
	 * This method executes a partial query on the updateDeclaration mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateDeclaration</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Declaration updateDeclaration = executor.updateDeclarationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declaration, // A value for updateDeclaration's declaration input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param declaration Parameter for the updateDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Declaration updateDeclarationWithBindValues(String queryResponseDef, DeclarationInput declaration,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateDeclarationWithBindValues(queryResponseDef, declaration, parameters));
	}

	/**
	 * Updates an existing declaration.<br/>
	 * This method executes a partial query on the updateDeclaration mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateDeclaration</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Declaration updateDeclaration = executor.updateDeclaration(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declaration, // A value for updateDeclaration's declaration input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param declaration Parameter for the updateDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Declaration updateDeclaration(String queryResponseDef, DeclarationInput declaration,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateDeclaration(queryResponseDef, declaration, paramsAndValues));
	}

	/**
	 * Updates an existing declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Declaration updateDeclaration = executor.updateDeclarationWithBindValues(preparedRequest, declaration, // A
	 * 																												// value
	 * 																												// for
	 * 																												// updateDeclaration's
	 * 																												// declaration
	 * 																												// input
	 * 																												// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateDeclarationGraphQLRequest(String)} method.
	 * @param declaration Parameter for the updateDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Declaration updateDeclarationWithBindValues(ObjectResponse objectResponse, DeclarationInput declaration,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateDeclarationWithBindValues(objectResponse, declaration, parameters));
	}

	/**
	 * Updates an existing declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Declaration updateDeclaration = executor.updateDeclaration(preparedRequest, declaration, // A value for
	 * 																									// updateDeclaration's
	 * 																									// declaration
	 * 																									// input
	 * 																									// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateDeclarationGraphQLRequest(String)} method.
	 * @param declaration Parameter for the updateDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Declaration updateDeclaration(ObjectResponse objectResponse, DeclarationInput declaration,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateDeclaration(objectResponse, declaration, paramsAndValues));
	}

	/**
	 * Updates an existing declaration.<br/>
	 * Get the {@link Builder} for the Declaration, as expected by the updateDeclaration query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdateDeclarationResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdateDeclarationResponseBuilder();
	}

	/**
	 * Updates an existing declaration.<br/>
	 * Get the {@link GraphQLRequest} for the updateDeclaration EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdateDeclarationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateDeclaration",
			InputParameter.newBindParameter("", "declaration", "mutationUpdateDeclarationDeclaration", MANDATORY,
				"DeclarationInput", true, 0, false));
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * This method executes a partial query on the deleteDeclaration mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteDeclaration</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Declaration deleteDeclaration = executor.deleteDeclarationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declarationId, // A value for deleteDeclaration's declarationId input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param declarationId Parameter for the deleteDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Declaration deleteDeclarationWithBindValues(String queryResponseDef, Long declarationId,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteDeclarationWithBindValues(queryResponseDef, declarationId, parameters));
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * This method executes a partial query on the deleteDeclaration mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteDeclaration</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Declaration deleteDeclaration = executor.deleteDeclaration(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declarationId, // A value for deleteDeclaration's declarationId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param declarationId Parameter for the deleteDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Declaration deleteDeclaration(String queryResponseDef, Long declarationId, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteDeclaration(queryResponseDef, declarationId, paramsAndValues));
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Declaration deleteDeclaration = executor.deleteDeclarationWithBindValues(preparedRequest, declarationId, // A
	 * 																													// value
	 * 																													// for
	 * 																													// deleteDeclaration's
	 * 																													// declarationId
	 * 																													// input
	 * 																													// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteDeclarationGraphQLRequest(String)} method.
	 * @param declarationId Parameter for the deleteDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Declaration deleteDeclarationWithBindValues(ObjectResponse objectResponse, Long declarationId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteDeclarationWithBindValues(objectResponse, declarationId, parameters));
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Declaration deleteDeclaration = executor.deleteDeclaration(preparedRequest, declarationId, // A value for
	 * 																									// deleteDeclaration's
	 * 																									// declarationId
	 * 																									// input
	 * 																									// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteDeclarationGraphQLRequest(String)} method.
	 * @param declarationId Parameter for the deleteDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Declaration deleteDeclaration(ObjectResponse objectResponse, Long declarationId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteDeclaration(objectResponse, declarationId, paramsAndValues));
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * Get the {@link Builder} for the Declaration, as expected by the deleteDeclaration query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeleteDeclarationResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getDeleteDeclarationResponseBuilder();
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * Get the {@link GraphQLRequest} for the deleteDeclaration EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDeleteDeclarationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteDeclaration",
			InputParameter.newBindParameter("", "declarationId", "mutationDeleteDeclarationDeclarationId", MANDATORY,
				"ID", true, 0, false));
	}

	/**
	 * Creates an entity link.<br/>
	 * This method executes a partial query on the createEntityLink mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createEntityLink</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		EntityLink createEntityLink = executor.createEntityLinkWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			link, // A value for createEntityLink's link input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param entityLink Parameter for the createEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public EntityLink createEntityLinkWithBindValues(String queryResponseDef, EntityLinkInput entityLink,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createEntityLinkWithBindValues(queryResponseDef, entityLink, parameters));
	}

	/**
	 * Creates an entity link.<br/>
	 * This method executes a partial query on the createEntityLink mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createEntityLink</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		EntityLink createEntityLink = executor.createEntityLink(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			link, // A value for createEntityLink's link input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param entityLink Parameter for the createEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public EntityLink createEntityLink(String queryResponseDef, EntityLinkInput entityLink, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createEntityLink(queryResponseDef, entityLink, paramsAndValues));
	}

	/**
	 * Creates an entity link.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateEntityLinkGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		EntityLink createEntityLink = executor.createEntityLinkWithBindValues(preparedRequest, link, // A value
	 * 																										// for
	 * 																										// createEntityLink's
	 * 																										// link
	 * 																										// input
	 * 																										// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateEntityLinkGraphQLRequest(String)} method.
	 * @param entityLink Parameter for the createEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public EntityLink createEntityLinkWithBindValues(ObjectResponse objectResponse, EntityLinkInput entityLink,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createEntityLinkWithBindValues(objectResponse, entityLink, parameters));
	}

	/**
	 * Creates an entity link.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateEntityLinkGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		EntityLink createEntityLink = executor.createEntityLink(preparedRequest, link, // A value for
	 * 																						// createEntityLink's
	 * 																						// link input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateEntityLinkGraphQLRequest(String)} method.
	 * @param entityLink Parameter for the createEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public EntityLink createEntityLink(ObjectResponse objectResponse, EntityLinkInput entityLink,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createEntityLink(objectResponse, entityLink, paramsAndValues));
	}

	/**
	 * Creates an entity link.<br/>
	 * Get the {@link Builder} for the EntityLink, as expected by the createEntityLink query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreateEntityLinkResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getCreateEntityLinkResponseBuilder();
	}

	/**
	 * Creates an entity link.<br/>
	 * Get the {@link GraphQLRequest} for the createEntityLink EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getCreateEntityLinkGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createEntityLink",
			InputParameter.newBindParameter("", "entityLink", "mutationCreateEntityLinkEntityLink", MANDATORY,
				"EntityLinkInput", true, 0, false));
	}

	/**
	 * Updates an existing entity link.<br/>
	 * This method executes a partial query on the updateEntityLink mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateEntityLink</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		EntityLink updateEntityLink = executor.updateEntityLinkWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			entityLink, // A value for updateEntityLink's entityLink input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param entityLink Parameter for the updateEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public EntityLink updateEntityLinkWithBindValues(String queryResponseDef, EntityLinkInput entityLink,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateEntityLinkWithBindValues(queryResponseDef, entityLink, parameters));
	}

	/**
	 * Updates an existing entity link.<br/>
	 * This method executes a partial query on the updateEntityLink mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateEntityLink</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		EntityLink updateEntityLink = executor.updateEntityLink(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			entityLink, // A value for updateEntityLink's entityLink input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param entityLink Parameter for the updateEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public EntityLink updateEntityLink(String queryResponseDef, EntityLinkInput entityLink, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateEntityLink(queryResponseDef, entityLink, paramsAndValues));
	}

	/**
	 * Updates an existing entity link.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateEntityLinkGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		EntityLink updateEntityLink = executor.updateEntityLinkWithBindValues(preparedRequest, entityLink, // A
	 * 																											// value
	 * 																											// for
	 * 																											// updateEntityLink's
	 * 																											// entityLink
	 * 																											// input
	 * 																											// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateEntityLinkGraphQLRequest(String)} method.
	 * @param entityLink Parameter for the updateEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public EntityLink updateEntityLinkWithBindValues(ObjectResponse objectResponse, EntityLinkInput entityLink,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateEntityLinkWithBindValues(objectResponse, entityLink, parameters));
	}

	/**
	 * Updates an existing entity link.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateEntityLinkGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		EntityLink updateEntityLink = executor.updateEntityLink(preparedRequest, entityLink, // A value for
	 * 																								// updateEntityLink's
	 * 																								// entityLink
	 * 																								// input
	 * 																								// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateEntityLinkGraphQLRequest(String)} method.
	 * @param entityLink Parameter for the updateEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public EntityLink updateEntityLink(ObjectResponse objectResponse, EntityLinkInput entityLink,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateEntityLink(objectResponse, entityLink, paramsAndValues));
	}

	/**
	 * Updates an existing entity link.<br/>
	 * Get the {@link Builder} for the EntityLink, as expected by the updateEntityLink query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdateEntityLinkResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdateEntityLinkResponseBuilder();
	}

	/**
	 * Updates an existing entity link.<br/>
	 * Get the {@link GraphQLRequest} for the updateEntityLink EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdateEntityLinkGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateEntityLink",
			InputParameter.newBindParameter("", "entityLink", "mutationUpdateEntityLinkEntityLink", MANDATORY,
				"EntityLinkInput", true, 0, false));
	}

	/**
	 * Deletes an entity link.<br/>
	 * This method executes a partial query on the deleteEntityLink mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteEntityLink</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		EntityLink deleteEntityLink = executor.deleteEntityLinkWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			linkId, // A value for deleteEntityLink's linkId input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param entityLinkId Parameter for the deleteEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "deleteEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public EntityLink deleteEntityLinkWithBindValues(String queryResponseDef, Long entityLinkId,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteEntityLinkWithBindValues(queryResponseDef, entityLinkId, parameters));
	}

	/**
	 * Deletes an entity link.<br/>
	 * This method executes a partial query on the deleteEntityLink mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteEntityLink</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		EntityLink deleteEntityLink = executor.deleteEntityLink(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			linkId, // A value for deleteEntityLink's linkId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param entityLinkId Parameter for the deleteEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "deleteEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public EntityLink deleteEntityLink(String queryResponseDef, Long entityLinkId, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteEntityLink(queryResponseDef, entityLinkId, paramsAndValues));
	}

	/**
	 * Deletes an entity link.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteEntityLinkGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		EntityLink deleteEntityLink = executor.deleteEntityLinkWithBindValues(preparedRequest, entityLinkId, // A
	 * 																												// value
	 * 			// for
	 * 			// deleteEntityLink's
	 * 			// entityLinkId
	 * 			// input
	 * 			// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteEntityLinkGraphQLRequest(String)} method.
	 * @param entityLinkId Parameter for the deleteEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "deleteEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public EntityLink deleteEntityLinkWithBindValues(ObjectResponse objectResponse, Long entityLinkId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteEntityLinkWithBindValues(objectResponse, entityLinkId, parameters));
	}

	/**
	 * Deletes an entity link.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteEntityLinkGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		EntityLink deleteEntityLink = executor.deleteEntityLink(preparedRequest, entityLinkId, // A value for
	 * 																								// deleteEntityLink's
	 * 																								// entityLinkId
	 * 																								// input
	 * 																								// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteEntityLinkGraphQLRequest(String)} method.
	 * @param entityLinkId Parameter for the deleteEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "deleteEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public EntityLink deleteEntityLink(ObjectResponse objectResponse, Long entityLinkId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteEntityLink(objectResponse, entityLinkId, paramsAndValues));
	}

	/**
	 * Deletes an entity link.<br/>
	 * Get the {@link Builder} for the EntityLink, as expected by the deleteEntityLink query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeleteEntityLinkResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getDeleteEntityLinkResponseBuilder();
	}

	/**
	 * Deletes an entity link.<br/>
	 * Get the {@link GraphQLRequest} for the deleteEntityLink EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDeleteEntityLinkGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteEntityLink",
			InputParameter.newBindParameter("", "entityLinkId", "mutationDeleteEntityLinkEntityLinkId", MANDATORY,
				"Long", true, 0, false));
	}

	/**
	 * Create a new journal.<br/>
	 * This method executes a partial query on the createJournal mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createJournal</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Journal createJournal = executor.createJournalWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journal, // A value for createJournal's journal input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param journal Parameter for the createJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Journal createJournalWithBindValues(String queryResponseDef, JournalInput journal,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createJournalWithBindValues(queryResponseDef, journal, parameters));
	}

	/**
	 * Create a new journal.<br/>
	 * This method executes a partial query on the createJournal mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createJournal</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Journal createJournal = executor.createJournal(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journal, // A value for createJournal's journal input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param journal Parameter for the createJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Journal createJournal(String queryResponseDef, JournalInput journal, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createJournal(queryResponseDef, journal, paramsAndValues));
	}

	/**
	 * Create a new journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Journal createJournal = executor.createJournalWithBindValues(preparedRequest, journal, // A value for
	 * 																								// createJournal's
	 * 																								// journal input
	 * 																								// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateJournalGraphQLRequest(String)} method.
	 * @param journal Parameter for the createJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Journal createJournalWithBindValues(ObjectResponse objectResponse, JournalInput journal,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createJournalWithBindValues(objectResponse, journal, parameters));
	}

	/**
	 * Create a new journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Journal createJournal = executor.createJournal(preparedRequest, journal, // A value for createJournal's
	 * 																					// journal input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateJournalGraphQLRequest(String)} method.
	 * @param journal Parameter for the createJournal field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Journal createJournal(ObjectResponse objectResponse, JournalInput journal, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createJournal(objectResponse, journal, paramsAndValues));
	}

	/**
	 * Create a new journal.<br/>
	 * Get the {@link Builder} for the Journal, as expected by the createJournal query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreateJournalResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getCreateJournalResponseBuilder();
	}

	/**
	 * Create a new journal.<br/>
	 * Get the {@link GraphQLRequest} for the createJournal EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getCreateJournalGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createJournal",
			InputParameter.newBindParameter("", "journal", "mutationCreateJournalJournal", MANDATORY, "JournalInput",
				true, 0, false));
	}

	/**
	 * Updates an existing journal.<br/>
	 * This method executes a partial query on the updateJournal mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateJournal</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Journal updateJournal = executor.updateJournalWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journal, // A value for updateJournal's journal input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param journal Parameter for the updateJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Journal updateJournalWithBindValues(String queryResponseDef, JournalInput journal,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateJournalWithBindValues(queryResponseDef, journal, parameters));
	}

	/**
	 * Updates an existing journal.<br/>
	 * This method executes a partial query on the updateJournal mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateJournal</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Journal updateJournal = executor.updateJournal(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journal, // A value for updateJournal's journal input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param journal Parameter for the updateJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Journal updateJournal(String queryResponseDef, JournalInput journal, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateJournal(queryResponseDef, journal, paramsAndValues));
	}

	/**
	 * Updates an existing journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Journal updateJournal = executor.updateJournalWithBindValues(preparedRequest, journal, // A value for
	 * 																								// updateJournal's
	 * 																								// journal input
	 * 																								// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateJournalGraphQLRequest(String)} method.
	 * @param journal Parameter for the updateJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Journal updateJournalWithBindValues(ObjectResponse objectResponse, JournalInput journal,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateJournalWithBindValues(objectResponse, journal, parameters));
	}

	/**
	 * Updates an existing journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Journal updateJournal = executor.updateJournal(preparedRequest, journal, // A value for updateJournal's
	 * 																					// journal input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateJournalGraphQLRequest(String)} method.
	 * @param journal Parameter for the updateJournal field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Journal updateJournal(ObjectResponse objectResponse, JournalInput journal, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateJournal(objectResponse, journal, paramsAndValues));
	}

	/**
	 * Updates an existing journal.<br/>
	 * Get the {@link Builder} for the Journal, as expected by the updateJournal query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdateJournalResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdateJournalResponseBuilder();
	}

	/**
	 * Updates an existing journal.<br/>
	 * Get the {@link GraphQLRequest} for the updateJournal EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdateJournalGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateJournal",
			InputParameter.newBindParameter("", "journal", "mutationUpdateJournalJournal", MANDATORY, "JournalInput",
				true, 0, false));
	}

	/**
	 * Deletes an existing journal.<br/>
	 * This method executes a partial query on the deleteJournal mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteJournal</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Journal deleteJournal = executor.deleteJournalWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journalId, // A value for deleteJournal's journalId input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param journalId Parameter for the deleteJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Journal deleteJournalWithBindValues(String queryResponseDef, Long journalId, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteJournalWithBindValues(queryResponseDef, journalId, parameters));
	}

	/**
	 * Deletes an existing journal.<br/>
	 * This method executes a partial query on the deleteJournal mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteJournal</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Journal deleteJournal = executor.deleteJournal(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journalId, // A value for deleteJournal's journalId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param journalId Parameter for the deleteJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Journal deleteJournal(String queryResponseDef, Long journalId, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteJournal(queryResponseDef, journalId, paramsAndValues));
	}

	/**
	 * Deletes an existing journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Journal deleteJournal = executor.deleteJournalWithBindValues(preparedRequest, journalId, // A value for
	 * 																									// deleteJournal's
	 * 																									// journalId
	 * 																									// input
	 * 																									// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteJournalGraphQLRequest(String)} method.
	 * @param journalId Parameter for the deleteJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Journal deleteJournalWithBindValues(ObjectResponse objectResponse, Long journalId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteJournalWithBindValues(objectResponse, journalId, parameters));
	}

	/**
	 * Deletes an existing journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Journal deleteJournal = executor.deleteJournal(preparedRequest, journalId, // A value for deleteJournal's
	 * 																					// journalId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteJournalGraphQLRequest(String)} method.
	 * @param journalId Parameter for the deleteJournal field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Journal deleteJournal(ObjectResponse objectResponse, Long journalId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteJournal(objectResponse, journalId, paramsAndValues));
	}

	/**
	 * Deletes an existing journal.<br/>
	 * Get the {@link Builder} for the Journal, as expected by the deleteJournal query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeleteJournalResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getDeleteJournalResponseBuilder();
	}

	/**
	 * Deletes an existing journal.<br/>
	 * Get the {@link GraphQLRequest} for the deleteJournal EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDeleteJournalGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteJournal",
			InputParameter.newBindParameter("", "journalId", "mutationDeleteJournalJournalId", MANDATORY, "ID", true, 0,
				false));
	}

	/**
	 * Creates a new person.<br/>
	 * This method executes a partial query on the createPerson mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createPerson</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Person createPerson = executor.createPersonWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			person, // A value for createPerson's person input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param person Parameter for the createPerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Person createPersonWithBindValues(String queryResponseDef, PersonInput person,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPersonWithBindValues(queryResponseDef, person, parameters));
	}

	/**
	 * Creates a new person.<br/>
	 * This method executes a partial query on the createPerson mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createPerson</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Person createPerson = executor.createPerson(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			person, // A value for createPerson's person input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param person Parameter for the createPerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Person createPerson(String queryResponseDef, PersonInput person, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPerson(queryResponseDef, person, paramsAndValues));
	}

	/**
	 * Creates a new person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Person createPerson = executor.createPersonWithBindValues(preparedRequest, person, // A value for
	 * 																							// createPerson's
	 * 																							// person input
	 * 																							// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePersonGraphQLRequest(String)} method.
	 * @param person Parameter for the createPerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Person createPersonWithBindValues(ObjectResponse objectResponse, PersonInput person,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPersonWithBindValues(objectResponse, person, parameters));
	}

	/**
	 * Creates a new person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Person createPerson = executor.createPerson(preparedRequest, person, // A value for createPerson's person
	 * 																				// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePersonGraphQLRequest(String)} method.
	 * @param person Parameter for the createPerson field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Person createPerson(ObjectResponse objectResponse, PersonInput person, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPerson(objectResponse, person, paramsAndValues));
	}

	/**
	 * Creates a new person.<br/>
	 * Get the {@link Builder} for the Person, as expected by the createPerson query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreatePersonResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getCreatePersonResponseBuilder();
	}

	/**
	 * Creates a new person.<br/>
	 * Get the {@link GraphQLRequest} for the createPerson EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getCreatePersonGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createPerson",
			InputParameter.newBindParameter("", "person", "mutationCreatePersonPerson", MANDATORY, "PersonInput", true,
				0, false));
	}

	/**
	 * Updates an existing person.<br/>
	 * This method executes a partial query on the updatePerson mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updatePerson</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Person updatePerson = executor.updatePersonWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			person, // A value for updatePerson's person input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param person Parameter for the updatePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Person updatePersonWithBindValues(String queryResponseDef, PersonInput person,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePersonWithBindValues(queryResponseDef, person, parameters));
	}

	/**
	 * Updates an existing person.<br/>
	 * This method executes a partial query on the updatePerson mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updatePerson</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Person updatePerson = executor.updatePerson(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			person, // A value for updatePerson's person input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param person Parameter for the updatePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Person updatePerson(String queryResponseDef, PersonInput person, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePerson(queryResponseDef, person, paramsAndValues));
	}

	/**
	 * Updates an existing person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Person updatePerson = executor.updatePersonWithBindValues(preparedRequest, person, // A value for
	 * 																							// updatePerson's
	 * 																							// person input
	 * 																							// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePersonGraphQLRequest(String)} method.
	 * @param person Parameter for the updatePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Person updatePersonWithBindValues(ObjectResponse objectResponse, PersonInput person,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePersonWithBindValues(objectResponse, person, parameters));
	}

	/**
	 * Updates an existing person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Person updatePerson = executor.updatePerson(preparedRequest, person, // A value for updatePerson's person
	 * 																				// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePersonGraphQLRequest(String)} method.
	 * @param person Parameter for the updatePerson field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Person updatePerson(ObjectResponse objectResponse, PersonInput person, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePerson(objectResponse, person, paramsAndValues));
	}

	/**
	 * Updates an existing person.<br/>
	 * Get the {@link Builder} for the Person, as expected by the updatePerson query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdatePersonResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdatePersonResponseBuilder();
	}

	/**
	 * Updates an existing person.<br/>
	 * Get the {@link GraphQLRequest} for the updatePerson EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdatePersonGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updatePerson",
			InputParameter.newBindParameter("", "person", "mutationUpdatePersonPerson", MANDATORY, "PersonInput", true,
				0, false));
	}

	/**
	 * Deletes an existing person.<br/>
	 * This method executes a partial query on the deletePerson mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deletePerson</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Person deletePerson = executor.deletePersonWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			personId, // A value for deletePerson's personId input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param personId Parameter for the deletePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Person deletePersonWithBindValues(String queryResponseDef, Long personId, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePersonWithBindValues(queryResponseDef, personId, parameters));
	}

	/**
	 * Deletes an existing person.<br/>
	 * This method executes a partial query on the deletePerson mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deletePerson</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Person deletePerson = executor.deletePerson(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			personId, // A value for deletePerson's personId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param personId Parameter for the deletePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Person deletePerson(String queryResponseDef, Long personId, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePerson(queryResponseDef, personId, paramsAndValues));
	}

	/**
	 * Deletes an existing person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Person deletePerson = executor.deletePersonWithBindValues(preparedRequest, personId, // A value for
	 * 																								// deletePerson's
	 * 																								// personId input
	 * 																								// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePersonGraphQLRequest(String)} method.
	 * @param personId Parameter for the deletePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Person deletePersonWithBindValues(ObjectResponse objectResponse, Long personId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePersonWithBindValues(objectResponse, personId, parameters));
	}

	/**
	 * Deletes an existing person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Person deletePerson = executor.deletePerson(preparedRequest, personId, // A value for deletePerson's
	 * 																				// personId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePersonGraphQLRequest(String)} method.
	 * @param personId Parameter for the deletePerson field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Person deletePerson(ObjectResponse objectResponse, Long personId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePerson(objectResponse, personId, paramsAndValues));
	}

	/**
	 * Deletes an existing person.<br/>
	 * Get the {@link Builder} for the Person, as expected by the deletePerson query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeletePersonResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getDeletePersonResponseBuilder();
	}

	/**
	 * Deletes an existing person.<br/>
	 * Get the {@link GraphQLRequest} for the deletePerson EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDeletePersonGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deletePerson",
			InputParameter.newBindParameter("", "personId", "mutationDeletePersonPersonId", MANDATORY, "ID", true, 0,
				false));
	}

	/**
	 * Creates a new publication.<br/>
	 * This method executes a partial query on the createPublication mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createPublication</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Publication createPublication = executor.createPublicationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publication, // A value for createPublication's publication input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publication Parameter for the createPublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Publication createPublicationWithBindValues(String queryResponseDef, PublicationInput publication,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPublicationWithBindValues(queryResponseDef, publication, parameters));
	}

	/**
	 * Creates a new publication.<br/>
	 * This method executes a partial query on the createPublication mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createPublication</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Publication createPublication = executor.createPublication(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publication, // A value for createPublication's publication input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publication Parameter for the createPublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Publication createPublication(String queryResponseDef, PublicationInput publication,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPublication(queryResponseDef, publication, paramsAndValues));
	}

	/**
	 * Creates a new publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publication createPublication = executor.createPublicationWithBindValues(preparedRequest, publication, // A
	 * 																												// value
	 * 																												// for
	 * 																												// createPublication's
	 * 																												// publication
	 * 																												// input
	 * 																												// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePublicationGraphQLRequest(String)} method.
	 * @param publication Parameter for the createPublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Publication createPublicationWithBindValues(ObjectResponse objectResponse, PublicationInput publication,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPublicationWithBindValues(objectResponse, publication, parameters));
	}

	/**
	 * Creates a new publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publication createPublication = executor.createPublication(preparedRequest, publication, // A value for
	 * 																									// createPublication's
	 * 																									// publication
	 * 																									// input
	 * 																									// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePublicationGraphQLRequest(String)} method.
	 * @param publication Parameter for the createPublication field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Publication createPublication(ObjectResponse objectResponse, PublicationInput publication,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPublication(objectResponse, publication, paramsAndValues));
	}

	/**
	 * Creates a new publication.<br/>
	 * Get the {@link Builder} for the Publication, as expected by the createPublication query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreatePublicationResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getCreatePublicationResponseBuilder();
	}

	/**
	 * Creates a new publication.<br/>
	 * Get the {@link GraphQLRequest} for the createPublication EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getCreatePublicationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createPublication",
			InputParameter.newBindParameter("", "publication", "mutationCreatePublicationPublication", MANDATORY,
				"PublicationInput", true, 0, false));
	}

	/**
	 * Updates an existing publication.<br/>
	 * This method executes a partial query on the updatePublication mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updatePublication</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Publication updatePublication = executor.updatePublicationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publication, // A value for updatePublication's publication input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publication Parameter for the updatePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Publication updatePublicationWithBindValues(String queryResponseDef, PublicationInput publication,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePublicationWithBindValues(queryResponseDef, publication, parameters));
	}

	/**
	 * Updates an existing publication.<br/>
	 * This method executes a partial query on the updatePublication mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updatePublication</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Publication updatePublication = executor.updatePublication(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publication, // A value for updatePublication's publication input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publication Parameter for the updatePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Publication updatePublication(String queryResponseDef, PublicationInput publication,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePublication(queryResponseDef, publication, paramsAndValues));
	}

	/**
	 * Updates an existing publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publication updatePublication = executor.updatePublicationWithBindValues(preparedRequest, publication, // A
	 * 																												// value
	 * 																												// for
	 * 																												// updatePublication's
	 * 																												// publication
	 * 																												// input
	 * 																												// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePublicationGraphQLRequest(String)} method.
	 * @param publication Parameter for the updatePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Publication updatePublicationWithBindValues(ObjectResponse objectResponse, PublicationInput publication,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePublicationWithBindValues(objectResponse, publication, parameters));
	}

	/**
	 * Updates an existing publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publication updatePublication = executor.updatePublication(preparedRequest, publication, // A value for
	 * 																									// updatePublication's
	 * 																									// publication
	 * 																									// input
	 * 																									// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePublicationGraphQLRequest(String)} method.
	 * @param publication Parameter for the updatePublication field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Publication updatePublication(ObjectResponse objectResponse, PublicationInput publication,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePublication(objectResponse, publication, paramsAndValues));
	}

	/**
	 * Updates an existing publication.<br/>
	 * Get the {@link Builder} for the Publication, as expected by the updatePublication query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdatePublicationResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdatePublicationResponseBuilder();
	}

	/**
	 * Updates an existing publication.<br/>
	 * Get the {@link GraphQLRequest} for the updatePublication EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdatePublicationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updatePublication",
			InputParameter.newBindParameter("", "publication", "mutationUpdatePublicationPublication", MANDATORY,
				"PublicationInput", true, 0, false));
	}

	/**
	 * Deletes an existing publication.<br/>
	 * This method executes a partial query on the deletePublication mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deletePublication</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Publication deletePublication = executor.deletePublicationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publicationId, // A value for deletePublication's publicationId input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publicationId Parameter for the deletePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Publication deletePublicationWithBindValues(String queryResponseDef, Long publicationId,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePublicationWithBindValues(queryResponseDef, publicationId, parameters));
	}

	/**
	 * Deletes an existing publication.<br/>
	 * This method executes a partial query on the deletePublication mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deletePublication</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Publication deletePublication = executor.deletePublication(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publicationId, // A value for deletePublication's publicationId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publicationId Parameter for the deletePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Publication deletePublication(String queryResponseDef, Long publicationId, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePublication(queryResponseDef, publicationId, paramsAndValues));
	}

	/**
	 * Deletes an existing publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publication deletePublication = executor.deletePublicationWithBindValues(preparedRequest, publicationId, // A
	 * 																													// value
	 * 																													// for
	 * 																													// deletePublication's
	 * 																													// publicationId
	 * 																													// input
	 * 																													// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePublicationGraphQLRequest(String)} method.
	 * @param publicationId Parameter for the deletePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Publication deletePublicationWithBindValues(ObjectResponse objectResponse, Long publicationId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePublicationWithBindValues(objectResponse, publicationId, parameters));
	}

	/**
	 * Deletes an existing publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publication deletePublication = executor.deletePublication(preparedRequest, publicationId, // A value for
	 * 																									// deletePublication's
	 * 																									// publicationId
	 * 																									// input
	 * 																									// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePublicationGraphQLRequest(String)} method.
	 * @param publicationId Parameter for the deletePublication field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Publication deletePublication(ObjectResponse objectResponse, Long publicationId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePublication(objectResponse, publicationId, paramsAndValues));
	}

	/**
	 * Deletes an existing publication.<br/>
	 * Get the {@link Builder} for the Publication, as expected by the deletePublication query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeletePublicationResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getDeletePublicationResponseBuilder();
	}

	/**
	 * Deletes an existing publication.<br/>
	 * Get the {@link GraphQLRequest} for the deletePublication EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDeletePublicationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deletePublication",
			InputParameter.newBindParameter("", "publicationId", "mutationDeletePublicationPublicationId", MANDATORY,
				"ID", true, 0, false));
	}

	/**
	 * Creates a new publisher.<br/>
	 * This method executes a partial query on the createPublisher mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createPublisher</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Publisher createPublisher = executor.createPublisherWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisher, // A value for createPublisher's publisher input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publisher Parameter for the createPublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Publisher createPublisherWithBindValues(String queryResponseDef, PublisherInput publisher,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPublisherWithBindValues(queryResponseDef, publisher, parameters));
	}

	/**
	 * Creates a new publisher.<br/>
	 * This method executes a partial query on the createPublisher mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createPublisher</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Publisher createPublisher = executor.createPublisher(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisher, // A value for createPublisher's publisher input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publisher Parameter for the createPublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Publisher createPublisher(String queryResponseDef, PublisherInput publisher, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPublisher(queryResponseDef, publisher, paramsAndValues));
	}

	/**
	 * Creates a new publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publisher createPublisher = executor.createPublisherWithBindValues(preparedRequest, publisher, // A value
	 * 																										// for
	 * 																										// createPublisher's
	 * 																										// publisher
	 * 																										// input
	 * 																										// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePublisherGraphQLRequest(String)} method.
	 * @param publisher Parameter for the createPublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Publisher createPublisherWithBindValues(ObjectResponse objectResponse, PublisherInput publisher,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPublisherWithBindValues(objectResponse, publisher, parameters));
	}

	/**
	 * Creates a new publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publisher createPublisher = executor.createPublisher(preparedRequest, publisher, // A value for
	 * 																							// createPublisher's
	 * 																							// publisher input
	 * 																							// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePublisherGraphQLRequest(String)} method.
	 * @param publisher Parameter for the createPublisher field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Publisher createPublisher(ObjectResponse objectResponse, PublisherInput publisher, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPublisher(objectResponse, publisher, paramsAndValues));
	}

	/**
	 * Creates a new publisher.<br/>
	 * Get the {@link Builder} for the Publisher, as expected by the createPublisher query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreatePublisherResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getCreatePublisherResponseBuilder();
	}

	/**
	 * Creates a new publisher.<br/>
	 * Get the {@link GraphQLRequest} for the createPublisher EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getCreatePublisherGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createPublisher",
			InputParameter.newBindParameter("", "publisher", "mutationCreatePublisherPublisher", MANDATORY,
				"PublisherInput", true, 0, false));
	}

	/**
	 * Updates an existing publisher.<br/>
	 * This method executes a partial query on the updatePublisher mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updatePublisher</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Publisher updatePublisher = executor.updatePublisherWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisher, // A value for updatePublisher's publisher input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publisher Parameter for the updatePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Publisher updatePublisherWithBindValues(String queryResponseDef, PublisherInput publisher,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePublisherWithBindValues(queryResponseDef, publisher, parameters));
	}

	/**
	 * Updates an existing publisher.<br/>
	 * This method executes a partial query on the updatePublisher mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updatePublisher</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Publisher updatePublisher = executor.updatePublisher(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisher, // A value for updatePublisher's publisher input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publisher Parameter for the updatePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Publisher updatePublisher(String queryResponseDef, PublisherInput publisher, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePublisher(queryResponseDef, publisher, paramsAndValues));
	}

	/**
	 * Updates an existing publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publisher updatePublisher = executor.updatePublisherWithBindValues(preparedRequest, publisher, // A value
	 * 																										// for
	 * 																										// updatePublisher's
	 * 																										// publisher
	 * 																										// input
	 * 																										// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePublisherGraphQLRequest(String)} method.
	 * @param publisher Parameter for the updatePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Publisher updatePublisherWithBindValues(ObjectResponse objectResponse, PublisherInput publisher,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePublisherWithBindValues(objectResponse, publisher, parameters));
	}

	/**
	 * Updates an existing publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publisher updatePublisher = executor.updatePublisher(preparedRequest, publisher, // A value for
	 * 																							// updatePublisher's
	 * 																							// publisher input
	 * 																							// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePublisherGraphQLRequest(String)} method.
	 * @param publisher Parameter for the updatePublisher field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Publisher updatePublisher(ObjectResponse objectResponse, PublisherInput publisher, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePublisher(objectResponse, publisher, paramsAndValues));
	}

	/**
	 * Updates an existing publisher.<br/>
	 * Get the {@link Builder} for the Publisher, as expected by the updatePublisher query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdatePublisherResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdatePublisherResponseBuilder();
	}

	/**
	 * Updates an existing publisher.<br/>
	 * Get the {@link GraphQLRequest} for the updatePublisher EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdatePublisherGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updatePublisher",
			InputParameter.newBindParameter("", "publisher", "mutationUpdatePublisherPublisher", MANDATORY,
				"PublisherInput", true, 0, false));
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * This method executes a partial query on the deletePublisher mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deletePublisher</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Publisher deletePublisher = executor.deletePublisherWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisherId, // A value for deletePublisher's publisherId input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publisherId Parameter for the deletePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Publisher deletePublisherWithBindValues(String queryResponseDef, Long publisherId,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePublisherWithBindValues(queryResponseDef, publisherId, parameters));
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * This method executes a partial query on the deletePublisher mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deletePublisher</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Publisher deletePublisher = executor.deletePublisher(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisherId, // A value for deletePublisher's publisherId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publisherId Parameter for the deletePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Publisher deletePublisher(String queryResponseDef, Long publisherId, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePublisher(queryResponseDef, publisherId, paramsAndValues));
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publisher deletePublisher = executor.deletePublisherWithBindValues(preparedRequest, publisherId, // A
	 * 																											// value
	 * 																											// for
	 * 																											// deletePublisher's
	 * 																											// publisherId
	 * 																											// input
	 * 																											// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePublisherGraphQLRequest(String)} method.
	 * @param publisherId Parameter for the deletePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Publisher deletePublisherWithBindValues(ObjectResponse objectResponse, Long publisherId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePublisherWithBindValues(objectResponse, publisherId, parameters));
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publisher deletePublisher = executor.deletePublisher(preparedRequest, publisherId, // A value for
	 * 																							// deletePublisher's
	 * 																							// publisherId input
	 * 																							// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePublisherGraphQLRequest(String)} method.
	 * @param publisherId Parameter for the deletePublisher field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Publisher deletePublisher(ObjectResponse objectResponse, Long publisherId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePublisher(objectResponse, publisherId, paramsAndValues));
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * Get the {@link Builder} for the Publisher, as expected by the deletePublisher query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeletePublisherResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getDeletePublisherResponseBuilder();
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * Get the {@link GraphQLRequest} for the deletePublisher EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDeletePublisherGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deletePublisher",
			InputParameter.newBindParameter("", "publisherId", "mutationDeletePublisherPublisherId", MANDATORY, "ID",
				true, 0, false));
	}

	/**
	 * Creates a new quotation.<br/>
	 * This method executes a partial query on the createQuotation mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createQuotation</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Quotation createQuotation = executor.createQuotationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotation, // A value for createQuotation's quotation input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param quotation Parameter for the createQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Quotation createQuotationWithBindValues(String queryResponseDef, QuotationInput quotation,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createQuotationWithBindValues(queryResponseDef, quotation, parameters));
	}

	/**
	 * Creates a new quotation.<br/>
	 * This method executes a partial query on the createQuotation mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createQuotation</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Quotation createQuotation = executor.createQuotation(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotation, // A value for createQuotation's quotation input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param quotation Parameter for the createQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Quotation createQuotation(String queryResponseDef, QuotationInput quotation, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createQuotation(queryResponseDef, quotation, paramsAndValues));
	}

	/**
	 * Creates a new quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Quotation createQuotation = executor.createQuotationWithBindValues(preparedRequest, quotation, // A value
	 * 																										// for
	 * 																										// createQuotation's
	 * 																										// quotation
	 * 																										// input
	 * 																										// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateQuotationGraphQLRequest(String)} method.
	 * @param quotation Parameter for the createQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Quotation createQuotationWithBindValues(ObjectResponse objectResponse, QuotationInput quotation,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createQuotationWithBindValues(objectResponse, quotation, parameters));
	}

	/**
	 * Creates a new quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Quotation createQuotation = executor.createQuotation(preparedRequest, quotation, // A value for
	 * 																							// createQuotation's
	 * 																							// quotation input
	 * 																							// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateQuotationGraphQLRequest(String)} method.
	 * @param quotation Parameter for the createQuotation field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Quotation createQuotation(ObjectResponse objectResponse, QuotationInput quotation, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createQuotation(objectResponse, quotation, paramsAndValues));
	}

	/**
	 * Creates a new quotation.<br/>
	 * Get the {@link Builder} for the Quotation, as expected by the createQuotation query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreateQuotationResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getCreateQuotationResponseBuilder();
	}

	/**
	 * Creates a new quotation.<br/>
	 * Get the {@link GraphQLRequest} for the createQuotation EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getCreateQuotationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createQuotation",
			InputParameter.newBindParameter("", "quotation", "mutationCreateQuotationQuotation", MANDATORY,
				"QuotationInput", true, 0, false));
	}

	/**
	 * Updates an existing quotation.<br/>
	 * This method executes a partial query on the updateQuotation mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateQuotation</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Quotation updateQuotation = executor.updateQuotationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotation, // A value for updateQuotation's quotation input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param quotation Parameter for the updateQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Quotation updateQuotationWithBindValues(String queryResponseDef, QuotationInput quotation,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateQuotationWithBindValues(queryResponseDef, quotation, parameters));
	}

	/**
	 * Updates an existing quotation.<br/>
	 * This method executes a partial query on the updateQuotation mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateQuotation</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Quotation updateQuotation = executor.updateQuotation(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotation, // A value for updateQuotation's quotation input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param quotation Parameter for the updateQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Quotation updateQuotation(String queryResponseDef, QuotationInput quotation, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateQuotation(queryResponseDef, quotation, paramsAndValues));
	}

	/**
	 * Updates an existing quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Quotation updateQuotation = executor.updateQuotationWithBindValues(preparedRequest, quotation, // A value
	 * 																										// for
	 * 																										// updateQuotation's
	 * 																										// quotation
	 * 																										// input
	 * 																										// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateQuotationGraphQLRequest(String)} method.
	 * @param quotation Parameter for the updateQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Quotation updateQuotationWithBindValues(ObjectResponse objectResponse, QuotationInput quotation,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateQuotationWithBindValues(objectResponse, quotation, parameters));
	}

	/**
	 * Updates an existing quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Quotation updateQuotation = executor.updateQuotation(preparedRequest, quotation, // A value for
	 * 																							// updateQuotation's
	 * 																							// quotation input
	 * 																							// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateQuotationGraphQLRequest(String)} method.
	 * @param quotation Parameter for the updateQuotation field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Quotation updateQuotation(ObjectResponse objectResponse, QuotationInput quotation, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateQuotation(objectResponse, quotation, paramsAndValues));
	}

	/**
	 * Updates an existing quotation.<br/>
	 * Get the {@link Builder} for the Quotation, as expected by the updateQuotation query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdateQuotationResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdateQuotationResponseBuilder();
	}

	/**
	 * Updates an existing quotation.<br/>
	 * Get the {@link GraphQLRequest} for the updateQuotation EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdateQuotationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateQuotation",
			InputParameter.newBindParameter("", "quotation", "mutationUpdateQuotationQuotation", MANDATORY,
				"QuotationInput", true, 0, false));
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * This method executes a partial query on the deleteQuotation mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteQuotation</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Quotation deleteQuotation = executor.deleteQuotationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotationId, // A value for deleteQuotation's quotationId input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param quotationId Parameter for the deleteQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Quotation deleteQuotationWithBindValues(String queryResponseDef, Long quotationId,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteQuotationWithBindValues(queryResponseDef, quotationId, parameters));
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * This method executes a partial query on the deleteQuotation mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteQuotation</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Quotation deleteQuotation = executor.deleteQuotation(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotationId, // A value for deleteQuotation's quotationId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param quotationId Parameter for the deleteQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Quotation deleteQuotation(String queryResponseDef, Long quotationId, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteQuotation(queryResponseDef, quotationId, paramsAndValues));
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Quotation deleteQuotation = executor.deleteQuotationWithBindValues(preparedRequest, quotationId, // A
	 * 																											// value
	 * 																											// for
	 * 																											// deleteQuotation's
	 * 																											// quotationId
	 * 																											// input
	 * 																											// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteQuotationGraphQLRequest(String)} method.
	 * @param quotationId Parameter for the deleteQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Quotation deleteQuotationWithBindValues(ObjectResponse objectResponse, Long quotationId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteQuotationWithBindValues(objectResponse, quotationId, parameters));
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Quotation deleteQuotation = executor.deleteQuotation(preparedRequest, quotationId, // A value for
	 * 																							// deleteQuotation's
	 * 																							// quotationId input
	 * 																							// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteQuotationGraphQLRequest(String)} method.
	 * @param quotationId Parameter for the deleteQuotation field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Quotation deleteQuotation(ObjectResponse objectResponse, Long quotationId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteQuotation(objectResponse, quotationId, paramsAndValues));
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * Get the {@link Builder} for the Quotation, as expected by the deleteQuotation query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeleteQuotationResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getDeleteQuotationResponseBuilder();
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * Get the {@link GraphQLRequest} for the deleteQuotation EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDeleteQuotationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteQuotation",
			InputParameter.newBindParameter("", "quotationId", "mutationDeleteQuotationQuotationId", MANDATORY, "ID",
				true, 0, false));
	}

	/**
	 * Creates a new topic.<br/>
	 * This method executes a partial query on the createTopic mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createTopic</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Topic createTopic = executor.createTopicWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topic, // A value for createTopic's topic input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topic Parameter for the createTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Topic createTopicWithBindValues(String queryResponseDef, TopicInput topic, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createTopicWithBindValues(queryResponseDef, topic, parameters));
	}

	/**
	 * Creates a new topic.<br/>
	 * This method executes a partial query on the createTopic mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createTopic</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Topic createTopic = executor.createTopic(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topic, // A value for createTopic's topic input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topic Parameter for the createTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Topic createTopic(String queryResponseDef, TopicInput topic, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createTopic(queryResponseDef, topic, paramsAndValues));
	}

	/**
	 * Creates a new topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Topic createTopic = executor.createTopicWithBindValues(preparedRequest, topic, // A value for
	 * 																						// createTopic's topic
	 * 																						// input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateTopicGraphQLRequest(String)} method.
	 * @param topic Parameter for the createTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Topic createTopicWithBindValues(ObjectResponse objectResponse, TopicInput topic,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createTopicWithBindValues(objectResponse, topic, parameters));
	}

	/**
	 * Creates a new topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Topic createTopic = executor.createTopic(preparedRequest, topic, // A value for createTopic's topic input
	 * 																			// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateTopicGraphQLRequest(String)} method.
	 * @param topic Parameter for the createTopic field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Topic createTopic(ObjectResponse objectResponse, TopicInput topic, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createTopic(objectResponse, topic, paramsAndValues));
	}

	/**
	 * Creates a new topic.<br/>
	 * Get the {@link Builder} for the Topic, as expected by the createTopic query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreateTopicResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getCreateTopicResponseBuilder();
	}

	/**
	 * Creates a new topic.<br/>
	 * Get the {@link GraphQLRequest} for the createTopic EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getCreateTopicGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createTopic",
			InputParameter.newBindParameter("", "topic", "mutationCreateTopicTopic", MANDATORY, "TopicInput", true, 0,
				false));
	}

	/**
	 * Updates an existing topic.<br/>
	 * This method executes a partial query on the updateTopic mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateTopic</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Topic updateTopic = executor.updateTopicWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topic, // A value for updateTopic's topic input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topic Parameter for the updateTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Topic updateTopicWithBindValues(String queryResponseDef, TopicInput topic, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateTopicWithBindValues(queryResponseDef, topic, parameters));
	}

	/**
	 * Updates an existing topic.<br/>
	 * This method executes a partial query on the updateTopic mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateTopic</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Topic updateTopic = executor.updateTopic(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topic, // A value for updateTopic's topic input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topic Parameter for the updateTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Topic updateTopic(String queryResponseDef, TopicInput topic, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateTopic(queryResponseDef, topic, paramsAndValues));
	}

	/**
	 * Updates an existing topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Topic updateTopic = executor.updateTopicWithBindValues(preparedRequest, topic, // A value for
	 * 																						// updateTopic's topic
	 * 																						// input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateTopicGraphQLRequest(String)} method.
	 * @param topic Parameter for the updateTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Topic updateTopicWithBindValues(ObjectResponse objectResponse, TopicInput topic,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateTopicWithBindValues(objectResponse, topic, parameters));
	}

	/**
	 * Updates an existing topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Topic updateTopic = executor.updateTopic(preparedRequest, topic, // A value for updateTopic's topic input
	 * 																			// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateTopicGraphQLRequest(String)} method.
	 * @param topic Parameter for the updateTopic field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Topic updateTopic(ObjectResponse objectResponse, TopicInput topic, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateTopic(objectResponse, topic, paramsAndValues));
	}

	/**
	 * Updates an existing topic.<br/>
	 * Get the {@link Builder} for the Topic, as expected by the updateTopic query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdateTopicResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdateTopicResponseBuilder();
	}

	/**
	 * Updates an existing topic.<br/>
	 * Get the {@link GraphQLRequest} for the updateTopic EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdateTopicGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateTopic",
			InputParameter.newBindParameter("", "topic", "mutationUpdateTopicTopic", MANDATORY, "TopicInput", true, 0,
				false));
	}

	/**
	 * Deletes an existing topic.<br/>
	 * This method executes a partial query on the deleteTopic mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteTopic</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Topic deleteTopic = executor.deleteTopicWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topicId, // A value for deleteTopic's topicId input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topicId Parameter for the deleteTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Topic deleteTopicWithBindValues(String queryResponseDef, Long topicId, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteTopicWithBindValues(queryResponseDef, topicId, parameters));
	}

	/**
	 * Deletes an existing topic.<br/>
	 * This method executes a partial query on the deleteTopic mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteTopic</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Topic deleteTopic = executor.deleteTopic(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topicId, // A value for deleteTopic's topicId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topicId Parameter for the deleteTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Topic deleteTopic(String queryResponseDef, Long topicId, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteTopic(queryResponseDef, topicId, paramsAndValues));
	}

	/**
	 * Deletes an existing topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Topic deleteTopic = executor.deleteTopicWithBindValues(preparedRequest, topicId, // A value for
	 * 																							// deleteTopic's
	 * 																							// topicId input
	 * 																							// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteTopicGraphQLRequest(String)} method.
	 * @param topicId Parameter for the deleteTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Topic deleteTopicWithBindValues(ObjectResponse objectResponse, Long topicId, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteTopicWithBindValues(objectResponse, topicId, parameters));
	}

	/**
	 * Deletes an existing topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Topic deleteTopic = executor.deleteTopic(preparedRequest, topicId, // A value for deleteTopic's topicId
	 * 																			// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteTopicGraphQLRequest(String)} method.
	 * @param topicId Parameter for the deleteTopic field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Topic deleteTopic(ObjectResponse objectResponse, Long topicId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteTopic(objectResponse, topicId, paramsAndValues));
	}

	/**
	 * Deletes an existing topic.<br/>
	 * Get the {@link Builder} for the Topic, as expected by the deleteTopic query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeleteTopicResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getDeleteTopicResponseBuilder();
	}

	/**
	 * Deletes an existing topic.<br/>
	 * Get the {@link GraphQLRequest} for the deleteTopic EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDeleteTopicGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteTopic",
			InputParameter.newBindParameter("", "topicId", "mutationDeleteTopicTopicId", MANDATORY, "ID", true, 0,
				false));
	}

	/**
	 * Sets entity status.<br/>
	 * This method executes a partial query on the setEntityStatus mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>setEntityStatus</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Boolean setEntityStatus = executor.setEntityStatusWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			entityId, // A value for setEntityStatus's entityId input parameter
	 * 			status, // A value for setEntityStatus's status input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param entityId Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param status Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "setEntityStatus", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Boolean setEntityStatusWithBindValues(String queryResponseDef, Long entityId, StatusKind status,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(this.mutationReactiveExecutor.setEntityStatusWithBindValues(queryResponseDef,
			entityId, status, parameters));
	}

	/**
	 * Sets entity status.<br/>
	 * This method executes a partial query on the setEntityStatus mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>setEntityStatus</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Boolean setEntityStatus = executor.setEntityStatus(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			entityId, // A value for setEntityStatus's entityId input parameter
	 * 			status, // A value for setEntityStatus's status input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param entityId Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param status Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "setEntityStatus", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Boolean setEntityStatus(String queryResponseDef, Long entityId, StatusKind status, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.setEntityStatus(queryResponseDef, entityId, status, paramsAndValues));
	}

	/**
	 * Sets entity status.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getSetEntityStatusGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Boolean setEntityStatus = executor.setEntityStatusWithBindValues(preparedRequest, entityId, // A value
	 * 																									// for
	 * 																									// setEntityStatus's
	 * 																									// entityId
	 * 																									// input
	 * 																									// parameter
	 * 			status, // A value for setEntityStatus's status input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getSetEntityStatusGraphQLRequest(String)} method.
	 * @param entityId Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param status Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "setEntityStatus", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Boolean setEntityStatusWithBindValues(ObjectResponse objectResponse, Long entityId, StatusKind status,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.setEntityStatusWithBindValues(objectResponse, entityId, status, parameters));
	}

	/**
	 * Sets entity status.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getSetEntityStatusGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Boolean setEntityStatus = executor.setEntityStatus(preparedRequest, entityId, // A value for
	 * 																						// setEntityStatus's
	 * 																						// entityId input
	 * 																						// parameter
	 * 			status, // A value for setEntityStatus's status input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getSetEntityStatusGraphQLRequest(String)} method.
	 * @param entityId Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param status Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "setEntityStatus", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Boolean setEntityStatus(ObjectResponse objectResponse, Long entityId, StatusKind status,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.setEntityStatus(objectResponse, entityId, status, paramsAndValues));
	}

	/**
	 * Sets entity status.<br/>
	 * Get the {@link Builder} for the Boolean, as expected by the setEntityStatus query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getSetEntityStatusResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getSetEntityStatusResponseBuilder();
	}

	/**
	 * Sets entity status.<br/>
	 * Get the {@link GraphQLRequest} for the setEntityStatus EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getSetEntityStatusGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "setEntityStatus",
			InputParameter.newBindParameter("", "entityId", "mutationSetEntityStatusEntityId", MANDATORY, "ID", true, 0,
				false),
			InputParameter.newBindParameter("", "status", "mutationSetEntityStatusStatus", MANDATORY, "StatusKind",
				true, 0, false));
	}

	/**
	 * Creates a new user.<br/>
	 * This method executes a partial query on the createUser mutation against the GraphQL server. That is, the mutation
	 * is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains the part of
	 * the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createUser</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		User createUser = executor.createUserWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for createUser's user input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param user Parameter for the createUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User createUserWithBindValues(String queryResponseDef, UserInput user, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createUserWithBindValues(queryResponseDef, user, parameters));
	}

	/**
	 * Creates a new user.<br/>
	 * This method executes a partial query on the createUser mutation against the GraphQL server. That is, the mutation
	 * is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains the part of
	 * the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createUser</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		User createUser = executor.createUser(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for createUser's user input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param user Parameter for the createUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User createUser(String queryResponseDef, UserInput user, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createUser(queryResponseDef, user, paramsAndValues));
	}

	/**
	 * Creates a new user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User createUser = executor.createUserWithBindValues(preparedRequest, user, // A value for createUser's
	 * 																					// user input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateUserGraphQLRequest(String)} method.
	 * @param user Parameter for the createUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User createUserWithBindValues(ObjectResponse objectResponse, UserInput user, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createUserWithBindValues(objectResponse, user, parameters));
	}

	/**
	 * Creates a new user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User createUser = executor.createUser(preparedRequest, user, // A value for createUser's user input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateUserGraphQLRequest(String)} method.
	 * @param user Parameter for the createUser field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User createUser(ObjectResponse objectResponse, UserInput user, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createUser(objectResponse, user, paramsAndValues));
	}

	/**
	 * Creates a new user.<br/>
	 * Get the {@link Builder} for the User, as expected by the createUser query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreateUserResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getCreateUserResponseBuilder();
	}

	/**
	 * Creates a new user.<br/>
	 * Get the {@link GraphQLRequest} for the createUser EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getCreateUserGraphQLRequest(String partialRequest) throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createUser", InputParameter
			.newBindParameter("", "user", "mutationCreateUserUser", MANDATORY, "UserInput", true, 0, false));
	}

	/**
	 * Updates an existing user.<br/>
	 * This method executes a partial query on the updateUser mutation against the GraphQL server. That is, the mutation
	 * is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains the part of
	 * the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateUser</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		User updateUser = executor.updateUserWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for updateUser's user input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param user Parameter for the updateUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User updateUserWithBindValues(String queryResponseDef, UserInput user, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateUserWithBindValues(queryResponseDef, user, parameters));
	}

	/**
	 * Updates an existing user.<br/>
	 * This method executes a partial query on the updateUser mutation against the GraphQL server. That is, the mutation
	 * is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains the part of
	 * the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateUser</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		User updateUser = executor.updateUser(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for updateUser's user input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param user Parameter for the updateUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User updateUser(String queryResponseDef, UserInput user, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateUser(queryResponseDef, user, paramsAndValues));
	}

	/**
	 * Updates an existing user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User updateUser = executor.updateUserWithBindValues(preparedRequest, user, // A value for updateUser's
	 * 																					// user input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateUserGraphQLRequest(String)} method.
	 * @param user Parameter for the updateUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User updateUserWithBindValues(ObjectResponse objectResponse, UserInput user, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateUserWithBindValues(objectResponse, user, parameters));
	}

	/**
	 * Updates an existing user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User updateUser = executor.updateUser(preparedRequest, user, // A value for updateUser's user input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateUserGraphQLRequest(String)} method.
	 * @param user Parameter for the updateUser field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User updateUser(ObjectResponse objectResponse, UserInput user, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateUser(objectResponse, user, paramsAndValues));
	}

	/**
	 * Updates an existing user.<br/>
	 * Get the {@link Builder} for the User, as expected by the updateUser query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdateUserResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdateUserResponseBuilder();
	}

	/**
	 * Updates an existing user.<br/>
	 * Get the {@link GraphQLRequest} for the updateUser EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdateUserGraphQLRequest(String partialRequest) throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateUser", InputParameter
			.newBindParameter("", "user", "mutationUpdateUserUser", MANDATORY, "UserInput", true, 0, false));
	}

	/**
	 * Updates an existing user's password.<br/>
	 * This method executes a partial query on the updateUserPassword mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateUserPassword</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for
	 * a scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		User updateUserPassword = executor.updateUserPasswordWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for updateUserPassword's user input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param user Parameter for the updateUserPassword field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUserPassword", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User updateUserPasswordWithBindValues(String queryResponseDef, UserPasswordInput user,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateUserPasswordWithBindValues(queryResponseDef, user, parameters));
	}

	/**
	 * Updates an existing user's password.<br/>
	 * This method executes a partial query on the updateUserPassword mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateUserPassword</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for
	 * a scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		User updateUserPassword = executor.updateUserPassword(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for updateUserPassword's user input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param user Parameter for the updateUserPassword field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUserPassword", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User updateUserPassword(String queryResponseDef, UserPasswordInput user, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateUserPassword(queryResponseDef, user, paramsAndValues));
	}

	/**
	 * Updates an existing user's password.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateUserPasswordGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User updateUserPassword = executor.updateUserPasswordWithBindValues(preparedRequest, user, // A value for
	 * 																									// updateUserPassword's
	 * 																									// user input
	 * 																									// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateUserPasswordGraphQLRequest(String)} method.
	 * @param user Parameter for the updateUserPassword field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUserPassword", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User updateUserPasswordWithBindValues(ObjectResponse objectResponse, UserPasswordInput user,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateUserPasswordWithBindValues(objectResponse, user, parameters));
	}

	/**
	 * Updates an existing user's password.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateUserPasswordGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User updateUserPassword = executor.updateUserPassword(preparedRequest, user, // A value for
	 * 																						// updateUserPassword's
	 * 																						// user input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateUserPasswordGraphQLRequest(String)} method.
	 * @param user Parameter for the updateUserPassword field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUserPassword", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User updateUserPassword(ObjectResponse objectResponse, UserPasswordInput user, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateUserPassword(objectResponse, user, paramsAndValues));
	}

	/**
	 * Updates an existing user's password.<br/>
	 * Get the {@link Builder} for the User, as expected by the updateUserPassword query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdateUserPasswordResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdateUserPasswordResponseBuilder();
	}

	/**
	 * Updates an existing user's password.<br/>
	 * Get the {@link GraphQLRequest} for the updateUserPassword EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdateUserPasswordGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateUserPassword",
			InputParameter.newBindParameter("", "user", "mutationUpdateUserPasswordUser", InputParameterType.MANDATORY,
				"UserPasswordInput", true, 0, false));
	}

	/**
	 * Updates an existing user's profile.<br/>
	 * This method executes a partial query on the updateUserProfile mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateUserProfile</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		User updateUserProfile = executor.updateUserProfileWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for updateUserProfile's user input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param user Parameter for the updateUserProfile field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUserProfile", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User updateUserProfileWithBindValues(String queryResponseDef, UserProfileInput user,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateUserProfileWithBindValues(queryResponseDef, user, parameters));
	}

	/**
	 * Updates an existing user's profile.<br/>
	 * This method executes a partial query on the updateUserProfile mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateUserProfile</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		User updateUserProfile = executor.updateUserProfile(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for updateUserProfile's user input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param user Parameter for the updateUserProfile field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUserProfile", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User updateUserProfile(String queryResponseDef, UserProfileInput user, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateUserProfile(queryResponseDef, user, paramsAndValues));
	}

	/**
	 * Updates an existing user's profile.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateUserProfileGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User updateUserProfile = executor.updateUserProfileWithBindValues(preparedRequest, user, // A value for
	 * 																									// updateUserProfile's
	 * 																									// user input
	 * 																									// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateUserProfileGraphQLRequest(String)} method.
	 * @param user Parameter for the updateUserProfile field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUserProfile", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User updateUserProfileWithBindValues(ObjectResponse objectResponse, UserProfileInput user,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateUserProfileWithBindValues(objectResponse, user, parameters));
	}

	/**
	 * Updates an existing user's profile.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateUserProfileGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User updateUserProfile = executor.updateUserProfile(preparedRequest, user, // A value for
	 * 																					// updateUserProfile's user
	 * 																					// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateUserProfileGraphQLRequest(String)} method.
	 * @param user Parameter for the updateUserProfile field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUserProfile", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User updateUserProfile(ObjectResponse objectResponse, UserProfileInput user, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateUserProfile(objectResponse, user, paramsAndValues));
	}

	/**
	 * Updates an existing user's profile.<br/>
	 * Get the {@link Builder} for the User, as expected by the updateUserProfile query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdateUserProfileResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdateUserProfileResponseBuilder();
	}

	/**
	 * Updates an existing user's profile.<br/>
	 * Get the {@link GraphQLRequest} for the updateUserProfile EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdateUserProfileGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateUserProfile",
			InputParameter.newBindParameter("", "user", "mutationUpdateUserProfileUser", InputParameterType.MANDATORY,
				"UserProfileInput", true, 0, false));
	}

	/**
	 * Deletes an existing user.<br/>
	 * This method executes a partial query on the deleteUser mutation against the GraphQL server. That is, the mutation
	 * is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains the part of
	 * the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteUser</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		User deleteUser = executor.deleteUserWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for deleteUser's userId input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param userId Parameter for the deleteUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User deleteUserWithBindValues(String queryResponseDef, Long userId, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteUserWithBindValues(queryResponseDef, userId, parameters));
	}

	/**
	 * Deletes an existing user.<br/>
	 * This method executes a partial query on the deleteUser mutation against the GraphQL server. That is, the mutation
	 * is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains the part of
	 * the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteUser</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		User deleteUser = executor.deleteUser(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for deleteUser's userId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param userId Parameter for the deleteUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User deleteUser(String queryResponseDef, Long userId, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteUser(queryResponseDef, userId, paramsAndValues));
	}

	/**
	 * Deletes an existing user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User deleteUser = executor.deleteUserWithBindValues(preparedRequest, userId, // A value for deleteUser's
	 * 																						// userId input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteUserGraphQLRequest(String)} method.
	 * @param userId Parameter for the deleteUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User deleteUserWithBindValues(ObjectResponse objectResponse, Long userId, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteUserWithBindValues(objectResponse, userId, parameters));
	}

	/**
	 * Deletes an existing user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User deleteUser = executor.deleteUser(preparedRequest, userId, // A value for deleteUser's userId input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteUserGraphQLRequest(String)} method.
	 * @param userId Parameter for the deleteUser field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User deleteUser(ObjectResponse objectResponse, Long userId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteUser(objectResponse, userId, paramsAndValues));
	}

	/**
	 * Deletes an existing user.<br/>
	 * Get the {@link Builder} for the User, as expected by the deleteUser query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeleteUserResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getDeleteUserResponseBuilder();
	}

	/**
	 * Deletes an existing user.<br/>
	 * Get the {@link GraphQLRequest} for the deleteUser EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDeleteUserGraphQLRequest(String partialRequest) throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteUser",
			InputParameter.newBindParameter("", "userId", "mutationDeleteUserUserId", MANDATORY, "ID", true, 0, false));
	}

	/**
	 * Grants authorities to a user. The specified authorities are added to any existing ones.<br/>
	 * This method executes a partial query on the grantUserAuthorities mutation against the GraphQL server. That is,
	 * the mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef
	 * contains the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>grantUserAuthorities</code> of the Mutation mutation type. It can be something like "{ id name }", or ""
	 * for a scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		User grantUserAuthorities = executor.grantUserAuthoritiesWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for grantUserAuthorities's userId input parameter
	 * 			authorities, // A value for grantUserAuthorities's authorities input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param userId Parameter for the grantUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the grantUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantUserAuthorities", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User grantUserAuthoritiesWithBindValues(String queryResponseDef, Long userId,
		List<AuthorityKind> authorities, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(this.mutationReactiveExecutor
			.grantUserAuthoritiesWithBindValues(queryResponseDef, userId, authorities, parameters));
	}

	/**
	 * Grants authorities to a user. The specified authorities are added to any existing ones.<br/>
	 * This method executes a partial query on the grantUserAuthorities mutation against the GraphQL server. That is,
	 * the mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef
	 * contains the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>grantUserAuthorities</code> of the Mutation mutation type. It can be something like "{ id name }", or ""
	 * for a scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		User grantUserAuthorities = executor.grantUserAuthorities(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for grantUserAuthorities's userId input parameter
	 * 			authorities, // A value for grantUserAuthorities's authorities input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param userId Parameter for the grantUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the grantUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantUserAuthorities", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User grantUserAuthorities(String queryResponseDef, Long userId, List<AuthorityKind> authorities,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.grantUserAuthorities(queryResponseDef, userId, authorities, paramsAndValues));
	}

	/**
	 * Grants authorities to a user. The specified authorities are added to any existing ones.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getGrantUserAuthoritiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User grantUserAuthorities = executor.grantUserAuthoritiesWithBindValues(preparedRequest, userId, // A
	 * 																											// value
	 * 																											// for
	 * 																											// grantUserAuthorities's
	 * 																											// userId
	 * 																											// input
	 * 																											// parameter
	 * 			authorities, // A value for grantUserAuthorities's authorities input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGrantUserAuthoritiesGraphQLRequest(String)} method.
	 * @param userId Parameter for the grantUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the grantUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantUserAuthorities", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User grantUserAuthoritiesWithBindValues(ObjectResponse objectResponse, Long userId,
		List<AuthorityKind> authorities, Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(this.mutationReactiveExecutor.grantUserAuthoritiesWithBindValues(objectResponse,
			userId, authorities, parameters));
	}

	/**
	 * Grants authorities to a user. The specified authorities are added to any existing ones.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getGrantUserAuthoritiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User grantUserAuthorities = executor.grantUserAuthorities(preparedRequest, userId, // A value for
	 * 																							// grantUserAuthorities's
	 * 																							// userId input
	 * 																							// parameter
	 * 			authorities, // A value for grantUserAuthorities's authorities input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGrantUserAuthoritiesGraphQLRequest(String)} method.
	 * @param userId Parameter for the grantUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the grantUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantUserAuthorities", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User grantUserAuthorities(ObjectResponse objectResponse, Long userId, List<AuthorityKind> authorities,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.grantUserAuthorities(objectResponse, userId, authorities, paramsAndValues));
	}

	/**
	 * Grants authorities to a user. The specified authorities are added to any existing ones.<br/>
	 * Get the {@link Builder} for the User, as expected by the grantUserAuthorities query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getGrantUserAuthoritiesResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getGrantUserAuthoritiesResponseBuilder();
	}

	/**
	 * Grants authorities to a user. The specified authorities are added to any existing ones.<br/>
	 * Get the {@link GraphQLRequest} for the grantUserAuthorities EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getGrantUserAuthoritiesGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "grantUserAuthorities",
			InputParameter.newBindParameter("", "userId", "mutationGrantUserAuthoritiesUserId", MANDATORY, "ID", true,
				0, false),
			InputParameter.newBindParameter("", "authorities", "mutationGrantUserAuthoritiesAuthorities", MANDATORY,
				"AuthorityKind", true, 1, true));
	}

	/**
	 * Revokes authorities from a user. The specified authorities are removed from the user; other authorities remain
	 * intact.<br/>
	 * This method executes a partial query on the revokeUserAuthorities mutation against the GraphQL server. That is,
	 * the mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef
	 * contains the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>revokeUserAuthorities</code> of the Mutation mutation type. It can be something like "{ id name }", or ""
	 * for a scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		User revokeUserAuthorities = executor.revokeUserAuthoritiesWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for revokeUserAuthorities's userId input parameter
	 * 			authorities, // A value for revokeUserAuthorities's authorities input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param userId Parameter for the revokeUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the revokeUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeUserAuthorities", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User revokeUserAuthoritiesWithBindValues(String queryResponseDef, Long userId,
		List<AuthorityKind> authorities, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(this.mutationReactiveExecutor
			.revokeUserAuthoritiesWithBindValues(queryResponseDef, userId, authorities, parameters));
	}

	/**
	 * Revokes authorities from a user. The specified authorities are removed from the user; other authorities remain
	 * intact.<br/>
	 * This method executes a partial query on the revokeUserAuthorities mutation against the GraphQL server. That is,
	 * the mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef
	 * contains the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>revokeUserAuthorities</code> of the Mutation mutation type. It can be something like "{ id name }", or ""
	 * for a scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		User revokeUserAuthorities = executor.revokeUserAuthorities(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for revokeUserAuthorities's userId input parameter
	 * 			authorities, // A value for revokeUserAuthorities's authorities input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param userId Parameter for the revokeUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the revokeUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeUserAuthorities", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User revokeUserAuthorities(String queryResponseDef, Long userId, List<AuthorityKind> authorities,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(this.mutationReactiveExecutor.revokeUserAuthorities(queryResponseDef, userId,
			authorities, paramsAndValues));
	}

	/**
	 * Revokes authorities from a user. The specified authorities are removed from the user; other authorities remain
	 * intact.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getRevokeUserAuthoritiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User revokeUserAuthorities = executor.revokeUserAuthoritiesWithBindValues(preparedRequest, userId, // A
	 * 																											// value
	 * 																											// for
	 * 																											// revokeUserAuthorities's
	 * 																											// userId
	 * 																											// input
	 * 																											// parameter
	 * 			authorities, // A value for revokeUserAuthorities's authorities input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getRevokeUserAuthoritiesGraphQLRequest(String)} method.
	 * @param userId Parameter for the revokeUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the revokeUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeUserAuthorities", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User revokeUserAuthoritiesWithBindValues(ObjectResponse objectResponse, Long userId,
		List<AuthorityKind> authorities, Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(this.mutationReactiveExecutor
			.revokeUserAuthoritiesWithBindValues(objectResponse, userId, authorities, parameters));
	}

	/**
	 * Revokes authorities from a user. The specified authorities are removed from the user; other authorities remain
	 * intact.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getRevokeUserAuthoritiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User revokeUserAuthorities = executor.revokeUserAuthorities(preparedRequest, userId, // A value for
	 * 																								// revokeUserAuthorities's
	 * 																								// userId input
	 * 																								// parameter
	 * 			authorities, // A value for revokeUserAuthorities's authorities input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getRevokeUserAuthoritiesGraphQLRequest(String)} method.
	 * @param userId Parameter for the revokeUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the revokeUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeUserAuthorities", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public User revokeUserAuthorities(ObjectResponse objectResponse, Long userId, List<AuthorityKind> authorities,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.revokeUserAuthorities(objectResponse, userId, authorities, paramsAndValues));
	}

	/**
	 * Revokes authorities from a user. The specified authorities are removed from the user; other authorities remain
	 * intact.<br/>
	 * Get the {@link Builder} for the User, as expected by the revokeUserAuthorities query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getRevokeUserAuthoritiesResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getRevokeUserAuthoritiesResponseBuilder();
	}

	/**
	 * Revokes authorities from a user. The specified authorities are removed from the user; other authorities remain
	 * intact.<br/>
	 * Get the {@link GraphQLRequest} for the revokeUserAuthorities EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getRevokeUserAuthoritiesGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "revokeUserAuthorities",
			InputParameter.newBindParameter("", "userId", "mutationRevokeUserAuthoritiesUserId", MANDATORY, "ID", true,
				0, false),
			InputParameter.newBindParameter("", "authorities", "mutationRevokeUserAuthoritiesAuthorities", MANDATORY,
				"AuthorityKind", true, 1, true));
	}

	/**
	 * Creates a new group.<br/>
	 * This method executes a partial query on the createGroup mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createGroup</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Group createGroup = executor.createGroupWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			group, // A value for createGroup's group input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param group Parameter for the createGroup field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group createGroupWithBindValues(String queryResponseDef, GroupInput group, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createGroupWithBindValues(queryResponseDef, group, parameters));
	}

	/**
	 * Creates a new group.<br/>
	 * This method executes a partial query on the createGroup mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createGroup</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Group createGroup = executor.createGroup(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			group, // A value for createGroup's group input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param group Parameter for the createGroup field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group createGroup(String queryResponseDef, GroupInput group, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createGroup(queryResponseDef, group, paramsAndValues));
	}

	/**
	 * Creates a new group.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getCreateGroupGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Group createGroup = executor.createGroupWithBindValues(preparedRequest, group, // A value for
	 * 																						// createGroup's group
	 * 																						// input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateGroupGraphQLRequest(String)} method.
	 * @param group Parameter for the createGroup field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group createGroupWithBindValues(ObjectResponse objectResponse, GroupInput group,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createGroupWithBindValues(objectResponse, group, parameters));
	}

	/**
	 * Creates a new group.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getCreateGroupGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Group createGroup = executor.createGroup(preparedRequest, group, // A value for createGroup's group input
	 * 																			// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateGroupGraphQLRequest(String)} method.
	 * @param group Parameter for the createGroup field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group createGroup(ObjectResponse objectResponse, GroupInput group, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createGroup(objectResponse, group, paramsAndValues));
	}

	/**
	 * Creates a new group.<br/>
	 * Get the {@link Builder} for the Group, as expected by the createGroup query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreateGroupResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getCreateGroupResponseBuilder();
	}

	/**
	 * Creates a new group.<br/>
	 * Get the {@link GraphQLRequest} for the createGroup EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF= "https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getCreateGroupGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createGroup",
			InputParameter.newBindParameter("", "group", "mutationCreateGroupGroup", InputParameterType.MANDATORY,
				"GroupInput", true, 0, false));
	}

	/**
	 * Updates an existing group.<br/>
	 * This method executes a partial query on the updateGroup mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateGroup</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Group updateGroup = executor.updateGroupWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			group, // A value for updateGroup's group input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param group Parameter for the updateGroup field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group updateGroupWithBindValues(String queryResponseDef, GroupInput group, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateGroupWithBindValues(queryResponseDef, group, parameters));
	}

	/**
	 * Updates an existing group.<br/>
	 * This method executes a partial query on the updateGroup mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateGroup</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Group updateGroup = executor.updateGroup(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			group, // A value for updateGroup's group input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param group Parameter for the updateGroup field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group updateGroup(String queryResponseDef, GroupInput group, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateGroup(queryResponseDef, group, paramsAndValues));
	}

	/**
	 * Updates an existing group.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getUpdateGroupGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Group updateGroup = executor.updateGroupWithBindValues(preparedRequest, group, // A value for
	 * 																						// updateGroup's group
	 * 																						// input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateGroupGraphQLRequest(String)} method.
	 * @param group Parameter for the updateGroup field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group updateGroupWithBindValues(ObjectResponse objectResponse, GroupInput group,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateGroupWithBindValues(objectResponse, group, parameters));
	}

	/**
	 * Updates an existing group.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getUpdateGroupGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Group updateGroup = executor.updateGroup(preparedRequest, group, // A value for updateGroup's group input
	 * 																			// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateGroupGraphQLRequest(String)} method.
	 * @param group Parameter for the updateGroup field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group updateGroup(ObjectResponse objectResponse, GroupInput group, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateGroup(objectResponse, group, paramsAndValues));
	}

	/**
	 * Updates an existing group.<br/>
	 * Get the {@link Builder} for the Group, as expected by the updateGroup query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdateGroupResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdateGroupResponseBuilder();
	}

	/**
	 * Updates an existing group.<br/>
	 * Get the {@link GraphQLRequest} for the updateGroup EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF= "https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdateGroupGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateGroup",
			InputParameter.newBindParameter("", "group", "mutationUpdateGroupGroup", InputParameterType.MANDATORY,
				"GroupInput", true, 0, false));
	}

	/**
	 * Deletes an existing group.<br/>
	 * This method executes a partial query on the deleteGroup mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteGroup</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Group deleteGroup = executor.deleteGroupWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			groupId, // A value for deleteGroup's groupId input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param groupId Parameter for the deleteGroup field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "deleteGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group deleteGroupWithBindValues(String queryResponseDef, String groupId, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteGroupWithBindValues(queryResponseDef, groupId, parameters));
	}

	/**
	 * Deletes an existing group.<br/>
	 * This method executes a partial query on the deleteGroup mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteGroup</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Group deleteGroup = executor.deleteGroup(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			groupId, // A value for deleteGroup's groupId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param groupId Parameter for the deleteGroup field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "deleteGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group deleteGroup(String queryResponseDef, String groupId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteGroup(queryResponseDef, groupId, paramsAndValues));
	}

	/**
	 * Deletes an existing group.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getDeleteGroupGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Group deleteGroup = executor.deleteGroupWithBindValues(preparedRequest, groupId, // A value for
	 * 																							// deleteGroup's
	 * 																							// groupId input
	 * 																							// parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteGroupGraphQLRequest(String)} method.
	 * @param groupId Parameter for the deleteGroup field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "deleteGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group deleteGroupWithBindValues(ObjectResponse objectResponse, String groupId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteGroupWithBindValues(objectResponse, groupId, parameters));
	}

	/**
	 * Deletes an existing group.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getDeleteGroupGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Group deleteGroup = executor.deleteGroup(preparedRequest, groupId, // A value for deleteGroup's groupId
	 * 																			// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteGroupGraphQLRequest(String)} method.
	 * @param groupId Parameter for the deleteGroup field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "deleteGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group deleteGroup(ObjectResponse objectResponse, String groupId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteGroup(objectResponse, groupId, paramsAndValues));
	}

	/**
	 * Deletes an existing group.<br/>
	 * Get the {@link Builder} for the Group, as expected by the deleteGroup query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeleteGroupResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getDeleteGroupResponseBuilder();
	}

	/**
	 * Deletes an existing group.<br/>
	 * Get the {@link GraphQLRequest} for the deleteGroup EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF= "https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDeleteGroupGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteGroup",
			InputParameter.newBindParameter("", "groupId", "mutationDeleteGroupGroupId", InputParameterType.MANDATORY,
				"ID", true, 0, false));
	}

	/**
	 * Adds a user to a group.<br/>
	 * This method executes a partial query on the addGroupMember mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>addGroupMember</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Group addGroupMember = executor.addGroupMemberWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			groupId, // A value for addGroupMember's groupId input parameter
	 * 			userId, // A value for addGroupMember's userId input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param groupId Parameter for the addGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param userId Parameter for the addGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "addGroupMember", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group addGroupMemberWithBindValues(String queryResponseDef, String groupId, String userId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.addGroupMemberWithBindValues(queryResponseDef, groupId, userId, parameters));
	}

	/**
	 * Adds a user to a group.<br/>
	 * This method executes a partial query on the addGroupMember mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>addGroupMember</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Group addGroupMember = executor.addGroupMember(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			groupId, // A value for addGroupMember's groupId input parameter
	 * 			userId, // A value for addGroupMember's userId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param groupId Parameter for the addGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param userId Parameter for the addGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "addGroupMember", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group addGroupMember(String queryResponseDef, String groupId, String userId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.addGroupMember(queryResponseDef, groupId, userId, paramsAndValues));
	}

	/**
	 * Adds a user to a group.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getAddGroupMemberGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Group addGroupMember = executor.addGroupMemberWithBindValues(preparedRequest, groupId, // A value for
	 * 																								// addGroupMember's
	 * 																								// groupId input
	 * 																								// parameter
	 * 			userId, // A value for addGroupMember's userId input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getAddGroupMemberGraphQLRequest(String)} method.
	 * @param groupId Parameter for the addGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param userId Parameter for the addGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "addGroupMember", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group addGroupMemberWithBindValues(ObjectResponse objectResponse, String groupId, String userId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.addGroupMemberWithBindValues(objectResponse, groupId, userId, parameters));
	}

	/**
	 * Adds a user to a group.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getAddGroupMemberGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Group addGroupMember = executor.addGroupMember(preparedRequest, groupId, // A value for addGroupMember's
	 * 																					// groupId input parameter
	 * 			userId, // A value for addGroupMember's userId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getAddGroupMemberGraphQLRequest(String)} method.
	 * @param groupId Parameter for the addGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param userId Parameter for the addGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "addGroupMember", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group addGroupMember(ObjectResponse objectResponse, String groupId, String userId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.addGroupMember(objectResponse, groupId, userId, paramsAndValues));
	}

	/**
	 * Adds a user to a group.<br/>
	 * Get the {@link Builder} for the Group, as expected by the addGroupMember query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getAddGroupMemberResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getAddGroupMemberResponseBuilder();
	}

	/**
	 * Adds a user to a group.<br/>
	 * Get the {@link GraphQLRequest} for the addGroupMember EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF= "https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getAddGroupMemberGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "addGroupMember",
			InputParameter.newBindParameter("", "groupId", "mutationAddGroupMemberGroupId",
				InputParameterType.MANDATORY, "ID", true, 0, false),
			InputParameter.newBindParameter("", "userId", "mutationAddGroupMemberUserId", InputParameterType.MANDATORY,
				"ID", true, 0, false));
	}

	/**
	 * Removes a user from a group.<br/>
	 * This method executes a partial query on the removeGroupMember mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>removeGroupMember</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Group removeGroupMember = executor.removeGroupMemberWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			groupId, // A value for removeGroupMember's groupId input parameter
	 * 			userId, // A value for removeGroupMember's userId input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param groupId Parameter for the removeGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param userId Parameter for the removeGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "removeGroupMember", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group removeGroupMemberWithBindValues(String queryResponseDef, String groupId, String userId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(this.mutationReactiveExecutor.removeGroupMemberWithBindValues(queryResponseDef,
			groupId, userId, parameters));
	}

	/**
	 * Removes a user from a group.<br/>
	 * This method executes a partial query on the removeGroupMember mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>removeGroupMember</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Group removeGroupMember = executor.removeGroupMember(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			groupId, // A value for removeGroupMember's groupId input parameter
	 * 			userId, // A value for removeGroupMember's userId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param groupId Parameter for the removeGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param userId Parameter for the removeGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "removeGroupMember", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group removeGroupMember(String queryResponseDef, String groupId, String userId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.removeGroupMember(queryResponseDef, groupId, userId, paramsAndValues));
	}

	/**
	 * Removes a user from a group.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getRemoveGroupMemberGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Group removeGroupMember = executor.removeGroupMemberWithBindValues(preparedRequest, groupId, // A value
	 * 																										// for
	 * 																										// removeGroupMember's
	 * 																										// groupId
	 * 																										// input
	 * 																										// parameter
	 * 			userId, // A value for removeGroupMember's userId input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getRemoveGroupMemberGraphQLRequest(String)} method.
	 * @param groupId Parameter for the removeGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param userId Parameter for the removeGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "removeGroupMember", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group removeGroupMemberWithBindValues(ObjectResponse objectResponse, String groupId, String userId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.removeGroupMemberWithBindValues(objectResponse, groupId, userId, parameters));
	}

	/**
	 * Removes a user from a group.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getRemoveGroupMemberGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Group removeGroupMember = executor.removeGroupMember(preparedRequest, groupId, // A value for
	 * 																						// removeGroupMember's
	 * 																						// groupId input
	 * 																						// parameter
	 * 			userId, // A value for removeGroupMember's userId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getRemoveGroupMemberGraphQLRequest(String)} method.
	 * @param groupId Parameter for the removeGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param userId Parameter for the removeGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "removeGroupMember", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group removeGroupMember(ObjectResponse objectResponse, String groupId, String userId,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.removeGroupMember(objectResponse, groupId, userId, paramsAndValues));
	}

	/**
	 * Removes a user from a group.<br/>
	 * Get the {@link Builder} for the Group, as expected by the removeGroupMember query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getRemoveGroupMemberResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getRemoveGroupMemberResponseBuilder();
	}

	/**
	 * Removes a user from a group.<br/>
	 * Get the {@link GraphQLRequest} for the removeGroupMember EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF= "https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getRemoveGroupMemberGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "removeGroupMember",
			InputParameter.newBindParameter("", "groupId", "mutationRemoveGroupMemberGroupId",
				InputParameterType.MANDATORY, "ID", true, 0, false),
			InputParameter.newBindParameter("", "userId", "mutationRemoveGroupMemberUserId",
				InputParameterType.MANDATORY, "ID", true, 0, false));
	}

	/**
	 * Grants authorities to a group. The specified authorities are added to any existing ones.<br/>
	 * This method executes a partial query on the grantGroupAuthorities mutation against the GraphQL server. That is,
	 * the mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef
	 * contains the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>grantGroupAuthorities</code> of the Mutation mutation type. It can be something like "{ id name }", or ""
	 * for a scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Group grantGroupAuthorities = executor.grantGroupAuthoritiesWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for grantGroupAuthorities's userId input parameter
	 * 			authorities, // A value for grantGroupAuthorities's authorities input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param groupId Parameter for the grantGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the grantGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantGroupAuthorities", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group grantGroupAuthoritiesWithBindValues(String queryResponseDef, String groupId,
		List<AuthorityKind> authorities, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(this.mutationReactiveExecutor
			.grantGroupAuthoritiesWithBindValues(queryResponseDef, groupId, authorities, parameters));
	}

	/**
	 * Grants authorities to a group. The specified authorities are added to any existing ones.<br/>
	 * This method executes a partial query on the grantGroupAuthorities mutation against the GraphQL server. That is,
	 * the mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef
	 * contains the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>grantGroupAuthorities</code> of the Mutation mutation type. It can be something like "{ id name }", or ""
	 * for a scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Group grantGroupAuthorities = executor.grantGroupAuthorities(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for grantGroupAuthorities's userId input parameter
	 * 			authorities, // A value for grantGroupAuthorities's authorities input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param groupId Parameter for the grantGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the grantGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantGroupAuthorities", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group grantGroupAuthorities(String queryResponseDef, String groupId, List<AuthorityKind> authorities,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(this.mutationReactiveExecutor.grantGroupAuthorities(queryResponseDef, groupId,
			authorities, paramsAndValues));
	}

	/**
	 * Grants authorities to a group. The specified authorities are added to any existing ones.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getGrantGroupAuthoritiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Group grantGroupAuthorities = executor.grantGroupAuthoritiesWithBindValues(preparedRequest, userId, // A
	 * 																											// value
	 * 																											// for
	 * 																											// grantGroupAuthorities's
	 * 																											// userId
	 * 																											// input
	 * 																											// parameter
	 * 			authorities, // A value for grantGroupAuthorities's authorities input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGrantGroupAuthoritiesGraphQLRequest(String)} method.
	 * @param groupId Parameter for the grantGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the grantGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantGroupAuthorities", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group grantGroupAuthoritiesWithBindValues(ObjectResponse objectResponse, String groupId,
		List<AuthorityKind> authorities, Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(this.mutationReactiveExecutor
			.grantGroupAuthoritiesWithBindValues(objectResponse, groupId, authorities, parameters));
	}

	/**
	 * Grants authorities to a group. The specified authorities are added to any existing ones.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getGrantGroupAuthoritiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Group grantGroupAuthorities = executor.grantGroupAuthorities(preparedRequest, userId, // A value for
	 * 																								// grantGroupAuthorities's
	 * 																								// userId input
	 * 																								// parameter
	 * 			authorities, // A value for grantGroupAuthorities's authorities input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGrantGroupAuthoritiesGraphQLRequest(String)} method.
	 * @param groupId Parameter for the grantGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the grantGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantGroupAuthorities", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group grantGroupAuthorities(ObjectResponse objectResponse, String groupId, List<AuthorityKind> authorities,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.grantGroupAuthorities(objectResponse, groupId, authorities, paramsAndValues));
	}

	/**
	 * Grants authorities to a group. The specified authorities are added to any existing ones.<br/>
	 * Get the {@link Builder} for the Group, as expected by the grantGroupAuthorities query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getGrantGroupAuthoritiesResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getGrantGroupAuthoritiesResponseBuilder();
	}

	/**
	 * Grants authorities to a group. The specified authorities are added to any existing ones.<br/>
	 * Get the {@link GraphQLRequest} for the grantGroupAuthorities EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF= "https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getGrantGroupAuthoritiesGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "grantGroupAuthorities",
			InputParameter.newBindParameter("", "groupId", "mutationGrantGroupAuthoritiesGroupId",
				InputParameterType.MANDATORY, "ID", true, 0, false),
			InputParameter.newBindParameter("", "authorities", "mutationGrantGroupAuthoritiesAuthorities",
				InputParameterType.MANDATORY, "AuthorityKind", true, 1, true));
	}

	/**
	 * Revokes authorities from a group. The specified authorities are removed from the group; other authorities remain
	 * intact.<br/>
	 * This method executes a partial query on the revokeGroupAuthorities mutation against the GraphQL server. That is,
	 * the mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef
	 * contains the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>revokeGroupAuthorities</code> of the Mutation mutation type. It can be something like "{ id name }", or ""
	 * for a scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Group revokeGroupAuthorities = executor.revokeGroupAuthoritiesWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for revokeGroupAuthorities's userId input parameter
	 * 			authorities, // A value for revokeGroupAuthorities's authorities input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param groupId Parameter for the revokeGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the revokeGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeGroupAuthorities", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group revokeGroupAuthoritiesWithBindValues(String queryResponseDef, String groupId,
		List<AuthorityKind> authorities, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(this.mutationReactiveExecutor
			.revokeGroupAuthoritiesWithBindValues(queryResponseDef, groupId, authorities, parameters));
	}

	/**
	 * Revokes authorities from a group. The specified authorities are removed from the group; other authorities remain
	 * intact.<br/>
	 * This method executes a partial query on the revokeGroupAuthorities mutation against the GraphQL server. That is,
	 * the mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef
	 * contains the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>revokeGroupAuthorities</code> of the Mutation mutation type. It can be something like "{ id name }", or ""
	 * for a scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Group revokeGroupAuthorities = executor.revokeGroupAuthorities(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for revokeGroupAuthorities's userId input parameter
	 * 			authorities, // A value for revokeGroupAuthorities's authorities input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param groupId Parameter for the revokeGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the revokeGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeGroupAuthorities", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group revokeGroupAuthorities(String queryResponseDef, String groupId, List<AuthorityKind> authorities,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		return getValueFromMonoOptional(this.mutationReactiveExecutor.revokeGroupAuthorities(queryResponseDef, groupId,
			authorities, paramsAndValues));
	}

	/**
	 * Revokes authorities from a group. The specified authorities are removed from the group; other authorities remain
	 * intact.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getRevokeGroupAuthoritiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Group revokeGroupAuthorities = executor.revokeGroupAuthoritiesWithBindValues(preparedRequest, userId, // A
	 * 																												// value
	 * 																												// for
	 * 																												// revokeGroupAuthorities's
	 * 																												// userId
	 * 																												// input
	 * 																												// parameter
	 * 			authorities, // A value for revokeGroupAuthorities's authorities input parameter
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getRevokeGroupAuthoritiesGraphQLRequest(String)} method.
	 * @param groupId Parameter for the revokeGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the revokeGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeGroupAuthorities", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group revokeGroupAuthoritiesWithBindValues(ObjectResponse objectResponse, String groupId,
		List<AuthorityKind> authorities, Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(this.mutationReactiveExecutor
			.revokeGroupAuthoritiesWithBindValues(objectResponse, groupId, authorities, parameters));
	}

	/**
	 * Revokes authorities from a group. The specified authorities are removed from the group; other authorities remain
	 * intact.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getRevokeGroupAuthoritiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Group revokeGroupAuthorities = executor.revokeGroupAuthorities(preparedRequest, userId, // A value for
	 * 																								// revokeGroupAuthorities's
	 * 																								// userId input
	 * 																								// parameter
	 * 			authorities, // A value for revokeGroupAuthorities's authorities input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getRevokeGroupAuthoritiesGraphQLRequest(String)} method.
	 * @param groupId Parameter for the revokeGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the revokeGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeGroupAuthorities", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Group revokeGroupAuthorities(ObjectResponse objectResponse, String groupId, List<AuthorityKind> authorities,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(this.mutationReactiveExecutor.revokeGroupAuthorities(objectResponse, groupId,
			authorities, paramsAndValues));
	}

	/**
	 * Revokes authorities from a group. The specified authorities are removed from the group; other authorities remain
	 * intact.<br/>
	 * Get the {@link Builder} for the Group, as expected by the revokeGroupAuthorities query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getRevokeGroupAuthoritiesResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getRevokeGroupAuthoritiesResponseBuilder();
	}

	/**
	 * Revokes authorities from a group. The specified authorities are removed from the group; other authorities remain
	 * intact.<br/>
	 * Get the {@link GraphQLRequest} for the revokeGroupAuthorities EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF= "https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getRevokeGroupAuthoritiesGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "revokeGroupAuthorities",
			InputParameter.newBindParameter("", "groupId", "mutationRevokeGroupAuthoritiesGroupId",
				InputParameterType.MANDATORY, "ID", true, 0, false),
			InputParameter.newBindParameter("", "authorities", "mutationRevokeGroupAuthoritiesAuthorities",
				InputParameterType.MANDATORY, "AuthorityKind", true, 1, true));
	}

	/**
	 * This method executes a partial query on the __typename mutation against the GraphQL server. That is, the mutation
	 * is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains the part of
	 * the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>__typename</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		String __typename = executor.__typenameWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "__typename", graphQLTypeSimpleName = "String", javaClass = String.class)
	public String __typenameWithBindValues(String queryResponseDef, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.__typenameWithBindValues(queryResponseDef, parameters));
	}

	/**
	 * This method executes a partial query on the __typename mutation against the GraphQL server. That is, the mutation
	 * is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains the part of
	 * the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>__typename</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		String __typename = executor.__typename(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "__typename", graphQLTypeSimpleName = "String", javaClass = String.class)
	public String __typename(String queryResponseDef, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		return getValueFromMonoOptional(this.mutationReactiveExecutor.__typename(queryResponseDef, paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.get__typenameGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		String __typename = executor.__typenameWithBindValues(preparedRequest, params);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link get__typenameGraphQLRequest(String)} method.
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "__typename", graphQLTypeSimpleName = "String", javaClass = String.class)
	public String __typenameWithBindValues(ObjectResponse objectResponse, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.__typenameWithBindValues(objectResponse, parameters));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.get__typenameGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		String __typename = executor.__typename(preparedRequest, "param", paramValue, // param is optional, as it
	 * 																						// is marked by a "?" in
	 * 																						// the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link get__typenameGraphQLRequest(String)} method.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "__typename", graphQLTypeSimpleName = "String", javaClass = String.class)
	public String __typename(ObjectResponse objectResponse, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return getValueFromMonoOptional(this.mutationReactiveExecutor.__typename(objectResponse, paramsAndValues));
	}

	/**
	 * Get the {@link Builder} for the String, as expected by the __typename query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder get__typenameResponseBuilder() throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.get__typenameResponseBuilder();
	}

	/**
	 * Get the {@link GraphQLRequest} for the __typename EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest get__typenameGraphQLRequest(String partialRequest) throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "__typename");
	}

	/**
	 * Retrieves the value returned by the given Mono.
	 * @param <T>
	 * @param mono
	 * @param clazz
	 * @return
	 * @throws GraphQLRequestExecutionException A {@link GraphQLRequestExecutionException} is thrown, when a
	 * {@link GraphQLRequestExecutionUncheckedException} is thrown while processing the Mono.
	 */
	private static <T> T getValueFromMono(Mono<T> mono) throws GraphQLRequestExecutionException {
		try {
			return mono.block();
		} catch (GraphQLRequestExecutionUncheckedException e) {
			throw e.getGraphQLRequestExecutionException();
		}
	}

	/**
	 * Retrieves the value returned by the given Mono. The values are {@link Optional}, and the returned is either null
	 * or the non empty value
	 * @param <T>
	 * @param mono
	 * @param clazz
	 * @return
	 * @throws GraphQLRequestExecutionException A {@link GraphQLRequestExecutionException} is thrown, when a
	 * {@link GraphQLRequestExecutionUncheckedException} is thrown while processing the Mono.
	 */
	private static <T> T getValueFromMonoOptional(Mono<Optional<T>> mono) throws GraphQLRequestExecutionException {
		try {
			Optional<T> optional = mono.block();
			return (optional.isPresent()) ? optional.get() : null;
		} catch (GraphQLRequestExecutionUncheckedException e) {
			throw e.getGraphQLRequestExecutionException();
		}
	}

}
