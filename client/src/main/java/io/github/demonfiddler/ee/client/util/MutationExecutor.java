/*----------------------------------------------------------------------------------------------------------------------
 * Evidence Engine: A system for managing evidence on arbitrary scientific topics.
 * Comprises an SQL database, GraphQL public API, Java app server and web client.
 * Copyright Â© 2024 Adrian Price. All rights reserved.
 *
 * This file is part of Evidence Engine.
 *
 * Evidence Engine is free software: you can redistribute it and/or modify it under the terms of the
 * GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * Evidence Engine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License along with Evidence Engine.
 * If not, see <https://www.gnu.org/licenses/>. 
 *--------------------------------------------------------------------------------------------------------------------*/

package io.github.demonfiddler.ee.client.util;

import java.util.List;
import java.util.Map;
import java.util.Optional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.graphql.client.GraphQlClient;
import org.springframework.stereotype.Component;

import com.graphql_java_generator.annotation.GraphQLNonScalar;
import com.graphql_java_generator.annotation.GraphQLScalar;
import com.graphql_java_generator.annotation.RequestType;
import com.graphql_java_generator.client.GraphQLMutationExecutor;
import com.graphql_java_generator.client.GraphqlClientUtils;
import com.graphql_java_generator.client.request.InputParameter;
import com.graphql_java_generator.client.request.InputParameter.InputParameterType;
import com.graphql_java_generator.client.request.ObjectResponse;
import com.graphql_java_generator.customscalars.GraphQLScalarTypeDate;
import com.graphql_java_generator.exception.GraphQLRequestExecutionException;
import com.graphql_java_generator.exception.GraphQLRequestExecutionUncheckedException;
import com.graphql_java_generator.exception.GraphQLRequestPreparationException;
import com.graphql_java_generator.util.GraphqlUtils;

import io.github.demonfiddler.ee.client.Claim;
import io.github.demonfiddler.ee.client.ClaimInput;
import io.github.demonfiddler.ee.client.Declaration;
import io.github.demonfiddler.ee.client.DeclarationInput;
import io.github.demonfiddler.ee.client.EntityKind;
import io.github.demonfiddler.ee.client.Journal;
import io.github.demonfiddler.ee.client.JournalInput;
import io.github.demonfiddler.ee.client.LinkEntitiesInput;
import io.github.demonfiddler.ee.client.Mutation;
import io.github.demonfiddler.ee.client.PermissionKind;
import io.github.demonfiddler.ee.client.Person;
import io.github.demonfiddler.ee.client.PersonInput;
import io.github.demonfiddler.ee.client.Publication;
import io.github.demonfiddler.ee.client.PublicationInput;
import io.github.demonfiddler.ee.client.Publisher;
import io.github.demonfiddler.ee.client.PublisherInput;
import io.github.demonfiddler.ee.client.Quotation;
import io.github.demonfiddler.ee.client.QuotationInput;
import io.github.demonfiddler.ee.client.StatusKind;
import io.github.demonfiddler.ee.client.Topic;
import io.github.demonfiddler.ee.client.TopicInput;
import io.github.demonfiddler.ee.client.TopicRefInput;
import io.github.demonfiddler.ee.client.User;
import io.github.demonfiddler.ee.client.UserInput;
import reactor.core.publisher.Mono;

/**
 * Available mutations. <br/>
 * This class contains the methods that allows the execution of the queries or mutations that are defined in the
 * Mutation of the GraphQL schema.<br/>
 * These methods allows:
 * <UL>
 * <LI>Preparation of full requests</LI>
 * <LI>Execution of prepared full requests</LI>
 * <LI>Execution of direct full direct requests</LI>
 * <LI>Preparation of partial requests</LI>
 * <LI>Execution of prepared partial requests</LI>
 * <LI>Execution of direct partial requests</LI>
 * </UL>
 * You'll find all the documentation on the
 * <A HREF="https://github.com/graphql-java-generator/graphql-maven-plugin-project/wiki/client_spring">client page
 * doc</A>.
 * @author generated by graphql-java-generator
 */
@Component
public class MutationExecutor implements GraphQLMutationExecutor {

	/** Logger for this class */
	@SuppressWarnings("unused")
	private static Logger logger = LoggerFactory.getLogger(MutationExecutor.class);

	@Autowired
	@Qualifier("httpGraphQlClient")
	GraphQlClient graphQlClient;

	@Autowired
	@Qualifier("mutationReactiveExecutor")
	MutationReactiveExecutor mutationReactiveExecutor;

	GraphqlUtils graphqlUtils = GraphqlUtils.graphqlUtils; // must be set that way, to be used in the constructor

	@Autowired
	GraphqlClientUtils graphqlClientUtils;

	public MutationExecutor() {
		if (!"2.8".equals(this.graphqlUtils.getRuntimeVersion())) { //$NON-NLS-1$
			throw new RuntimeException(
				"The GraphQL runtime version doesn't match the GraphQL plugin version. The runtime's version is '" //$NON-NLS-1$
					+ this.graphqlUtils.getRuntimeVersion() + "' whereas the GraphQL plugin version is '2.8'"); //$NON-NLS-1$
		}
		CustomScalarRegistryInitializer.initCustomScalarRegistry();
		DirectiveRegistryInitializer.initDirectiveRegistry();
	}

	/**
	 * This method takes a <B>full request</B> definition, and executes it against the GraphQL server. As this class is
	 * a mutation executor, the provided request must be a mutation full request.<br/>
	 * This method offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace
	 * mode).<br/>
	 * Here is a sample on how to use it: This method takes a <B>full request</B> definition, and executes it against
	 * the GraphQL server. That is, the query contains the full string that <B><U>follows</U></B> the mutation
	 * keyword.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 *     @Autowired
	 *     MutationExecutor executor;
	 * 
	 *     void myMethod() {
	 * 	        Map<String, Object> params = new HashMap<>();
	 *          params.put("param", paramValue);   // param is optional, as it is marked by a "?" in the request
	 *          params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 *          
	 *          Mutation mutation = executor.execWithBindValues(
	 *              "mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}",
	 *              callback,
	 *              params);
	 *          FieldType field = mutation.getSampleQueryOrMutationField();
	 *
	 *          .... do something with this field's value
	 *     }
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the mutation, in the native GraphQL format (see here above).
	 * It must omit the mutation keyword, and start by the first { that follows. It may contain directives, as explained
	 * in the GraphQL specs.
	 * @param parameters The map of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}. The key is the parameter
	 * name, as declared in the request you defined (in the above sample: param is an optional parameter and skip is a
	 * mandatory one). The value is the parameter value in its Java type (for instance a {@link Date} for the
	 * {@link GraphQLScalarTypeDate}). The parameters which value is missing in this map will be ignored.
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	public Mutation execWithBindValues(String queryResponseDef, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMono(this.mutationReactiveExecutor.execWithBindValues(queryResponseDef, parameters));
	}

	/**
	 * This method takes a <B>full request</B> definition, and executes it against the GraphQL server. As this class is
	 * a mutation executor, the provided request must be a mutation full request.<br/>
	 * This method offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace
	 * mode).<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 *     @Autowired
	 *     MutationExecutor executor;
	 * 
	 *     void myMethod() {
	 *          Mutation mutation = executor.exec(
	 *              "mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}",
	 *              "param", paramValue,   // param is optional, as it is marked by a "?" in the request
	 *              "skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 *              );
	 *          FieldType field = mutation.getSampleQueryOrMutationField();
	 *
	 *          .... do something with this field's value
	 *     }
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above). It
	 * must omit the mutation keyword, and start by the first { that follows. It may contain directives, as explained in
	 * the GraphQL specs.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	public Mutation exec(String queryResponseDef, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMono(this.mutationReactiveExecutor.exec(queryResponseDef, paramsAndValues));
	}

	/**
	 * This method takes a <B>full request</B> definition, and executes it against the GraphQL server. As this class is
	 * a mutation executor, the provided request must be a mutation full request.<br/>
	 * This method offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace
	 * mode).<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 *     &#64;Autowired
	 *     MutationExecutor executor;
	 *     
	 *     GraphQLRequest preparedRequest;
	 *     
	 *     @PostConstruct
	 *     public void setup() {
	 *         // Preparation of the query, so that it is prepared once then executed several times
	 *         preparedRequest = executor
	 *             .getResponseBuilder()
	 *             .withQueryResponseDef("mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}")
	 *             .build();
	 *     }
	 * 
	 *     void myMethod() {
	 * 	        Map<String, Object> params = new HashMap<>();
	 *          params.put("param", paramValue);   // param is optional, as it is marked by a "?" in the request
	 *          params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 *          
	 *          Mutation mutation = executor.execWithBindValues(
	 *              preparedRequest,
	 *              params);
	 *          FieldType field = mutation.getSampleQueryOrMutationField();
	 *
	 *          .... do something with this field's value
	 *     }
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGraphQLRequest(String)} method or one of the <code>getXxxxGraphQLRequest(String)</code> methods.
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	public Mutation execWithBindValues(ObjectResponse objectResponse, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {
		return getValueFromMono(this.mutationReactiveExecutor.execWithBindValues(objectResponse, parameters));
	}

	/**
	 * This method takes a <B>full request</B> definition, and executes it against the GraphQL server. As this class is
	 * a mutation executor, the provided request must be a mutation full request.<br/>
	 * This method offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace
	 * mode).<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 *     &#64;Autowired
	 *     MutationExecutor executor;
	 *     
	 *     GraphQLRequest preparedRequest;
	 *     
	 *     @PostConstruct
	 *     public void setup() {
	 *         // Preparation of the query, so that it is prepared once then executed several times
	 *         preparedRequest = executor
	 *             .getResponseBuilder()
	 *             .withQueryResponseDef("mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}")
	 *             .build();
	 *     }
	 * 
	 *     void myMethod() {
	 *          Mutation mutation = executor.exec(
	 *              preparedRequest,
	 *              "param", paramValue,   // param is optional, as it is marked by a "?" in the request
	 *              "skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 *              );
	 *          FieldType field = mutation.getSampleQueryOrMutationField();
	 *
	 *          .... do something with this field's value
	 *     }
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGraphQLRequest(String)} method or one of the <code>getXxxxGraphQLRequest(String)</code>
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	public Mutation exec(ObjectResponse objectResponse, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMono(this.mutationReactiveExecutor.exec(objectResponse, paramsAndValues));
	}

	/**
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for a <B>full request</B>, as expected by the
	 * exec and execWithBindValues methods.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getResponseBuilder();
	}

	/**
	 * Get the {@link GraphQLRequest} for <B>full request</B>. For instance:
	 * 
	 * <PRE>
	 * GraphQLRequest request = new GraphQLRequest(fullRequest);
	 * </PRE>
	 * 
	 * @param fullRequest The full GraphQL Request, as specified in the GraphQL specification
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getGraphQLRequest(String fullRequest) throws GraphQLRequestPreparationException {
		return new GraphQLRequest(fullRequest);
	}

	/**
	 * Creates a new claim.<br/>
	 * This method executes a partial query on the createClaim mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createClaim</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Claim createClaim = executor.createClaimWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claim, // A value for createClaim's claim input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param claim Parameter for the createClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Claim createClaimWithBindValues(String queryResponseDef, ClaimInput claim, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createClaimWithBindValues(queryResponseDef, claim, parameters));
	}

	/**
	 * Creates a new claim.<br/>
	 * This method executes a partial query on the createClaim mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createClaim</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Claim createClaim = executor.createClaim(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claim, // A value for createClaim's claim input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param claim Parameter for the createClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Claim createClaim(String queryResponseDef, ClaimInput claim, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createClaim(queryResponseDef, claim, paramsAndValues));
	}

	/**
	 * Creates a new claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Claim createClaim = executor.createClaimWithBindValues(preparedRequest, claim, // A value for
	 * 																						// createClaim's claim
	 * 																						// input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateClaimGraphQLRequest(String)} method.
	 * @param claim Parameter for the createClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Claim createClaimWithBindValues(ObjectResponse objectResponse, ClaimInput claim,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createClaimWithBindValues(objectResponse, claim, parameters));
	}

	/**
	 * Creates a new claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Claim createClaim = executor.createClaim(preparedRequest, claim, // A value for createClaim's claim input
	 * 																			// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateClaimGraphQLRequest(String)} method.
	 * @param claim Parameter for the createClaim field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Claim createClaim(ObjectResponse objectResponse, ClaimInput claim, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createClaim(objectResponse, claim, paramsAndValues));
	}

	/**
	 * Creates a new claim.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Claim, as expected by the createClaim
	 * query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getCreateClaimResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getCreateClaimResponseBuilder();
	}

	/**
	 * Creates a new claim.<br/>
	 * Get the {@link GraphQLRequest} for the createClaim EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getCreateClaimGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createClaim" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "claim", "mutationCreateClaimClaim", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"ClaimInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing claim.<br/>
	 * This method executes a partial query on the updateClaim mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateClaim</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Claim updateClaim = executor.updateClaimWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claim, // A value for updateClaim's claim input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param claim Parameter for the updateClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Claim updateClaimWithBindValues(String queryResponseDef, ClaimInput claim, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateClaimWithBindValues(queryResponseDef, claim, parameters));
	}

	/**
	 * Updates an existing claim.<br/>
	 * This method executes a partial query on the updateClaim mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateClaim</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Claim updateClaim = executor.updateClaim(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claim, // A value for updateClaim's claim input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param claim Parameter for the updateClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Claim updateClaim(String queryResponseDef, ClaimInput claim, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateClaim(queryResponseDef, claim, paramsAndValues));
	}

	/**
	 * Updates an existing claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Claim updateClaim = executor.updateClaimWithBindValues(preparedRequest, claim, // A value for
	 * 																						// updateClaim's claim
	 * 																						// input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateClaimGraphQLRequest(String)} method.
	 * @param claim Parameter for the updateClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Claim updateClaimWithBindValues(ObjectResponse objectResponse, ClaimInput claim,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateClaimWithBindValues(objectResponse, claim, parameters));
	}

	/**
	 * Updates an existing claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Claim updateClaim = executor.updateClaim(preparedRequest, claim, // A value for updateClaim's claim input
	 * 																			// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateClaimGraphQLRequest(String)} method.
	 * @param claim Parameter for the updateClaim field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Claim updateClaim(ObjectResponse objectResponse, ClaimInput claim, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateClaim(objectResponse, claim, paramsAndValues));
	}

	/**
	 * Updates an existing claim.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Claim, as expected by the updateClaim
	 * query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getUpdateClaimResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdateClaimResponseBuilder();
	}

	/**
	 * Updates an existing claim.<br/>
	 * Get the {@link GraphQLRequest} for the updateClaim EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdateClaimGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateClaim" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "claim", "mutationUpdateClaimClaim", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"ClaimInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing claim.<br/>
	 * This method executes a partial query on the deleteClaim mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteClaim</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Claim deleteClaim = executor.deleteClaimWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claimId, // A value for deleteClaim's claimId input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param claimId Parameter for the deleteClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Claim deleteClaimWithBindValues(String queryResponseDef, Long claimId, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteClaimWithBindValues(queryResponseDef, claimId, parameters));
	}

	/**
	 * Deletes an existing claim.<br/>
	 * This method executes a partial query on the deleteClaim mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteClaim</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Claim deleteClaim = executor.deleteClaim(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claimId, // A value for deleteClaim's claimId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param claimId Parameter for the deleteClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Claim deleteClaim(String queryResponseDef, Long claimId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteClaim(queryResponseDef, claimId, paramsAndValues));
	}

	/**
	 * Deletes an existing claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Claim deleteClaim = executor.deleteClaimWithBindValues(preparedRequest, claimId, // A value for
	 * 																							// deleteClaim's
	 * 																							// claimId input
	 * 																							// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteClaimGraphQLRequest(String)} method.
	 * @param claimId Parameter for the deleteClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Claim deleteClaimWithBindValues(ObjectResponse objectResponse, Long claimId, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteClaimWithBindValues(objectResponse, claimId, parameters));
	}

	/**
	 * Deletes an existing claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Claim deleteClaim = executor.deleteClaim(preparedRequest, claimId, // A value for deleteClaim's claimId
	 * 																			// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteClaimGraphQLRequest(String)} method.
	 * @param claimId Parameter for the deleteClaim field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Claim deleteClaim(ObjectResponse objectResponse, Long claimId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteClaim(objectResponse, claimId, paramsAndValues));
	}

	/**
	 * Deletes an existing claim.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Claim, as expected by the deleteClaim
	 * query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getDeleteClaimResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getDeleteClaimResponseBuilder();
	}

	/**
	 * Deletes an existing claim.<br/>
	 * Get the {@link GraphQLRequest} for the deleteClaim EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDeleteClaimGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteClaim" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "claimId", "mutationDeleteClaimClaimId", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new declaration.<br/>
	 * This method executes a partial query on the createDeclaration mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createDeclaration</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Declaration createDeclaration = executor.createDeclarationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declaration, // A value for createDeclaration's declaration input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param declaration Parameter for the createDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Declaration createDeclarationWithBindValues(String queryResponseDef, DeclarationInput declaration,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createDeclarationWithBindValues(queryResponseDef, declaration, parameters));
	}

	/**
	 * Creates a new declaration.<br/>
	 * This method executes a partial query on the createDeclaration mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createDeclaration</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Declaration createDeclaration = executor.createDeclaration(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declaration, // A value for createDeclaration's declaration input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param declaration Parameter for the createDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Declaration createDeclaration(String queryResponseDef, DeclarationInput declaration,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createDeclaration(queryResponseDef, declaration, paramsAndValues));
	}

	/**
	 * Creates a new declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Declaration createDeclaration = executor.createDeclarationWithBindValues(preparedRequest, declaration, // A
	 * 																												// value
	 * 																												// for
	 * 																												// createDeclaration's
	 * 																												// declaration
	 * 																												// input
	 * 																												// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateDeclarationGraphQLRequest(String)} method.
	 * @param declaration Parameter for the createDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Declaration createDeclarationWithBindValues(ObjectResponse objectResponse, DeclarationInput declaration,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createDeclarationWithBindValues(objectResponse, declaration, parameters));
	}

	/**
	 * Creates a new declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Declaration createDeclaration = executor.createDeclaration(preparedRequest, declaration, // A value for
	 * 																									// createDeclaration's
	 * 																									// declaration
	 * 																									// input
	 * 																									// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateDeclarationGraphQLRequest(String)} method.
	 * @param declaration Parameter for the createDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Declaration createDeclaration(ObjectResponse objectResponse, DeclarationInput declaration,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createDeclaration(objectResponse, declaration, paramsAndValues));
	}

	/**
	 * Creates a new declaration.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Declaration, as expected by the
	 * createDeclaration query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getCreateDeclarationResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getCreateDeclarationResponseBuilder();
	}

	/**
	 * Creates a new declaration.<br/>
	 * Get the {@link GraphQLRequest} for the createDeclaration EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getCreateDeclarationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createDeclaration" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "declaration", "mutationCreateDeclarationDeclaration", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "DeclarationInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing declaration.<br/>
	 * This method executes a partial query on the updateDeclaration mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateDeclaration</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Declaration updateDeclaration = executor.updateDeclarationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declaration, // A value for updateDeclaration's declaration input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param declaration Parameter for the updateDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Declaration updateDeclarationWithBindValues(String queryResponseDef, DeclarationInput declaration,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateDeclarationWithBindValues(queryResponseDef, declaration, parameters));
	}

	/**
	 * Updates an existing declaration.<br/>
	 * This method executes a partial query on the updateDeclaration mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateDeclaration</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Declaration updateDeclaration = executor.updateDeclaration(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declaration, // A value for updateDeclaration's declaration input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param declaration Parameter for the updateDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Declaration updateDeclaration(String queryResponseDef, DeclarationInput declaration,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateDeclaration(queryResponseDef, declaration, paramsAndValues));
	}

	/**
	 * Updates an existing declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Declaration updateDeclaration = executor.updateDeclarationWithBindValues(preparedRequest, declaration, // A
	 * 																												// value
	 * 																												// for
	 * 																												// updateDeclaration's
	 * 																												// declaration
	 * 																												// input
	 * 																												// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateDeclarationGraphQLRequest(String)} method.
	 * @param declaration Parameter for the updateDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Declaration updateDeclarationWithBindValues(ObjectResponse objectResponse, DeclarationInput declaration,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateDeclarationWithBindValues(objectResponse, declaration, parameters));
	}

	/**
	 * Updates an existing declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Declaration updateDeclaration = executor.updateDeclaration(preparedRequest, declaration, // A value for
	 * 																									// updateDeclaration's
	 * 																									// declaration
	 * 																									// input
	 * 																									// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateDeclarationGraphQLRequest(String)} method.
	 * @param declaration Parameter for the updateDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Declaration updateDeclaration(ObjectResponse objectResponse, DeclarationInput declaration,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateDeclaration(objectResponse, declaration, paramsAndValues));
	}

	/**
	 * Updates an existing declaration.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Declaration, as expected by the
	 * updateDeclaration query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getUpdateDeclarationResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdateDeclarationResponseBuilder();
	}

	/**
	 * Updates an existing declaration.<br/>
	 * Get the {@link GraphQLRequest} for the updateDeclaration EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdateDeclarationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateDeclaration" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "declaration", "mutationUpdateDeclarationDeclaration", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "DeclarationInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * This method executes a partial query on the deleteDeclaration mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteDeclaration</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Declaration deleteDeclaration = executor.deleteDeclarationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declarationId, // A value for deleteDeclaration's declarationId input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param declarationId Parameter for the deleteDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Declaration deleteDeclarationWithBindValues(String queryResponseDef, Long declarationId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteDeclarationWithBindValues(queryResponseDef, declarationId, parameters));
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * This method executes a partial query on the deleteDeclaration mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteDeclaration</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Declaration deleteDeclaration = executor.deleteDeclaration(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declarationId, // A value for deleteDeclaration's declarationId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param declarationId Parameter for the deleteDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Declaration deleteDeclaration(String queryResponseDef, Long declarationId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteDeclaration(queryResponseDef, declarationId, paramsAndValues));
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Declaration deleteDeclaration = executor.deleteDeclarationWithBindValues(preparedRequest, declarationId, // A
	 * 																													// value
	 * 																													// for
	 * 																													// deleteDeclaration's
	 * 																													// declarationId
	 * 																													// input
	 * 																													// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteDeclarationGraphQLRequest(String)} method.
	 * @param declarationId Parameter for the deleteDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Declaration deleteDeclarationWithBindValues(ObjectResponse objectResponse, Long declarationId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteDeclarationWithBindValues(objectResponse, declarationId, parameters));
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Declaration deleteDeclaration = executor.deleteDeclaration(preparedRequest, declarationId, // A value for
	 * 																									// deleteDeclaration's
	 * 																									// declarationId
	 * 																									// input
	 * 																									// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteDeclarationGraphQLRequest(String)} method.
	 * @param declarationId Parameter for the deleteDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Declaration deleteDeclaration(ObjectResponse objectResponse, Long declarationId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteDeclaration(objectResponse, declarationId, paramsAndValues));
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Declaration, as expected by the
	 * deleteDeclaration query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getDeleteDeclarationResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getDeleteDeclarationResponseBuilder();
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * Get the {@link GraphQLRequest} for the deleteDeclaration EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDeleteDeclarationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteDeclaration" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "declarationId", "mutationDeleteDeclarationDeclarationId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Create a new journal.<br/>
	 * This method executes a partial query on the createJournal mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createJournal</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Journal createJournal = executor.createJournalWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journal, // A value for createJournal's journal input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param journal Parameter for the createJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Journal createJournalWithBindValues(String queryResponseDef, JournalInput journal,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createJournalWithBindValues(queryResponseDef, journal, parameters));
	}

	/**
	 * Create a new journal.<br/>
	 * This method executes a partial query on the createJournal mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createJournal</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Journal createJournal = executor.createJournal(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journal, // A value for createJournal's journal input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param journal Parameter for the createJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Journal createJournal(String queryResponseDef, JournalInput journal, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createJournal(queryResponseDef, journal, paramsAndValues));
	}

	/**
	 * Create a new journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Journal createJournal = executor.createJournalWithBindValues(preparedRequest, journal, // A value for
	 * 																								// createJournal's
	 * 																								// journal input
	 * 																								// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateJournalGraphQLRequest(String)} method.
	 * @param journal Parameter for the createJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Journal createJournalWithBindValues(ObjectResponse objectResponse, JournalInput journal,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createJournalWithBindValues(objectResponse, journal, parameters));
	}

	/**
	 * Create a new journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Journal createJournal = executor.createJournal(preparedRequest, journal, // A value for createJournal's
	 * 																					// journal input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateJournalGraphQLRequest(String)} method.
	 * @param journal Parameter for the createJournal field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Journal createJournal(ObjectResponse objectResponse, JournalInput journal, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createJournal(objectResponse, journal, paramsAndValues));
	}

	/**
	 * Create a new journal.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Journal, as expected by the
	 * createJournal query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getCreateJournalResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getCreateJournalResponseBuilder();
	}

	/**
	 * Create a new journal.<br/>
	 * Get the {@link GraphQLRequest} for the createJournal EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getCreateJournalGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createJournal" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "journal", "mutationCreateJournalJournal", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "JournalInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing journal.<br/>
	 * This method executes a partial query on the updateJournal mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateJournal</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Journal updateJournal = executor.updateJournalWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journal, // A value for updateJournal's journal input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param journal Parameter for the updateJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Journal updateJournalWithBindValues(String queryResponseDef, JournalInput journal,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateJournalWithBindValues(queryResponseDef, journal, parameters));
	}

	/**
	 * Updates an existing journal.<br/>
	 * This method executes a partial query on the updateJournal mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateJournal</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Journal updateJournal = executor.updateJournal(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journal, // A value for updateJournal's journal input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param journal Parameter for the updateJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Journal updateJournal(String queryResponseDef, JournalInput journal, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateJournal(queryResponseDef, journal, paramsAndValues));
	}

	/**
	 * Updates an existing journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Journal updateJournal = executor.updateJournalWithBindValues(preparedRequest, journal, // A value for
	 * 																								// updateJournal's
	 * 																								// journal input
	 * 																								// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateJournalGraphQLRequest(String)} method.
	 * @param journal Parameter for the updateJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Journal updateJournalWithBindValues(ObjectResponse objectResponse, JournalInput journal,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateJournalWithBindValues(objectResponse, journal, parameters));
	}

	/**
	 * Updates an existing journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Journal updateJournal = executor.updateJournal(preparedRequest, journal, // A value for updateJournal's
	 * 																					// journal input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateJournalGraphQLRequest(String)} method.
	 * @param journal Parameter for the updateJournal field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Journal updateJournal(ObjectResponse objectResponse, JournalInput journal, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateJournal(objectResponse, journal, paramsAndValues));
	}

	/**
	 * Updates an existing journal.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Journal, as expected by the
	 * updateJournal query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getUpdateJournalResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdateJournalResponseBuilder();
	}

	/**
	 * Updates an existing journal.<br/>
	 * Get the {@link GraphQLRequest} for the updateJournal EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdateJournalGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateJournal" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "journal", "mutationUpdateJournalJournal", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "JournalInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing journal.<br/>
	 * This method executes a partial query on the deleteJournal mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteJournal</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Journal deleteJournal = executor.deleteJournalWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journalId, // A value for deleteJournal's journalId input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param journalId Parameter for the deleteJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Journal deleteJournalWithBindValues(String queryResponseDef, Long journalId, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteJournalWithBindValues(queryResponseDef, journalId, parameters));
	}

	/**
	 * Deletes an existing journal.<br/>
	 * This method executes a partial query on the deleteJournal mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteJournal</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Journal deleteJournal = executor.deleteJournal(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journalId, // A value for deleteJournal's journalId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param journalId Parameter for the deleteJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Journal deleteJournal(String queryResponseDef, Long journalId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteJournal(queryResponseDef, journalId, paramsAndValues));
	}

	/**
	 * Deletes an existing journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Journal deleteJournal = executor.deleteJournalWithBindValues(preparedRequest, journalId, // A value for
	 * 																									// deleteJournal's
	 * 																									// journalId
	 * 																									// input
	 * 																									// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteJournalGraphQLRequest(String)} method.
	 * @param journalId Parameter for the deleteJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Journal deleteJournalWithBindValues(ObjectResponse objectResponse, Long journalId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteJournalWithBindValues(objectResponse, journalId, parameters));
	}

	/**
	 * Deletes an existing journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Journal deleteJournal = executor.deleteJournal(preparedRequest, journalId, // A value for deleteJournal's
	 * 																					// journalId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteJournalGraphQLRequest(String)} method.
	 * @param journalId Parameter for the deleteJournal field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Journal deleteJournal(ObjectResponse objectResponse, Long journalId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteJournal(objectResponse, journalId, paramsAndValues));
	}

	/**
	 * Deletes an existing journal.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Journal, as expected by the
	 * deleteJournal query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getDeleteJournalResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getDeleteJournalResponseBuilder();
	}

	/**
	 * Deletes an existing journal.<br/>
	 * Get the {@link GraphQLRequest} for the deleteJournal EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDeleteJournalGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteJournal" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "journalId", "mutationDeleteJournalJournalId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new person.<br/>
	 * This method executes a partial query on the createPerson mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createPerson</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Person createPerson = executor.createPersonWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			person, // A value for createPerson's person input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param person Parameter for the createPerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Person createPersonWithBindValues(String queryResponseDef, PersonInput person,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPersonWithBindValues(queryResponseDef, person, parameters));
	}

	/**
	 * Creates a new person.<br/>
	 * This method executes a partial query on the createPerson mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createPerson</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Person createPerson = executor.createPerson(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			person, // A value for createPerson's person input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param person Parameter for the createPerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Person createPerson(String queryResponseDef, PersonInput person, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPerson(queryResponseDef, person, paramsAndValues));
	}

	/**
	 * Creates a new person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Person createPerson = executor.createPersonWithBindValues(preparedRequest, person, // A value for
	 * 																							// createPerson's
	 * 																							// person input
	 * 																							// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePersonGraphQLRequest(String)} method.
	 * @param person Parameter for the createPerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Person createPersonWithBindValues(ObjectResponse objectResponse, PersonInput person,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPersonWithBindValues(objectResponse, person, parameters));
	}

	/**
	 * Creates a new person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Person createPerson = executor.createPerson(preparedRequest, person, // A value for createPerson's person
	 * 																				// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePersonGraphQLRequest(String)} method.
	 * @param person Parameter for the createPerson field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Person createPerson(ObjectResponse objectResponse, PersonInput person, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPerson(objectResponse, person, paramsAndValues));
	}

	/**
	 * Creates a new person.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Person, as expected by the createPerson
	 * query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getCreatePersonResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getCreatePersonResponseBuilder();
	}

	/**
	 * Creates a new person.<br/>
	 * Get the {@link GraphQLRequest} for the createPerson EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getCreatePersonGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createPerson" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "person", "mutationCreatePersonPerson", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PersonInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing person.<br/>
	 * This method executes a partial query on the updatePerson mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updatePerson</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Person updatePerson = executor.updatePersonWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			person, // A value for updatePerson's person input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param person Parameter for the updatePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Person updatePersonWithBindValues(String queryResponseDef, PersonInput person,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePersonWithBindValues(queryResponseDef, person, parameters));
	}

	/**
	 * Updates an existing person.<br/>
	 * This method executes a partial query on the updatePerson mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updatePerson</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Person updatePerson = executor.updatePerson(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			person, // A value for updatePerson's person input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param person Parameter for the updatePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Person updatePerson(String queryResponseDef, PersonInput person, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePerson(queryResponseDef, person, paramsAndValues));
	}

	/**
	 * Updates an existing person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Person updatePerson = executor.updatePersonWithBindValues(preparedRequest, person, // A value for
	 * 																							// updatePerson's
	 * 																							// person input
	 * 																							// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePersonGraphQLRequest(String)} method.
	 * @param person Parameter for the updatePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Person updatePersonWithBindValues(ObjectResponse objectResponse, PersonInput person,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePersonWithBindValues(objectResponse, person, parameters));
	}

	/**
	 * Updates an existing person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Person updatePerson = executor.updatePerson(preparedRequest, person, // A value for updatePerson's person
	 * 																				// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePersonGraphQLRequest(String)} method.
	 * @param person Parameter for the updatePerson field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Person updatePerson(ObjectResponse objectResponse, PersonInput person, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePerson(objectResponse, person, paramsAndValues));
	}

	/**
	 * Updates an existing person.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Person, as expected by the updatePerson
	 * query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getUpdatePersonResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdatePersonResponseBuilder();
	}

	/**
	 * Updates an existing person.<br/>
	 * Get the {@link GraphQLRequest} for the updatePerson EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdatePersonGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updatePerson" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "person", "mutationUpdatePersonPerson", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PersonInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing person.<br/>
	 * This method executes a partial query on the deletePerson mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deletePerson</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Person deletePerson = executor.deletePersonWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			personId, // A value for deletePerson's personId input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param personId Parameter for the deletePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Person deletePersonWithBindValues(String queryResponseDef, Long personId, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePersonWithBindValues(queryResponseDef, personId, parameters));
	}

	/**
	 * Deletes an existing person.<br/>
	 * This method executes a partial query on the deletePerson mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deletePerson</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Person deletePerson = executor.deletePerson(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			personId, // A value for deletePerson's personId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param personId Parameter for the deletePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Person deletePerson(String queryResponseDef, Long personId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePerson(queryResponseDef, personId, paramsAndValues));
	}

	/**
	 * Deletes an existing person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Person deletePerson = executor.deletePersonWithBindValues(preparedRequest, personId, // A value for
	 * 																								// deletePerson's
	 * 																								// personId input
	 * 																								// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePersonGraphQLRequest(String)} method.
	 * @param personId Parameter for the deletePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Person deletePersonWithBindValues(ObjectResponse objectResponse, Long personId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePersonWithBindValues(objectResponse, personId, parameters));
	}

	/**
	 * Deletes an existing person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Person deletePerson = executor.deletePerson(preparedRequest, personId, // A value for deletePerson's
	 * 																				// personId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePersonGraphQLRequest(String)} method.
	 * @param personId Parameter for the deletePerson field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Person deletePerson(ObjectResponse objectResponse, Long personId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePerson(objectResponse, personId, paramsAndValues));
	}

	/**
	 * Deletes an existing person.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Person, as expected by the deletePerson
	 * query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getDeletePersonResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getDeletePersonResponseBuilder();
	}

	/**
	 * Deletes an existing person.<br/>
	 * Get the {@link GraphQLRequest} for the deletePerson EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDeletePersonGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deletePerson" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "personId", "mutationDeletePersonPersonId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new publication.<br/>
	 * This method executes a partial query on the createPublication mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createPublication</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Publication createPublication = executor.createPublicationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publication, // A value for createPublication's publication input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publication Parameter for the createPublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Publication createPublicationWithBindValues(String queryResponseDef, PublicationInput publication,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPublicationWithBindValues(queryResponseDef, publication, parameters));
	}

	/**
	 * Creates a new publication.<br/>
	 * This method executes a partial query on the createPublication mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createPublication</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Publication createPublication = executor.createPublication(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publication, // A value for createPublication's publication input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publication Parameter for the createPublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Publication createPublication(String queryResponseDef, PublicationInput publication,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPublication(queryResponseDef, publication, paramsAndValues));
	}

	/**
	 * Creates a new publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publication createPublication = executor.createPublicationWithBindValues(preparedRequest, publication, // A
	 * 																												// value
	 * 																												// for
	 * 																												// createPublication's
	 * 																												// publication
	 * 																												// input
	 * 																												// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePublicationGraphQLRequest(String)} method.
	 * @param publication Parameter for the createPublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Publication createPublicationWithBindValues(ObjectResponse objectResponse, PublicationInput publication,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPublicationWithBindValues(objectResponse, publication, parameters));
	}

	/**
	 * Creates a new publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publication createPublication = executor.createPublication(preparedRequest, publication, // A value for
	 * 																									// createPublication's
	 * 																									// publication
	 * 																									// input
	 * 																									// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePublicationGraphQLRequest(String)} method.
	 * @param publication Parameter for the createPublication field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Publication createPublication(ObjectResponse objectResponse, PublicationInput publication,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPublication(objectResponse, publication, paramsAndValues));
	}

	/**
	 * Creates a new publication.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Publication, as expected by the
	 * createPublication query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getCreatePublicationResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getCreatePublicationResponseBuilder();
	}

	/**
	 * Creates a new publication.<br/>
	 * Get the {@link GraphQLRequest} for the createPublication EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getCreatePublicationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createPublication" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "publication", "mutationCreatePublicationPublication", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "PublicationInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing publication.<br/>
	 * This method executes a partial query on the updatePublication mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updatePublication</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Publication updatePublication = executor.updatePublicationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publication, // A value for updatePublication's publication input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publication Parameter for the updatePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Publication updatePublicationWithBindValues(String queryResponseDef, PublicationInput publication,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePublicationWithBindValues(queryResponseDef, publication, parameters));
	}

	/**
	 * Updates an existing publication.<br/>
	 * This method executes a partial query on the updatePublication mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updatePublication</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Publication updatePublication = executor.updatePublication(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publication, // A value for updatePublication's publication input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publication Parameter for the updatePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Publication updatePublication(String queryResponseDef, PublicationInput publication,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePublication(queryResponseDef, publication, paramsAndValues));
	}

	/**
	 * Updates an existing publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publication updatePublication = executor.updatePublicationWithBindValues(preparedRequest, publication, // A
	 * 																												// value
	 * 																												// for
	 * 																												// updatePublication's
	 * 																												// publication
	 * 																												// input
	 * 																												// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePublicationGraphQLRequest(String)} method.
	 * @param publication Parameter for the updatePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Publication updatePublicationWithBindValues(ObjectResponse objectResponse, PublicationInput publication,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePublicationWithBindValues(objectResponse, publication, parameters));
	}

	/**
	 * Updates an existing publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publication updatePublication = executor.updatePublication(preparedRequest, publication, // A value for
	 * 																									// updatePublication's
	 * 																									// publication
	 * 																									// input
	 * 																									// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePublicationGraphQLRequest(String)} method.
	 * @param publication Parameter for the updatePublication field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Publication updatePublication(ObjectResponse objectResponse, PublicationInput publication,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePublication(objectResponse, publication, paramsAndValues));
	}

	/**
	 * Updates an existing publication.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Publication, as expected by the
	 * updatePublication query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getUpdatePublicationResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdatePublicationResponseBuilder();
	}

	/**
	 * Updates an existing publication.<br/>
	 * Get the {@link GraphQLRequest} for the updatePublication EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdatePublicationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updatePublication" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "publication", "mutationUpdatePublicationPublication", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "PublicationInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing publication.<br/>
	 * This method executes a partial query on the deletePublication mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deletePublication</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Publication deletePublication = executor.deletePublicationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publicationId, // A value for deletePublication's publicationId input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publicationId Parameter for the deletePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Publication deletePublicationWithBindValues(String queryResponseDef, Long publicationId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePublicationWithBindValues(queryResponseDef, publicationId, parameters));
	}

	/**
	 * Deletes an existing publication.<br/>
	 * This method executes a partial query on the deletePublication mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deletePublication</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Publication deletePublication = executor.deletePublication(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publicationId, // A value for deletePublication's publicationId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publicationId Parameter for the deletePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Publication deletePublication(String queryResponseDef, Long publicationId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePublication(queryResponseDef, publicationId, paramsAndValues));
	}

	/**
	 * Deletes an existing publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publication deletePublication = executor.deletePublicationWithBindValues(preparedRequest, publicationId, // A
	 * 																													// value
	 * 																													// for
	 * 																													// deletePublication's
	 * 																													// publicationId
	 * 																													// input
	 * 																													// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePublicationGraphQLRequest(String)} method.
	 * @param publicationId Parameter for the deletePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Publication deletePublicationWithBindValues(ObjectResponse objectResponse, Long publicationId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePublicationWithBindValues(objectResponse, publicationId, parameters));
	}

	/**
	 * Deletes an existing publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publication deletePublication = executor.deletePublication(preparedRequest, publicationId, // A value for
	 * 																									// deletePublication's
	 * 																									// publicationId
	 * 																									// input
	 * 																									// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePublicationGraphQLRequest(String)} method.
	 * @param publicationId Parameter for the deletePublication field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Publication deletePublication(ObjectResponse objectResponse, Long publicationId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePublication(objectResponse, publicationId, paramsAndValues));
	}

	/**
	 * Deletes an existing publication.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Publication, as expected by the
	 * deletePublication query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getDeletePublicationResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getDeletePublicationResponseBuilder();
	}

	/**
	 * Deletes an existing publication.<br/>
	 * Get the {@link GraphQLRequest} for the deletePublication EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDeletePublicationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deletePublication" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "publicationId", "mutationDeletePublicationPublicationId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new publisher.<br/>
	 * This method executes a partial query on the createPublisher mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createPublisher</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Publisher createPublisher = executor.createPublisherWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisher, // A value for createPublisher's publisher input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publisher Parameter for the createPublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Publisher createPublisherWithBindValues(String queryResponseDef, PublisherInput publisher,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPublisherWithBindValues(queryResponseDef, publisher, parameters));
	}

	/**
	 * Creates a new publisher.<br/>
	 * This method executes a partial query on the createPublisher mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createPublisher</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Publisher createPublisher = executor.createPublisher(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisher, // A value for createPublisher's publisher input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publisher Parameter for the createPublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Publisher createPublisher(String queryResponseDef, PublisherInput publisher, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPublisher(queryResponseDef, publisher, paramsAndValues));
	}

	/**
	 * Creates a new publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publisher createPublisher = executor.createPublisherWithBindValues(preparedRequest, publisher, // A value
	 * 																										// for
	 * 																										// createPublisher's
	 * 																										// publisher
	 * 																										// input
	 * 																										// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePublisherGraphQLRequest(String)} method.
	 * @param publisher Parameter for the createPublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Publisher createPublisherWithBindValues(ObjectResponse objectResponse, PublisherInput publisher,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPublisherWithBindValues(objectResponse, publisher, parameters));
	}

	/**
	 * Creates a new publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publisher createPublisher = executor.createPublisher(preparedRequest, publisher, // A value for
	 * 																							// createPublisher's
	 * 																							// publisher input
	 * 																							// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePublisherGraphQLRequest(String)} method.
	 * @param publisher Parameter for the createPublisher field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Publisher createPublisher(ObjectResponse objectResponse, PublisherInput publisher, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createPublisher(objectResponse, publisher, paramsAndValues));
	}

	/**
	 * Creates a new publisher.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Publisher, as expected by the
	 * createPublisher query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getCreatePublisherResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getCreatePublisherResponseBuilder();
	}

	/**
	 * Creates a new publisher.<br/>
	 * Get the {@link GraphQLRequest} for the createPublisher EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getCreatePublisherGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createPublisher" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "publisher", "mutationCreatePublisherPublisher", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "PublisherInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing publisher.<br/>
	 * This method executes a partial query on the updatePublisher mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updatePublisher</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Publisher updatePublisher = executor.updatePublisherWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisher, // A value for updatePublisher's publisher input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publisher Parameter for the updatePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Publisher updatePublisherWithBindValues(String queryResponseDef, PublisherInput publisher,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePublisherWithBindValues(queryResponseDef, publisher, parameters));
	}

	/**
	 * Updates an existing publisher.<br/>
	 * This method executes a partial query on the updatePublisher mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updatePublisher</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Publisher updatePublisher = executor.updatePublisher(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisher, // A value for updatePublisher's publisher input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publisher Parameter for the updatePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Publisher updatePublisher(String queryResponseDef, PublisherInput publisher, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePublisher(queryResponseDef, publisher, paramsAndValues));
	}

	/**
	 * Updates an existing publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publisher updatePublisher = executor.updatePublisherWithBindValues(preparedRequest, publisher, // A value
	 * 																										// for
	 * 																										// updatePublisher's
	 * 																										// publisher
	 * 																										// input
	 * 																										// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePublisherGraphQLRequest(String)} method.
	 * @param publisher Parameter for the updatePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Publisher updatePublisherWithBindValues(ObjectResponse objectResponse, PublisherInput publisher,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePublisherWithBindValues(objectResponse, publisher, parameters));
	}

	/**
	 * Updates an existing publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publisher updatePublisher = executor.updatePublisher(preparedRequest, publisher, // A value for
	 * 																							// updatePublisher's
	 * 																							// publisher input
	 * 																							// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePublisherGraphQLRequest(String)} method.
	 * @param publisher Parameter for the updatePublisher field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Publisher updatePublisher(ObjectResponse objectResponse, PublisherInput publisher, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updatePublisher(objectResponse, publisher, paramsAndValues));
	}

	/**
	 * Updates an existing publisher.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Publisher, as expected by the
	 * updatePublisher query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getUpdatePublisherResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdatePublisherResponseBuilder();
	}

	/**
	 * Updates an existing publisher.<br/>
	 * Get the {@link GraphQLRequest} for the updatePublisher EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdatePublisherGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updatePublisher" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "publisher", "mutationUpdatePublisherPublisher", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "PublisherInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * This method executes a partial query on the deletePublisher mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deletePublisher</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Publisher deletePublisher = executor.deletePublisherWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisherId, // A value for deletePublisher's publisherId input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publisherId Parameter for the deletePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Publisher deletePublisherWithBindValues(String queryResponseDef, Long publisherId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePublisherWithBindValues(queryResponseDef, publisherId, parameters));
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * This method executes a partial query on the deletePublisher mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deletePublisher</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Publisher deletePublisher = executor.deletePublisher(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisherId, // A value for deletePublisher's publisherId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publisherId Parameter for the deletePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Publisher deletePublisher(String queryResponseDef, Long publisherId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePublisher(queryResponseDef, publisherId, paramsAndValues));
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publisher deletePublisher = executor.deletePublisherWithBindValues(preparedRequest, publisherId, // A
	 * 																											// value
	 * 																											// for
	 * 																											// deletePublisher's
	 * 																											// publisherId
	 * 																											// input
	 * 																											// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePublisherGraphQLRequest(String)} method.
	 * @param publisherId Parameter for the deletePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Publisher deletePublisherWithBindValues(ObjectResponse objectResponse, Long publisherId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePublisherWithBindValues(objectResponse, publisherId, parameters));
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Publisher deletePublisher = executor.deletePublisher(preparedRequest, publisherId, // A value for
	 * 																							// deletePublisher's
	 * 																							// publisherId input
	 * 																							// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePublisherGraphQLRequest(String)} method.
	 * @param publisherId Parameter for the deletePublisher field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Publisher deletePublisher(ObjectResponse objectResponse, Long publisherId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deletePublisher(objectResponse, publisherId, paramsAndValues));
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Publisher, as expected by the
	 * deletePublisher query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getDeletePublisherResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getDeletePublisherResponseBuilder();
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * Get the {@link GraphQLRequest} for the deletePublisher EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDeletePublisherGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deletePublisher" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "publisherId", "mutationDeletePublisherPublisherId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new quotation.<br/>
	 * This method executes a partial query on the createQuotation mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createQuotation</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Quotation createQuotation = executor.createQuotationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotation, // A value for createQuotation's quotation input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param quotation Parameter for the createQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Quotation createQuotationWithBindValues(String queryResponseDef, QuotationInput quotation,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createQuotationWithBindValues(queryResponseDef, quotation, parameters));
	}

	/**
	 * Creates a new quotation.<br/>
	 * This method executes a partial query on the createQuotation mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createQuotation</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Quotation createQuotation = executor.createQuotation(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotation, // A value for createQuotation's quotation input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param quotation Parameter for the createQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Quotation createQuotation(String queryResponseDef, QuotationInput quotation, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createQuotation(queryResponseDef, quotation, paramsAndValues));
	}

	/**
	 * Creates a new quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Quotation createQuotation = executor.createQuotationWithBindValues(preparedRequest, quotation, // A value
	 * 																										// for
	 * 																										// createQuotation's
	 * 																										// quotation
	 * 																										// input
	 * 																										// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateQuotationGraphQLRequest(String)} method.
	 * @param quotation Parameter for the createQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Quotation createQuotationWithBindValues(ObjectResponse objectResponse, QuotationInput quotation,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createQuotationWithBindValues(objectResponse, quotation, parameters));
	}

	/**
	 * Creates a new quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Quotation createQuotation = executor.createQuotation(preparedRequest, quotation, // A value for
	 * 																							// createQuotation's
	 * 																							// quotation input
	 * 																							// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateQuotationGraphQLRequest(String)} method.
	 * @param quotation Parameter for the createQuotation field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Quotation createQuotation(ObjectResponse objectResponse, QuotationInput quotation, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createQuotation(objectResponse, quotation, paramsAndValues));
	}

	/**
	 * Creates a new quotation.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Quotation, as expected by the
	 * createQuotation query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getCreateQuotationResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getCreateQuotationResponseBuilder();
	}

	/**
	 * Creates a new quotation.<br/>
	 * Get the {@link GraphQLRequest} for the createQuotation EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getCreateQuotationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createQuotation" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "quotation", "mutationCreateQuotationQuotation", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "QuotationInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing quotation.<br/>
	 * This method executes a partial query on the updateQuotation mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateQuotation</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Quotation updateQuotation = executor.updateQuotationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotation, // A value for updateQuotation's quotation input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param quotation Parameter for the updateQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Quotation updateQuotationWithBindValues(String queryResponseDef, QuotationInput quotation,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateQuotationWithBindValues(queryResponseDef, quotation, parameters));
	}

	/**
	 * Updates an existing quotation.<br/>
	 * This method executes a partial query on the updateQuotation mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateQuotation</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Quotation updateQuotation = executor.updateQuotation(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotation, // A value for updateQuotation's quotation input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param quotation Parameter for the updateQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Quotation updateQuotation(String queryResponseDef, QuotationInput quotation, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateQuotation(queryResponseDef, quotation, paramsAndValues));
	}

	/**
	 * Updates an existing quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Quotation updateQuotation = executor.updateQuotationWithBindValues(preparedRequest, quotation, // A value
	 * 																										// for
	 * 																										// updateQuotation's
	 * 																										// quotation
	 * 																										// input
	 * 																										// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateQuotationGraphQLRequest(String)} method.
	 * @param quotation Parameter for the updateQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Quotation updateQuotationWithBindValues(ObjectResponse objectResponse, QuotationInput quotation,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateQuotationWithBindValues(objectResponse, quotation, parameters));
	}

	/**
	 * Updates an existing quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Quotation updateQuotation = executor.updateQuotation(preparedRequest, quotation, // A value for
	 * 																							// updateQuotation's
	 * 																							// quotation input
	 * 																							// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateQuotationGraphQLRequest(String)} method.
	 * @param quotation Parameter for the updateQuotation field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Quotation updateQuotation(ObjectResponse objectResponse, QuotationInput quotation, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateQuotation(objectResponse, quotation, paramsAndValues));
	}

	/**
	 * Updates an existing quotation.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Quotation, as expected by the
	 * updateQuotation query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getUpdateQuotationResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdateQuotationResponseBuilder();
	}

	/**
	 * Updates an existing quotation.<br/>
	 * Get the {@link GraphQLRequest} for the updateQuotation EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdateQuotationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateQuotation" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "quotation", "mutationUpdateQuotationQuotation", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "QuotationInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * This method executes a partial query on the deleteQuotation mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteQuotation</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Quotation deleteQuotation = executor.deleteQuotationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotationId, // A value for deleteQuotation's quotationId input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param quotationId Parameter for the deleteQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Quotation deleteQuotationWithBindValues(String queryResponseDef, Long quotationId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteQuotationWithBindValues(queryResponseDef, quotationId, parameters));
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * This method executes a partial query on the deleteQuotation mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteQuotation</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Quotation deleteQuotation = executor.deleteQuotation(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotationId, // A value for deleteQuotation's quotationId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param quotationId Parameter for the deleteQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Quotation deleteQuotation(String queryResponseDef, Long quotationId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteQuotation(queryResponseDef, quotationId, paramsAndValues));
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Quotation deleteQuotation = executor.deleteQuotationWithBindValues(preparedRequest, quotationId, // A
	 * 																											// value
	 * 																											// for
	 * 																											// deleteQuotation's
	 * 																											// quotationId
	 * 																											// input
	 * 																											// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteQuotationGraphQLRequest(String)} method.
	 * @param quotationId Parameter for the deleteQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Quotation deleteQuotationWithBindValues(ObjectResponse objectResponse, Long quotationId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteQuotationWithBindValues(objectResponse, quotationId, parameters));
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Quotation deleteQuotation = executor.deleteQuotation(preparedRequest, quotationId, // A value for
	 * 																							// deleteQuotation's
	 * 																							// quotationId input
	 * 																							// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteQuotationGraphQLRequest(String)} method.
	 * @param quotationId Parameter for the deleteQuotation field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Quotation deleteQuotation(ObjectResponse objectResponse, Long quotationId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteQuotation(objectResponse, quotationId, paramsAndValues));
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Quotation, as expected by the
	 * deleteQuotation query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getDeleteQuotationResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getDeleteQuotationResponseBuilder();
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * Get the {@link GraphQLRequest} for the deleteQuotation EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDeleteQuotationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteQuotation" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "quotationId", "mutationDeleteQuotationQuotationId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new topic.<br/>
	 * This method executes a partial query on the createTopic mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createTopic</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Topic createTopic = executor.createTopicWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topic, // A value for createTopic's topic input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topic Parameter for the createTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Topic createTopicWithBindValues(String queryResponseDef, TopicInput topic, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createTopicWithBindValues(queryResponseDef, topic, parameters));
	}

	/**
	 * Creates a new topic.<br/>
	 * This method executes a partial query on the createTopic mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createTopic</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Topic createTopic = executor.createTopic(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topic, // A value for createTopic's topic input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topic Parameter for the createTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Topic createTopic(String queryResponseDef, TopicInput topic, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createTopic(queryResponseDef, topic, paramsAndValues));
	}

	/**
	 * Creates a new topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Topic createTopic = executor.createTopicWithBindValues(preparedRequest, topic, // A value for
	 * 																						// createTopic's topic
	 * 																						// input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateTopicGraphQLRequest(String)} method.
	 * @param topic Parameter for the createTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Topic createTopicWithBindValues(ObjectResponse objectResponse, TopicInput topic,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createTopicWithBindValues(objectResponse, topic, parameters));
	}

	/**
	 * Creates a new topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Topic createTopic = executor.createTopic(preparedRequest, topic, // A value for createTopic's topic input
	 * 																			// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateTopicGraphQLRequest(String)} method.
	 * @param topic Parameter for the createTopic field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Topic createTopic(ObjectResponse objectResponse, TopicInput topic, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createTopic(objectResponse, topic, paramsAndValues));
	}

	/**
	 * Creates a new topic.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Topic, as expected by the createTopic
	 * query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getCreateTopicResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getCreateTopicResponseBuilder();
	}

	/**
	 * Creates a new topic.<br/>
	 * Get the {@link GraphQLRequest} for the createTopic EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getCreateTopicGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createTopic" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "topic", "mutationCreateTopicTopic", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TopicInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing topic.<br/>
	 * This method executes a partial query on the updateTopic mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateTopic</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Topic updateTopic = executor.updateTopicWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topic, // A value for updateTopic's topic input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topic Parameter for the updateTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Topic updateTopicWithBindValues(String queryResponseDef, TopicInput topic, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateTopicWithBindValues(queryResponseDef, topic, parameters));
	}

	/**
	 * Updates an existing topic.<br/>
	 * This method executes a partial query on the updateTopic mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateTopic</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Topic updateTopic = executor.updateTopic(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topic, // A value for updateTopic's topic input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topic Parameter for the updateTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Topic updateTopic(String queryResponseDef, TopicInput topic, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateTopic(queryResponseDef, topic, paramsAndValues));
	}

	/**
	 * Updates an existing topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Topic updateTopic = executor.updateTopicWithBindValues(preparedRequest, topic, // A value for
	 * 																						// updateTopic's topic
	 * 																						// input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateTopicGraphQLRequest(String)} method.
	 * @param topic Parameter for the updateTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Topic updateTopicWithBindValues(ObjectResponse objectResponse, TopicInput topic,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateTopicWithBindValues(objectResponse, topic, parameters));
	}

	/**
	 * Updates an existing topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Topic updateTopic = executor.updateTopic(preparedRequest, topic, // A value for updateTopic's topic input
	 * 																			// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateTopicGraphQLRequest(String)} method.
	 * @param topic Parameter for the updateTopic field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Topic updateTopic(ObjectResponse objectResponse, TopicInput topic, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateTopic(objectResponse, topic, paramsAndValues));
	}

	/**
	 * Updates an existing topic.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Topic, as expected by the updateTopic
	 * query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getUpdateTopicResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdateTopicResponseBuilder();
	}

	/**
	 * Updates an existing topic.<br/>
	 * Get the {@link GraphQLRequest} for the updateTopic EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdateTopicGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateTopic" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "topic", "mutationUpdateTopicTopic", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TopicInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing topic.<br/>
	 * This method executes a partial query on the deleteTopic mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteTopic</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Topic deleteTopic = executor.deleteTopicWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topicId, // A value for deleteTopic's topicId input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topicId Parameter for the deleteTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Topic deleteTopicWithBindValues(String queryResponseDef, Long topicId, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteTopicWithBindValues(queryResponseDef, topicId, parameters));
	}

	/**
	 * Deletes an existing topic.<br/>
	 * This method executes a partial query on the deleteTopic mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteTopic</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Topic deleteTopic = executor.deleteTopic(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topicId, // A value for deleteTopic's topicId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topicId Parameter for the deleteTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Topic deleteTopic(String queryResponseDef, Long topicId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteTopic(queryResponseDef, topicId, paramsAndValues));
	}

	/**
	 * Deletes an existing topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Topic deleteTopic = executor.deleteTopicWithBindValues(preparedRequest, topicId, // A value for
	 * 																							// deleteTopic's
	 * 																							// topicId input
	 * 																							// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteTopicGraphQLRequest(String)} method.
	 * @param topicId Parameter for the deleteTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Topic deleteTopicWithBindValues(ObjectResponse objectResponse, Long topicId, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteTopicWithBindValues(objectResponse, topicId, parameters));
	}

	/**
	 * Deletes an existing topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Topic deleteTopic = executor.deleteTopic(preparedRequest, topicId, // A value for deleteTopic's topicId
	 * 																			// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteTopicGraphQLRequest(String)} method.
	 * @param topicId Parameter for the deleteTopic field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Topic deleteTopic(ObjectResponse objectResponse, Long topicId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteTopic(objectResponse, topicId, paramsAndValues));
	}

	/**
	 * Deletes an existing topic.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Topic, as expected by the deleteTopic
	 * query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getDeleteTopicResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getDeleteTopicResponseBuilder();
	}

	/**
	 * Deletes an existing topic.<br/>
	 * Get the {@link GraphQLRequest} for the deleteTopic EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDeleteTopicGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteTopic" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "topicId", "mutationDeleteTopicTopicId", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Adds a new topic reference.<br/>
	 * This method executes a partial query on the addTopicRef mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>addTopicRef</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Boolean addTopicRef = executor.addTopicRefWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topicRef, // A value for addTopicRef's topicRef input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topicRef Parameter for the addTopicRef field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "addTopicRef", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Boolean addTopicRefWithBindValues(String queryResponseDef, TopicRefInput topicRef,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.addTopicRefWithBindValues(queryResponseDef, topicRef, parameters));
	}

	/**
	 * Adds a new topic reference.<br/>
	 * This method executes a partial query on the addTopicRef mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>addTopicRef</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Boolean addTopicRef = executor.addTopicRef(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topicRef, // A value for addTopicRef's topicRef input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topicRef Parameter for the addTopicRef field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "addTopicRef", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Boolean addTopicRef(String queryResponseDef, TopicRefInput topicRef, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.addTopicRef(queryResponseDef, topicRef, paramsAndValues));
	}

	/**
	 * Adds a new topic reference.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getAddTopicRefGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Boolean addTopicRef = executor.addTopicRefWithBindValues(preparedRequest, topicRef, // A value for
	 * 																							// addTopicRef's
	 * 																							// topicRef input
	 * 																							// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getAddTopicRefGraphQLRequest(String)} method.
	 * @param topicRef Parameter for the addTopicRef field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "addTopicRef", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Boolean addTopicRefWithBindValues(ObjectResponse objectResponse, TopicRefInput topicRef,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.addTopicRefWithBindValues(objectResponse, topicRef, parameters));
	}

	/**
	 * Adds a new topic reference.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getAddTopicRefGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Boolean addTopicRef = executor.addTopicRef(preparedRequest, topicRef, // A value for addTopicRef's
	 * 																				// topicRef input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getAddTopicRefGraphQLRequest(String)} method.
	 * @param topicRef Parameter for the addTopicRef field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "addTopicRef", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Boolean addTopicRef(ObjectResponse objectResponse, TopicRefInput topicRef, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.addTopicRef(objectResponse, topicRef, paramsAndValues));
	}

	/**
	 * Adds a new topic reference.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Boolean, as expected by the addTopicRef
	 * query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getAddTopicRefResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getAddTopicRefResponseBuilder();
	}

	/**
	 * Adds a new topic reference.<br/>
	 * Get the {@link GraphQLRequest} for the addTopicRef EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getAddTopicRefGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "addTopicRef" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "topicRef", "mutationAddTopicRefTopicRef", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "TopicRefInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Removes a topic reference.<br/>
	 * This method executes a partial query on the removeTopicRef mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>removeTopicRef</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Boolean removeTopicRef = executor.removeTopicRefWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topicRef, // A value for removeTopicRef's topicRef input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topicRef Parameter for the removeTopicRef field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "removeTopicRef", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Boolean removeTopicRefWithBindValues(String queryResponseDef, TopicRefInput topicRef,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.removeTopicRefWithBindValues(queryResponseDef, topicRef, parameters));
	}

	/**
	 * Removes a topic reference.<br/>
	 * This method executes a partial query on the removeTopicRef mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>removeTopicRef</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Boolean removeTopicRef = executor.removeTopicRef(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topicRef, // A value for removeTopicRef's topicRef input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topicRef Parameter for the removeTopicRef field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "removeTopicRef", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Boolean removeTopicRef(String queryResponseDef, TopicRefInput topicRef, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.removeTopicRef(queryResponseDef, topicRef, paramsAndValues));
	}

	/**
	 * Removes a topic reference.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getRemoveTopicRefGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Boolean removeTopicRef = executor.removeTopicRefWithBindValues(preparedRequest, topicRef, // A value for
	 * 																									// removeTopicRef's
	 * 																									// topicRef
	 * 																									// input
	 * 																									// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getRemoveTopicRefGraphQLRequest(String)} method.
	 * @param topicRef Parameter for the removeTopicRef field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "removeTopicRef", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Boolean removeTopicRefWithBindValues(ObjectResponse objectResponse, TopicRefInput topicRef,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.removeTopicRefWithBindValues(objectResponse, topicRef, parameters));
	}

	/**
	 * Removes a topic reference.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getRemoveTopicRefGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Boolean removeTopicRef = executor.removeTopicRef(preparedRequest, topicRef, // A value for
	 * 																					// removeTopicRef's topicRef
	 * 																					// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getRemoveTopicRefGraphQLRequest(String)} method.
	 * @param topicRef Parameter for the removeTopicRef field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "removeTopicRef", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Boolean removeTopicRef(ObjectResponse objectResponse, TopicRefInput topicRef, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.removeTopicRef(objectResponse, topicRef, paramsAndValues));
	}

	/**
	 * Removes a topic reference.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Boolean, as expected by the
	 * removeTopicRef query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getRemoveTopicRefResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getRemoveTopicRefResponseBuilder();
	}

	/**
	 * Removes a topic reference.<br/>
	 * Get the {@link GraphQLRequest} for the removeTopicRef EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getRemoveTopicRefGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "removeTopicRef" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "topicRef", "mutationRemoveTopicRefTopicRef", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "TopicRefInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Links two entities.<br/>
	 * This method executes a partial query on the linkEntities mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>linkEntities</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Boolean linkEntities = executor.linkEntitiesWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			link, // A value for linkEntities's link input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param link Parameter for the linkEntities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "linkEntities", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Boolean linkEntitiesWithBindValues(String queryResponseDef, LinkEntitiesInput link,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.linkEntitiesWithBindValues(queryResponseDef, link, parameters));
	}

	/**
	 * Links two entities.<br/>
	 * This method executes a partial query on the linkEntities mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>linkEntities</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Boolean linkEntities = executor.linkEntities(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			link, // A value for linkEntities's link input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param link Parameter for the linkEntities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "linkEntities", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Boolean linkEntities(String queryResponseDef, LinkEntitiesInput link, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.linkEntities(queryResponseDef, link, paramsAndValues));
	}

	/**
	 * Links two entities.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getLinkEntitiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Boolean linkEntities = executor.linkEntitiesWithBindValues(preparedRequest, link, // A value for
	 * 																							// linkEntities's
	 * 																							// link input
	 * 																							// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getLinkEntitiesGraphQLRequest(String)} method.
	 * @param link Parameter for the linkEntities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "linkEntities", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Boolean linkEntitiesWithBindValues(ObjectResponse objectResponse, LinkEntitiesInput link,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.linkEntitiesWithBindValues(objectResponse, link, parameters));
	}

	/**
	 * Links two entities.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getLinkEntitiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Boolean linkEntities = executor.linkEntities(preparedRequest, link, // A value for linkEntities's link
	 * 																			// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getLinkEntitiesGraphQLRequest(String)} method.
	 * @param link Parameter for the linkEntities field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "linkEntities", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Boolean linkEntities(ObjectResponse objectResponse, LinkEntitiesInput link, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.linkEntities(objectResponse, link, paramsAndValues));
	}

	/**
	 * Links two entities.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Boolean, as expected by the
	 * linkEntities query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getLinkEntitiesResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getLinkEntitiesResponseBuilder();
	}

	/**
	 * Links two entities.<br/>
	 * Get the {@link GraphQLRequest} for the linkEntities EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getLinkEntitiesGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "linkEntities" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "link", "mutationLinkEntitiesLink", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"LinkEntitiesInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Unlinks two linked entities.<br/>
	 * This method executes a partial query on the unlinkEntities mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>unlinkEntities</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Boolean unlinkEntities = executor.unlinkEntitiesWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			link, // A value for unlinkEntities's link input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param link Parameter for the unlinkEntities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "unlinkEntities", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Boolean unlinkEntitiesWithBindValues(String queryResponseDef, LinkEntitiesInput link,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.unlinkEntitiesWithBindValues(queryResponseDef, link, parameters));
	}

	/**
	 * Unlinks two linked entities.<br/>
	 * This method executes a partial query on the unlinkEntities mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>unlinkEntities</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Boolean unlinkEntities = executor.unlinkEntities(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			link, // A value for unlinkEntities's link input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param link Parameter for the unlinkEntities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "unlinkEntities", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Boolean unlinkEntities(String queryResponseDef, LinkEntitiesInput link, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.unlinkEntities(queryResponseDef, link, paramsAndValues));
	}

	/**
	 * Unlinks two linked entities.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUnlinkEntitiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Boolean unlinkEntities = executor.unlinkEntitiesWithBindValues(preparedRequest, link, // A value for
	 * 																								// unlinkEntities's
	 * 																								// link input
	 * 																								// parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUnlinkEntitiesGraphQLRequest(String)} method.
	 * @param link Parameter for the unlinkEntities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "unlinkEntities", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Boolean unlinkEntitiesWithBindValues(ObjectResponse objectResponse, LinkEntitiesInput link,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.unlinkEntitiesWithBindValues(objectResponse, link, parameters));
	}

	/**
	 * Unlinks two linked entities.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUnlinkEntitiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Boolean unlinkEntities = executor.unlinkEntities(preparedRequest, link, // A value for unlinkEntities's
	 * 																				// link input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUnlinkEntitiesGraphQLRequest(String)} method.
	 * @param link Parameter for the unlinkEntities field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "unlinkEntities", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Boolean unlinkEntities(ObjectResponse objectResponse, LinkEntitiesInput link, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.unlinkEntities(objectResponse, link, paramsAndValues));
	}

	/**
	 * Unlinks two linked entities.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Boolean, as expected by the
	 * unlinkEntities query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getUnlinkEntitiesResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUnlinkEntitiesResponseBuilder();
	}

	/**
	 * Unlinks two linked entities.<br/>
	 * Get the {@link GraphQLRequest} for the unlinkEntities EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUnlinkEntitiesGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "unlinkEntities" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "link", "mutationUnlinkEntitiesLink", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"LinkEntitiesInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Sets entity status.<br/>
	 * This method executes a partial query on the setEntityStatus mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>setEntityStatus</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Boolean setEntityStatus = executor.setEntityStatusWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			entityKind, // A value for setEntityStatus's entityKind input parameter
	 * 			entityId, // A value for setEntityStatus's entityId input parameter
	 * 			status, // A value for setEntityStatus's status input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param entityKind Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param entityId Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param status Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "setEntityStatus", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Boolean setEntityStatusWithBindValues(String queryResponseDef, EntityKind entityKind, Long entityId,
		StatusKind status, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(this.mutationReactiveExecutor.setEntityStatusWithBindValues(queryResponseDef,
			entityKind, entityId, status, parameters));
	}

	/**
	 * Sets entity status.<br/>
	 * This method executes a partial query on the setEntityStatus mutation against the GraphQL server. That is, the
	 * mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains
	 * the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>setEntityStatus</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Boolean setEntityStatus = executor.setEntityStatus(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			entityKind, // A value for setEntityStatus's entityKind input parameter
	 * 			entityId, // A value for setEntityStatus's entityId input parameter
	 * 			status, // A value for setEntityStatus's status input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param entityKind Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param entityId Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param status Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "setEntityStatus", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Boolean setEntityStatus(String queryResponseDef, EntityKind entityKind, Long entityId, StatusKind status,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(this.mutationReactiveExecutor.setEntityStatus(queryResponseDef, entityKind,
			entityId, status, paramsAndValues));
	}

	/**
	 * Sets entity status.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getSetEntityStatusGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Boolean setEntityStatus = executor.setEntityStatusWithBindValues(preparedRequest, entityKind, // A value
	 * 																										// for
	 * 																										// setEntityStatus's
	 * 																										// entityKind
	 * 																										// input
	 * 																										// parameter
	 * 			entityId, // A value for setEntityStatus's entityId input parameter
	 * 			status, // A value for setEntityStatus's status input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getSetEntityStatusGraphQLRequest(String)} method.
	 * @param entityKind Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param entityId Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param status Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "setEntityStatus", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Boolean setEntityStatusWithBindValues(ObjectResponse objectResponse, EntityKind entityKind, Long entityId,
		StatusKind status, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(this.mutationReactiveExecutor.setEntityStatusWithBindValues(objectResponse,
			entityKind, entityId, status, parameters));
	}

	/**
	 * Sets entity status.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getSetEntityStatusGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Boolean setEntityStatus = executor.setEntityStatus(preparedRequest, entityKind, // A value for
	 * 																						// setEntityStatus's
	 * 																						// entityKind input
	 * 																						// parameter
	 * 			entityId, // A value for setEntityStatus's entityId input parameter
	 * 			status, // A value for setEntityStatus's status input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getSetEntityStatusGraphQLRequest(String)} method.
	 * @param entityKind Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param entityId Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param status Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "setEntityStatus", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Boolean setEntityStatus(ObjectResponse objectResponse, EntityKind entityKind, Long entityId,
		StatusKind status, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(this.mutationReactiveExecutor.setEntityStatus(objectResponse, entityKind,
			entityId, status, paramsAndValues));
	}

	/**
	 * Sets entity status.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Boolean, as expected by the
	 * setEntityStatus query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getSetEntityStatusResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getSetEntityStatusResponseBuilder();
	}

	/**
	 * Sets entity status.<br/>
	 * Get the {@link GraphQLRequest} for the setEntityStatus EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getSetEntityStatusGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "setEntityStatus" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "entityKind", "mutationSetEntityStatusEntityKind", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "EntityKind", true, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "entityId", "mutationSetEntityStatusEntityId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "Long", true, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "status", "mutationSetEntityStatusStatus", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "StatusKind", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new user.<br/>
	 * This method executes a partial query on the createUser mutation against the GraphQL server. That is, the mutation
	 * is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains the part of
	 * the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createUser</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		User createUser = executor.createUserWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for createUser's user input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param user Parameter for the createUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public User createUserWithBindValues(String queryResponseDef, UserInput user, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createUserWithBindValues(queryResponseDef, user, parameters));
	}

	/**
	 * Creates a new user.<br/>
	 * This method executes a partial query on the createUser mutation against the GraphQL server. That is, the mutation
	 * is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains the part of
	 * the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>createUser</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		User createUser = executor.createUser(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for createUser's user input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param user Parameter for the createUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public User createUser(String queryResponseDef, UserInput user, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createUser(queryResponseDef, user, paramsAndValues));
	}

	/**
	 * Creates a new user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User createUser = executor.createUserWithBindValues(preparedRequest, user, // A value for createUser's
	 * 																					// user input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateUserGraphQLRequest(String)} method.
	 * @param user Parameter for the createUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public User createUserWithBindValues(ObjectResponse objectResponse, UserInput user, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createUserWithBindValues(objectResponse, user, parameters));
	}

	/**
	 * Creates a new user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User createUser = executor.createUser(preparedRequest, user, // A value for createUser's user input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateUserGraphQLRequest(String)} method.
	 * @param user Parameter for the createUser field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public User createUser(ObjectResponse objectResponse, UserInput user, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.createUser(objectResponse, user, paramsAndValues));
	}

	/**
	 * Creates a new user.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the User, as expected by the createUser
	 * query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getCreateUserResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getCreateUserResponseBuilder();
	}

	/**
	 * Creates a new user.<br/>
	 * Get the {@link GraphQLRequest} for the createUser EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getCreateUserGraphQLRequest(String partialRequest) throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createUser" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "user", "mutationCreateUserUser", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"UserInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing user.<br/>
	 * This method executes a partial query on the updateUser mutation against the GraphQL server. That is, the mutation
	 * is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains the part of
	 * the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateUser</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		User updateUser = executor.updateUserWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for updateUser's user input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param user Parameter for the updateUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public User updateUserWithBindValues(String queryResponseDef, UserInput user, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateUserWithBindValues(queryResponseDef, user, parameters));
	}

	/**
	 * Updates an existing user.<br/>
	 * This method executes a partial query on the updateUser mutation against the GraphQL server. That is, the mutation
	 * is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains the part of
	 * the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>updateUser</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		User updateUser = executor.updateUser(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for updateUser's user input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param user Parameter for the updateUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public User updateUser(String queryResponseDef, UserInput user, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateUser(queryResponseDef, user, paramsAndValues));
	}

	/**
	 * Updates an existing user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User updateUser = executor.updateUserWithBindValues(preparedRequest, user, // A value for updateUser's
	 * 																					// user input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateUserGraphQLRequest(String)} method.
	 * @param user Parameter for the updateUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public User updateUserWithBindValues(ObjectResponse objectResponse, UserInput user, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateUserWithBindValues(objectResponse, user, parameters));
	}

	/**
	 * Updates an existing user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User updateUser = executor.updateUser(preparedRequest, user, // A value for updateUser's user input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateUserGraphQLRequest(String)} method.
	 * @param user Parameter for the updateUser field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public User updateUser(ObjectResponse objectResponse, UserInput user, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.updateUser(objectResponse, user, paramsAndValues));
	}

	/**
	 * Updates an existing user.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the User, as expected by the updateUser
	 * query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getUpdateUserResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getUpdateUserResponseBuilder();
	}

	/**
	 * Updates an existing user.<br/>
	 * Get the {@link GraphQLRequest} for the updateUser EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUpdateUserGraphQLRequest(String partialRequest) throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateUser" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "user", "mutationUpdateUserUser", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"UserInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing user.<br/>
	 * This method executes a partial query on the deleteUser mutation against the GraphQL server. That is, the mutation
	 * is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains the part of
	 * the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteUser</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		User deleteUser = executor.deleteUserWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for deleteUser's userId input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param userId Parameter for the deleteUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public User deleteUserWithBindValues(String queryResponseDef, Long userId, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteUserWithBindValues(queryResponseDef, userId, parameters));
	}

	/**
	 * Updates an existing user.<br/>
	 * This method executes a partial query on the deleteUser mutation against the GraphQL server. That is, the mutation
	 * is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains the part of
	 * the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>deleteUser</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		User deleteUser = executor.deleteUser(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for deleteUser's userId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param userId Parameter for the deleteUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public User deleteUser(String queryResponseDef, Long userId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteUser(queryResponseDef, userId, paramsAndValues));
	}

	/**
	 * Updates an existing user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User deleteUser = executor.deleteUserWithBindValues(preparedRequest, userId, // A value for deleteUser's
	 * 																						// userId input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteUserGraphQLRequest(String)} method.
	 * @param userId Parameter for the deleteUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public User deleteUserWithBindValues(ObjectResponse objectResponse, Long userId, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteUserWithBindValues(objectResponse, userId, parameters));
	}

	/**
	 * Updates an existing user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User deleteUser = executor.deleteUser(preparedRequest, userId, // A value for deleteUser's userId input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteUserGraphQLRequest(String)} method.
	 * @param userId Parameter for the deleteUser field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public User deleteUser(ObjectResponse objectResponse, Long userId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.deleteUser(objectResponse, userId, paramsAndValues));
	}

	/**
	 * Updates an existing user.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the User, as expected by the deleteUser
	 * query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getDeleteUserResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getDeleteUserResponseBuilder();
	}

	/**
	 * Updates an existing user.<br/>
	 * Get the {@link GraphQLRequest} for the deleteUser EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDeleteUserGraphQLRequest(String partialRequest) throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteUser" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "userId", "mutationDeleteUserUserId", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Grants permissions to a user. The specified permissions are added to any existing ones.<br/>
	 * This method executes a partial query on the grantUserPermissions mutation against the GraphQL server. That is,
	 * the mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef
	 * contains the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>grantUserPermissions</code> of the Mutation mutation type. It can be something like "{ id name }", or ""
	 * for a scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		User grantUserPermissions = executor.grantUserPermissionsWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for grantUserPermissions's userId input parameter
	 * 			permissions, // A value for grantUserPermissions's permissions input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param userId Parameter for the grantUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param permissions Parameter for the grantUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantUserPermissions", graphQLTypeSimpleName = "User", javaClass = User.class)
	public User grantUserPermissionsWithBindValues(String queryResponseDef, Long userId,
		List<PermissionKind> permissions, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(this.mutationReactiveExecutor
			.grantUserPermissionsWithBindValues(queryResponseDef, userId, permissions, parameters));
	}

	/**
	 * Grants permissions to a user. The specified permissions are added to any existing ones.<br/>
	 * This method executes a partial query on the grantUserPermissions mutation against the GraphQL server. That is,
	 * the mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef
	 * contains the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>grantUserPermissions</code> of the Mutation mutation type. It can be something like "{ id name }", or ""
	 * for a scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		User grantUserPermissions = executor.grantUserPermissions(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for grantUserPermissions's userId input parameter
	 * 			permissions, // A value for grantUserPermissions's permissions input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param userId Parameter for the grantUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param permissions Parameter for the grantUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantUserPermissions", graphQLTypeSimpleName = "User", javaClass = User.class)
	public User grantUserPermissions(String queryResponseDef, Long userId, List<PermissionKind> permissions,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.grantUserPermissions(queryResponseDef, userId, permissions, paramsAndValues));
	}

	/**
	 * Grants permissions to a user. The specified permissions are added to any existing ones.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getGrantUserPermissionsGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User grantUserPermissions = executor.grantUserPermissionsWithBindValues(preparedRequest, userId, // A
	 * 																											// value
	 * 																											// for
	 * 																											// grantUserPermissions's
	 * 																											// userId
	 * 																											// input
	 * 																											// parameter
	 * 			permissions, // A value for grantUserPermissions's permissions input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGrantUserPermissionsGraphQLRequest(String)} method.
	 * @param userId Parameter for the grantUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param permissions Parameter for the grantUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantUserPermissions", graphQLTypeSimpleName = "User", javaClass = User.class)
	public User grantUserPermissionsWithBindValues(ObjectResponse objectResponse, Long userId,
		List<PermissionKind> permissions, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(this.mutationReactiveExecutor.grantUserPermissionsWithBindValues(objectResponse,
			userId, permissions, parameters));
	}

	/**
	 * Grants permissions to a user. The specified permissions are added to any existing ones.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getGrantUserPermissionsGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User grantUserPermissions = executor.grantUserPermissions(preparedRequest, userId, // A value for
	 * 																							// grantUserPermissions's
	 * 																							// userId input
	 * 																							// parameter
	 * 			permissions, // A value for grantUserPermissions's permissions input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGrantUserPermissionsGraphQLRequest(String)} method.
	 * @param userId Parameter for the grantUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param permissions Parameter for the grantUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantUserPermissions", graphQLTypeSimpleName = "User", javaClass = User.class)
	public User grantUserPermissions(ObjectResponse objectResponse, Long userId, List<PermissionKind> permissions,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.grantUserPermissions(objectResponse, userId, permissions, paramsAndValues));
	}

	/**
	 * Grants permissions to a user. The specified permissions are added to any existing ones.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the User, as expected by the
	 * grantUserPermissions query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getGrantUserPermissionsResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getGrantUserPermissionsResponseBuilder();
	}

	/**
	 * Grants permissions to a user. The specified permissions are added to any existing ones.<br/>
	 * Get the {@link GraphQLRequest} for the grantUserPermissions EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getGrantUserPermissionsGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "grantUserPermissions" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "userId", "mutationGrantUserPermissionsUserId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "permissions", "mutationGrantUserPermissionsPermissions", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "PermissionKind", true, 1, true) //$NON-NLS-1$
		);
	}

	/**
	 * Revokes permissions from a user. The specified permissions are removed from the user; other permissions remain
	 * intact.<br/>
	 * This method executes a partial query on the revokeUserPermissions mutation against the GraphQL server. That is,
	 * the mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef
	 * contains the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>revokeUserPermissions</code> of the Mutation mutation type. It can be something like "{ id name }", or ""
	 * for a scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		User revokeUserPermissions = executor.revokeUserPermissionsWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for revokeUserPermissions's userId input parameter
	 * 			permissions, // A value for revokeUserPermissions's permissions input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param userId Parameter for the revokeUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param permissions Parameter for the revokeUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeUserPermissions", graphQLTypeSimpleName = "User", javaClass = User.class)
	public User revokeUserPermissionsWithBindValues(String queryResponseDef, Long userId,
		List<PermissionKind> permissions, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(this.mutationReactiveExecutor
			.revokeUserPermissionsWithBindValues(queryResponseDef, userId, permissions, parameters));
	}

	/**
	 * Revokes permissions from a user. The specified permissions are removed from the user; other permissions remain
	 * intact.<br/>
	 * This method executes a partial query on the revokeUserPermissions mutation against the GraphQL server. That is,
	 * the mutation is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef
	 * contains the part of the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>revokeUserPermissions</code> of the Mutation mutation type. It can be something like "{ id name }", or ""
	 * for a scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		User revokeUserPermissions = executor.revokeUserPermissions(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for revokeUserPermissions's userId input parameter
	 * 			permissions, // A value for revokeUserPermissions's permissions input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param userId Parameter for the revokeUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param permissions Parameter for the revokeUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeUserPermissions", graphQLTypeSimpleName = "User", javaClass = User.class)
	public User revokeUserPermissions(String queryResponseDef, Long userId, List<PermissionKind> permissions,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(this.mutationReactiveExecutor.revokeUserPermissions(queryResponseDef, userId,
			permissions, paramsAndValues));
	}

	/**
	 * Revokes permissions from a user. The specified permissions are removed from the user; other permissions remain
	 * intact.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getRevokeUserPermissionsGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User revokeUserPermissions = executor.revokeUserPermissionsWithBindValues(preparedRequest, userId, // A
	 * 																											// value
	 * 																											// for
	 * 																											// revokeUserPermissions's
	 * 																											// userId
	 * 																											// input
	 * 																											// parameter
	 * 			permissions, // A value for revokeUserPermissions's permissions input parameter
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getRevokeUserPermissionsGraphQLRequest(String)} method.
	 * @param userId Parameter for the revokeUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param permissions Parameter for the revokeUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeUserPermissions", graphQLTypeSimpleName = "User", javaClass = User.class)
	public User revokeUserPermissionsWithBindValues(ObjectResponse objectResponse, Long userId,
		List<PermissionKind> permissions, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(this.mutationReactiveExecutor
			.revokeUserPermissionsWithBindValues(objectResponse, userId, permissions, parameters));
	}

	/**
	 * Revokes permissions from a user. The specified permissions are removed from the user; other permissions remain
	 * intact.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getRevokeUserPermissionsGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		User revokeUserPermissions = executor.revokeUserPermissions(preparedRequest, userId, // A value for
	 * 																								// revokeUserPermissions's
	 * 																								// userId input
	 * 																								// parameter
	 * 			permissions, // A value for revokeUserPermissions's permissions input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getRevokeUserPermissionsGraphQLRequest(String)} method.
	 * @param userId Parameter for the revokeUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param permissions Parameter for the revokeUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeUserPermissions", graphQLTypeSimpleName = "User", javaClass = User.class)
	public User revokeUserPermissions(ObjectResponse objectResponse, Long userId, List<PermissionKind> permissions,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.revokeUserPermissions(objectResponse, userId, permissions, paramsAndValues));
	}

	/**
	 * Revokes permissions from a user. The specified permissions are removed from the user; other permissions remain
	 * intact.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the User, as expected by the
	 * revokeUserPermissions query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getRevokeUserPermissionsResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.getRevokeUserPermissionsResponseBuilder();
	}

	/**
	 * Revokes permissions from a user. The specified permissions are removed from the user; other permissions remain
	 * intact.<br/>
	 * Get the {@link GraphQLRequest} for the revokeUserPermissions EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getRevokeUserPermissionsGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "revokeUserPermissions" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "userId", "mutationRevokeUserPermissionsUserId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "permissions", "mutationRevokeUserPermissionsPermissions", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "PermissionKind", true, 1, true) //$NON-NLS-1$
		);
	}

	/**
	 * This method executes a partial query on the __typename mutation against the GraphQL server. That is, the mutation
	 * is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains the part of
	 * the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>__typename</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		String __typename = executor.__typenameWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "__typename", graphQLTypeSimpleName = "String", javaClass = String.class)
	public String __typenameWithBindValues(String queryResponseDef, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.__typenameWithBindValues(queryResponseDef, parameters));
	}

	/**
	 * This method executes a partial query on the __typename mutation against the GraphQL server. That is, the mutation
	 * is one of the field of the Mutation type defined in the GraphQL schema. The queryResponseDef contains the part of
	 * the query that follows the field name.<br/>
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the
	 * <code>__typename</code> of the Mutation mutation type. It can be something like "{ id name }", or "" for a
	 * scalar. Please take a look at the StarWars, Forum and other samples for more complex queries.<br/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		String __typename = executor.__typename(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "__typename", graphQLTypeSimpleName = "String", javaClass = String.class)
	public String __typename(String queryResponseDef, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		return getValueFromMonoOptional(this.mutationReactiveExecutor.__typename(queryResponseDef, paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.get__typenameGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		String __typename = executor.__typenameWithBindValues(preparedRequest, params);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link get__typenameGraphQLRequest(String)} method.
	 * @param parameters The list of values, for the bind variables declared in the request you defined. If there is no
	 * bind variable in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "__typename", graphQLTypeSimpleName = "String", javaClass = String.class)
	public String __typenameWithBindValues(ObjectResponse objectResponse, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(
			this.mutationReactiveExecutor.__typenameWithBindValues(objectResponse, parameters));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<br/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<br/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.get__typenameGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		String __typename = executor.__typename(preparedRequest, "param", paramValue, // param is optional, as it
	 * 																						// is marked by a "?" in
	 * 																						// the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link get__typenameGraphQLRequest(String)} method.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<br/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "__typename", graphQLTypeSimpleName = "String", javaClass = String.class)
	public String __typename(ObjectResponse objectResponse, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return getValueFromMonoOptional(this.mutationReactiveExecutor.__typename(objectResponse, paramsAndValues));
	}

	/**
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the String, as expected by the __typename
	 * query.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder get__typenameResponseBuilder()
		throws GraphQLRequestPreparationException {
		return this.mutationReactiveExecutor.get__typenameResponseBuilder();
	}

	/**
	 * Get the {@link GraphQLRequest} for the __typename EXECUTOR, created with the given Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest get__typenameGraphQLRequest(String partialRequest) throws GraphQLRequestPreparationException {
		return new GraphQLRequest(this.graphQlClient, partialRequest, RequestType.mutation, "__typename" //$NON-NLS-1$
		);
	}

	/**
	 * Retrieves the value returned by the given Mono.
	 * @param <T>
	 * @param mono
	 * @param clazz
	 * @return
	 * @throws GraphQLRequestExecutionException A {@link GraphQLRequestExecutionException} is thrown, when a
	 * {@link GraphQLRequestExecutionUncheckedException} is thrown while processing the Mono.
	 */
	private static <T> T getValueFromMono(Mono<T> mono) throws GraphQLRequestExecutionException {
		try {
			return mono.block();
		} catch (GraphQLRequestExecutionUncheckedException e) {
			throw e.getGraphQLRequestExecutionException();
		}
	}

	/**
	 * Retrieves the value returned by the given Mono. The values are {@link Optional}, and the returned is either null
	 * or the non empty value
	 * @param <T>
	 * @param mono
	 * @param clazz
	 * @return
	 * @throws GraphQLRequestExecutionException A {@link GraphQLRequestExecutionException} is thrown, when a
	 * {@link GraphQLRequestExecutionUncheckedException} is thrown while processing the Mono.
	 */
	private static <T> T getValueFromMonoOptional(Mono<Optional<T>> mono) throws GraphQLRequestExecutionException {
		try {
			Optional<T> optional = mono.block();
			return (optional.isPresent()) ? optional.get() : null;
		} catch (GraphQLRequestExecutionUncheckedException e) {
			throw e.getGraphQLRequestExecutionException();
		}
	}
}
