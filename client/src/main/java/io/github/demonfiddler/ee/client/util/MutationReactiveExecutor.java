/*----------------------------------------------------------------------------------------------------------------------
 * Evidence Engine: A system for managing evidence on arbitrary scientific topics.
 * Comprises an SQL database, GraphQL public API, Java app server, Java and web clients.
 * Copyright Â© 2024-25 Adrian Price. All rights reserved.
 *
 * This file is part of Evidence Engine.
 *
 * Evidence Engine is free software: you can redistribute it and/or modify it under the terms of the
 * GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * Evidence Engine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License along with Evidence Engine.
 * If not, see <https://www.gnu.org/licenses/>. 
 *--------------------------------------------------------------------------------------------------------------------*/

package io.github.demonfiddler.ee.client.util;

import static com.graphql_java_generator.client.request.InputParameter.InputParameterType.MANDATORY;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.graphql.client.GraphQlClient;
import org.springframework.stereotype.Component;

import com.graphql_java_generator.annotation.GraphQLDirective;
import com.graphql_java_generator.annotation.GraphQLNonScalar;
import com.graphql_java_generator.annotation.GraphQLScalar;
import com.graphql_java_generator.annotation.RequestType;
import com.graphql_java_generator.client.GraphQLMutationReactiveExecutor;
import com.graphql_java_generator.client.request.Builder;
import com.graphql_java_generator.client.request.InputParameter;
import com.graphql_java_generator.client.request.InputParameter.InputParameterType;
import com.graphql_java_generator.client.request.ObjectResponse;
import com.graphql_java_generator.customscalars.GraphQLScalarTypeDate;
import com.graphql_java_generator.exception.GraphQLRequestExecutionException;
import com.graphql_java_generator.exception.GraphQLRequestPreparationException;
import com.graphql_java_generator.util.GraphqlUtils;

import io.github.demonfiddler.ee.client.Claim;
import io.github.demonfiddler.ee.client.ClaimInput;
import io.github.demonfiddler.ee.client.Declaration;
import io.github.demonfiddler.ee.client.DeclarationInput;
import io.github.demonfiddler.ee.client.EntityLink;
import io.github.demonfiddler.ee.client.EntityLinkInput;
import io.github.demonfiddler.ee.client.Group;
import io.github.demonfiddler.ee.client.GroupInput;
import io.github.demonfiddler.ee.client.Journal;
import io.github.demonfiddler.ee.client.JournalInput;
import io.github.demonfiddler.ee.client.Mutation;
import io.github.demonfiddler.ee.client.AuthorityKind;
import io.github.demonfiddler.ee.client.Person;
import io.github.demonfiddler.ee.client.PersonInput;
import io.github.demonfiddler.ee.client.Publication;
import io.github.demonfiddler.ee.client.PublicationInput;
import io.github.demonfiddler.ee.client.Publisher;
import io.github.demonfiddler.ee.client.PublisherInput;
import io.github.demonfiddler.ee.client.Quotation;
import io.github.demonfiddler.ee.client.QuotationInput;
import io.github.demonfiddler.ee.client.StatusKind;
import io.github.demonfiddler.ee.client.Topic;
import io.github.demonfiddler.ee.client.TopicInput;
import io.github.demonfiddler.ee.client.User;
import io.github.demonfiddler.ee.client.UserInput;
import io.github.demonfiddler.ee.client.UserPasswordInput;
import io.github.demonfiddler.ee.client.UserProfileInput;
import reactor.core.publisher.Mono;

/**
 * Available mutations. <BR/>
 * This class contains the methods that allows the execution of the queries or mutations that are defined in the
 * Mutation of the GraphQL schema. All the methods for this executor are in spring reactive, that is: they return a
 * {@link Mono}.<BR/>
 * These methods allows:
 * <UL>
 * <LI>Preparation of full requests</LI>
 * <LI>Execution of prepared full requests</LI>
 * <LI>Execution of direct full direct requests</LI>
 * <LI>Preparation of partial requests</LI>
 * <LI>Execution of prepared partial requests</LI>
 * <LI>Execution of direct partial requests</LI>
 * </UL>
 * You'll find all the documentation on the
 * <A HREF="https://github.com/graphql-java-generator/graphql-maven-plugin-project/wiki/client_spring">client page
 * doc</A>.
 * @author generated by graphql-java-generator
 */
@Component
public class MutationReactiveExecutor implements GraphQLMutationReactiveExecutor {

	/** Logger for this class */
	private static final Logger LOGGER = LoggerFactory.getLogger(MutationReactiveExecutor.class);

	@Autowired
	@Qualifier("httpGraphQlClient")
	GraphQlClient graphQlClient;

	@Autowired
	GraphqlClientUtilsEx graphqlClientUtils;

	GraphqlUtils graphqlUtils = GraphqlUtils.graphqlUtils; // must be set that way, to be used in the constructor

	public MutationReactiveExecutor() {
		if (!"2.8".equals(this.graphqlUtils.getRuntimeVersion())) {
			throw new RuntimeException(
				"The GraphQL runtime version doesn't match the GraphQL plugin version. The runtime's version is '"
					+ this.graphqlUtils.getRuntimeVersion() + "' whereas the GraphQL plugin version is '2.8'");
		}
		CustomScalarRegistryInitializer.initCustomScalarRegistry();
		DirectiveRegistryInitializer.initDirectiveRegistry();
	}

	/**
	 * This method takes a <B>full request</B> definition, and executes it against the GraphQL server. As this class is
	 * a mutation executor, the provided request must be a mutation full request. This request will be executed in
	 * reactive mode, that is: it returns a {@link Mono}<Mutation><BR/>
	 * This method offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace
	 * mode).<BR/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 *     @Autowired
	 *     MutationExecutor executor;
	 * 
	 *     void myMethod() {
	 * 	        Map<String, Object> params = new HashMap<>();
	 *          params.put("param", paramValue);   // param is optional, as it is marked by a "?" in the request
	 *          params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 *          
	 *          Mono<Mutation> mono = executor.execWithBindValues(
	 *              "mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}",
	 *              callback,
	 *              params);
	 *          Mutation mutation = mono.block();
	 *          FieldType field = mutation.getSampleQueryOrMutationField();
	 *
	 *          .... do something with this field's value
	 *     }
	 * }
	 * 
	 * 
	 * 
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("heroParam", heroParamValue);
	 * params.put("skip", Boolean.FALSE);
	 * 
	 * Mono<Mutation> mono = myQueryType.execWithBindValues(
	 * 		"{hero(param:?heroParam) @include(if:true) {id name @skip(if: ?skip) appearsIn friends {id name}}}",
	 * 		params);
	 * ...
	 * Mutation response = mono.block();
	 * Character c = response.getHero();
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the mutation, in the native GraphQL format (see here above).
	 * It must ommit the query/mutation/subscription keyword, and start by the first { that follows.It may contain
	 * directives, as explained in the GraphQL specs.
	 * @param parameters The map of values, for the bind variables defined in the query. If there is no bind variable in
	 * the defined Query, this argument may be null or an empty {@link Map}. The key is the parameter name, as defined
	 * in the query (in the above sample: heroParam is an optional parameter and skip is a mandatory one). The value is
	 * the parameter vale in its Java type (for instance a {@link java.util.Date} for the
	 * {@link GraphQLScalarTypeDate}). The parameters which value is missing in this map will no be transmitted toward
	 * the GraphQL server.
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	public Mono<Mutation> execWithBindValues(String queryResponseDef, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation {} ", queryResponseDef);
		ObjectResponse objectResponse = getResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return execWithBindValues(objectResponse, parameters);
	}

	/**
	 * This method takes a <B>full request</B> definition, and executes it against the GraphQL server. As this class is
	 * a mutation executor, the provided request must be a mutation full request. This request will be executed in
	 * reactive mode, that is: it returns a {@link Mono}<Mutation><BR/>
	 * This method offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace
	 * mode).<BR/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 *     @Autowired
	 *     MutationExecutor executor;
	 * 
	 *     void myMethod() {
	 *          Mono<Mutation> mono = executor.exec(
	 *              "mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}",
	 *              "param", paramValue,   // param is optional, as it is marked by a "?" in the request
	 *              "skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 *              );
	 *          Mutation mutation = mono.block();
	 *          FieldType field = mutation.getSampleQueryOrMutationField();
	 *
	 *          .... do something with this field's value
	 *     }
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above). It
	 * must ommit the query/mutation/subscription keyword, and start by the first { that follows.It may contain
	 * directives, as explained in the GraphQL specs.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	public Mono<Mutation> exec(String queryResponseDef, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation {} ", queryResponseDef);
		ObjectResponse objectResponse = getResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return execWithBindValues(objectResponse,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method takes a <B>full request</B> definition, and executes it against the GraphQL server. As this class is
	 * a mutation executor, the provided request must be a mutation full request. This request will be executed in
	 * reactive mode, that is: it returns a {@link Mono}<Mutation><BR/>
	 * This method offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace
	 * mode).<BR/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 *     &#64;Autowired
	 *     MutationExecutor executor;
	 *     
	 *     GraphQLRequest preparedRequest;
	 *     
	 *     @PostConstruct
	 *     public void setup() {
	 *         // Preparation of the query, so that it is prepared once then executed several times
	 *         preparedRequest = executor
	 *             .getResponseBuilder()
	 *             .withQueryResponseDef("mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}")
	 *             .build();
	 *     }
	 * 
	 *     void myMethod() {
	 * 	        Map<String, Object> params = new HashMap<>();
	 *          params.put("param", paramValue);   // param is optional, as it is marked by a "?" in the request
	 *          params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 *          
	 *          Mono<Mutation> mono = executor.execWithBindValues(
	 *              preparedRequest,
	 *              params);
	 *          Mutation mutation = mono.block();
	 *          FieldType field = mutation.getSampleQueryOrMutationField();
	 *
	 *          .... do something with this field's value
	 *     }
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGraphQLRequest(String)} method or one of the <code>getXxxxGraphQLRequest(String)</code> methods.
	 * @param parameters The list of values, for the bind variables defined in the query. If there is no bind variable
	 * in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	public Mono<Mutation> execWithBindValues(ObjectResponse objectResponse, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			if (parameters == null) {
				LOGGER.trace("Executing mutation without parameters");
			} else {
				StringBuilder sb = new StringBuilder("Executing root mutation with parameters: ");
				boolean addComma = false;
				for (String key : parameters.keySet()) {
					sb.append(key).append(":").append(parameters.get(key));
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
				LOGGER.trace(sb.toString());
			}
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'Mutation'");
		}

		return objectResponse.execReactive(Mutation.class, (parameters != null) ? parameters : new HashMap<>());
	}

	/**
	 * This method takes a <B>full request</B> definition, and executes it against the GraphQL server. As this class is
	 * a mutation executor, the provided request must be a mutation full request. This request will be executed in
	 * reactive mode, that is: it returns a {@link Mono}<Mutation><BR/>
	 * This method offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace
	 * mode).<BR/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 *     &#64;Autowired
	 *     MutationExecutor executor;
	 *     
	 *     GraphQLRequest preparedRequest;
	 *     
	 *     @PostConstruct
	 *     public void setup() {
	 *         // Preparation of the query, so that it is prepared once then executed several times
	 *         preparedRequest = executor
	 *             .getResponseBuilder()
	 *             .withQueryResponseDef("mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}")
	 *             .build();
	 *     }
	 * 
	 *     void myMethod() {
	 *          Mono<Mutation> mono = executor.exec(
	 *              preparedRequest,
	 *              "param", paramValue,   // param is optional, as it is marked by a "?" in the request
	 *              "skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 *              );
	 *          Mutation mutation = mono.block();
	 *          FieldType field = mutation.getSampleQueryOrMutationField();
	 *
	 *          .... do something with this field's value
	 *     }
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGraphQLRequest(String)} method or one of the <code>getXxxxGraphQLRequest(String)</code> methods.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	public Mono<Mutation> exec(ObjectResponse objectResponse, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		return execWithBindValues(objectResponse,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Get the {@link Builder} for a <B>full request</B>, as expected by the exec and execWithBindValues methods.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class);
	}

	/**
	 * Get the {@link GraphQLReactiveRequest} for <B>full request</B>. For instance:
	 * 
	 * <PRE>
	 * 
	 * GraphQLReactiveRequest request = new GraphQLRequest(fullRequest);
	 * </PRE>
	 * 
	 * @param fullRequest The full GraphQL Request, as specified in the GraphQL specification
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getGraphQLRequest(String fullRequest) throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(fullRequest);
	}

	/**
	 * Creates a new claim. This method executes a partial query against the GraphQL server. That is, the query that is
	 * one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the query that
	 * <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Claim> mono = executor.createClaimWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claim, // A value for createClaim's claim input parameter
	 * 			params);
	 * 		Claim field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param claim Parameter for the createClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Claim>> createClaimWithBindValues(String queryResponseDef, ClaimInput claim,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'createClaim': {} ", queryResponseDef);
		ObjectResponse objectResponse = getCreateClaimResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createClaimWithBindValues(objectResponse, claim, parameters);
	}

	/**
	 * Creates a new claim.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Claim> mono = executor.createClaim(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claim, // A value for createClaim's claim input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Claim field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param claim Parameter for the createClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Claim>> createClaim(String queryResponseDef, ClaimInput claim, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'createClaim': {} ", queryResponseDef);
		ObjectResponse objectResponse = getCreateClaimResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createClaimWithBindValues(objectResponse, claim,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Creates a new claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Claim> mono = executor.createClaimWithBindValues(preparedRequest, claim, // A value for
	 * 																						// createClaim's claim
	 * 																						// input parameter
	 * 			params);
	 * 		Claim field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateClaimGraphQLRequest(String)} method.
	 * @param claim Parameter for the createClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Claim>> createClaimWithBindValues(ObjectResponse objectResponse, ClaimInput claim,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'createClaim' with parameters: {} ", claim);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createClaim'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationCreateClaimClaim", claim);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getCreateClaim() == null) ? Optional.empty() : Optional.of(t.getCreateClaim()));
	}

	/**
	 * Creates a new claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Claim> mono = executor.createClaim(preparedRequest, claim, // A value for createClaim's claim input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Claim field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateClaimGraphQLRequest(String)} method.
	 * @param claim Parameter for the createClaim field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Claim>> createClaim(ObjectResponse objectResponse, ClaimInput claim, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'createClaim' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createClaim' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationCreateClaimClaim", claim);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getCreateClaim() == null) ? Optional.empty() : Optional.of(t.getCreateClaim()));
	}

	/**
	 * Creates a new claim.<br/>
	 * Get the {@link Builder} for the Claim, as expected by the createClaim query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreateClaimResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "createClaim", RequestType.mutation,
			InputParameter.newBindParameter("", "claim", "mutationCreateClaimClaim", MANDATORY, "ClaimInput", true, 0,
				false));
	}

	/**
	 * Creates a new claim.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the createClaim REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getCreateClaimGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createClaim",
			InputParameter.newBindParameter("", "claim", "mutationCreateClaimClaim", MANDATORY, "ClaimInput", true, 0,
				false));
	}

	/**
	 * Updates an existing claim. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Claim> mono = executor.updateClaimWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claim, // A value for updateClaim's claim input parameter
	 * 			params);
	 * 		Claim field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param claim Parameter for the updateClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Claim>> updateClaimWithBindValues(String queryResponseDef, ClaimInput claim,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'updateClaim': {} ", queryResponseDef);
		ObjectResponse objectResponse = getUpdateClaimResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateClaimWithBindValues(objectResponse, claim, parameters);
	}

	/**
	 * Updates an existing claim.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Claim> mono = executor.updateClaim(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claim, // A value for updateClaim's claim input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Claim field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param claim Parameter for the updateClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Claim>> updateClaim(String queryResponseDef, ClaimInput claim, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'updateClaim': {} ", queryResponseDef);
		ObjectResponse objectResponse = getUpdateClaimResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateClaimWithBindValues(objectResponse, claim,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Claim> mono = executor.updateClaimWithBindValues(preparedRequest, claim, // A value for
	 * 																						// updateClaim's claim
	 * 																						// input parameter
	 * 			params);
	 * 		Claim field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateClaimGraphQLRequest(String)} method.
	 * @param claim Parameter for the updateClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Claim>> updateClaimWithBindValues(ObjectResponse objectResponse, ClaimInput claim,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'updateClaim' with parameters: {} ", claim);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updateClaim'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdateClaimClaim", claim);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getUpdateClaim() == null) ? Optional.empty() : Optional.of(t.getUpdateClaim()));
	}

	/**
	 * Updates an existing claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Claim> mono = executor.updateClaim(preparedRequest, claim, // A value for updateClaim's claim input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Claim field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateClaimGraphQLRequest(String)} method.
	 * @param claim Parameter for the updateClaim field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Claim>> updateClaim(ObjectResponse objectResponse, ClaimInput claim, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updateClaim' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updateClaim' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdateClaimClaim", claim);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getUpdateClaim() == null) ? Optional.empty() : Optional.of(t.getUpdateClaim()));
	}

	/**
	 * Updates an existing claim.<br/>
	 * Get the {@link Builder} for the Claim, as expected by the updateClaim query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdateClaimResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "updateClaim", RequestType.mutation,
			InputParameter.newBindParameter("", "claim", "mutationUpdateClaimClaim", MANDATORY, "ClaimInput", true, 0,
				false));
	}

	/**
	 * Updates an existing claim.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updateClaim REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdateClaimGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateClaim",
			InputParameter.newBindParameter("", "claim", "mutationUpdateClaimClaim", MANDATORY, "ClaimInput", true, 0,
				false));
	}

	/**
	 * Deletes an existing claim. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Claim> mono = executor.deleteClaimWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claimId, // A value for deleteClaim's claimId input parameter
	 * 			params);
	 * 		Claim field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param claimId Parameter for the deleteClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Claim>> deleteClaimWithBindValues(String queryResponseDef, Long claimId,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'deleteClaim': {} ", queryResponseDef);
		ObjectResponse objectResponse = getDeleteClaimResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteClaimWithBindValues(objectResponse, claimId, parameters);
	}

	/**
	 * Deletes an existing claim.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Claim> mono = executor.deleteClaim(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claimId, // A value for deleteClaim's claimId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Claim field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param claimId Parameter for the deleteClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Claim>> deleteClaim(String queryResponseDef, Long claimId, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'deleteClaim': {} ", queryResponseDef);
		ObjectResponse objectResponse = getDeleteClaimResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteClaimWithBindValues(objectResponse, claimId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Deletes an existing claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Claim> mono = executor.deleteClaimWithBindValues(preparedRequest, claimId, // A value for
	 * 																						// deleteClaim's claimId
	 * 																						// input parameter
	 * 			params);
	 * 		Claim field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteClaimGraphQLRequest(String)} method.
	 * @param claimId Parameter for the deleteClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Claim>> deleteClaimWithBindValues(ObjectResponse objectResponse, Long claimId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'deleteClaim' with parameters: {} ", claimId);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deleteClaim'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationDeleteClaimClaimId", claimId);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getDeleteClaim() == null) ? Optional.empty() : Optional.of(t.getDeleteClaim()));
	}

	/**
	 * Deletes an existing claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Claim> mono = executor.deleteClaim(preparedRequest, claimId, // A value for deleteClaim's claimId
	 * 																			// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Claim field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteClaimGraphQLRequest(String)} method.
	 * @param claimId Parameter for the deleteClaim field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Claim>> deleteClaim(ObjectResponse objectResponse, Long claimId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'deleteClaim' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deleteClaim' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationDeleteClaimClaimId", claimId);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getDeleteClaim() == null) ? Optional.empty() : Optional.of(t.getDeleteClaim()));
	}

	/**
	 * Deletes an existing claim.<br/>
	 * Get the {@link Builder} for the Claim, as expected by the deleteClaim query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeleteClaimResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "deleteClaim", RequestType.mutation,
			InputParameter.newBindParameter("", "claimId", "mutationDeleteClaimClaimId", MANDATORY, "ID", true, 0,
				false));
	}

	/**
	 * Deletes an existing claim.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the deleteClaim REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeleteClaimGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteClaim",
			InputParameter.newBindParameter("", "claimId", "mutationDeleteClaimClaimId", MANDATORY, "ID", true, 0,
				false));
	}

	/**
	 * Creates a new declaration. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Declaration> mono = executor.createDeclarationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declaration, // A value for createDeclaration's declaration input parameter
	 * 			params);
	 * 		Declaration field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param declaration Parameter for the createDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Declaration>> createDeclarationWithBindValues(String queryResponseDef,
		DeclarationInput declaration, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'createDeclaration': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getCreateDeclarationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createDeclarationWithBindValues(objectResponse, declaration, parameters);
	}

	/**
	 * Creates a new declaration.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Declaration> mono = executor.createDeclaration(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declaration, // A value for createDeclaration's declaration input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Declaration field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param declaration Parameter for the createDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Declaration>> createDeclaration(String queryResponseDef, DeclarationInput declaration,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'createDeclaration': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getCreateDeclarationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createDeclarationWithBindValues(objectResponse, declaration,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Creates a new declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Declaration> mono = executor.createDeclarationWithBindValues(preparedRequest, declaration, // A
	 * 																										// value
	 * 																										// for
	 * 																										// createDeclaration's
	 * 																										// declaration
	 * 																										// input
	 * 																										// parameter
	 * 			params);
	 * 		Declaration field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateDeclarationGraphQLRequest(String)} method.
	 * @param declaration Parameter for the createDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Declaration>> createDeclarationWithBindValues(ObjectResponse objectResponse,
		DeclarationInput declaration, Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'createDeclaration' with parameters: {} ", declaration);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createDeclaration'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationCreateDeclarationDeclaration", declaration);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getCreateDeclaration() == null) ? Optional.empty() : Optional.of(t.getCreateDeclaration()));
	}

	/**
	 * Creates a new declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Declaration> mono = executor.createDeclaration(preparedRequest, declaration, // A value for
	 * 																							// createDeclaration's
	 * 																							// declaration input
	 * 																							// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Declaration field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateDeclarationGraphQLRequest(String)} method.
	 * @param declaration Parameter for the createDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Declaration>> createDeclaration(ObjectResponse objectResponse, DeclarationInput declaration,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'createDeclaration' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createDeclaration' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationCreateDeclarationDeclaration", declaration);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getCreateDeclaration() == null) ? Optional.empty() : Optional.of(t.getCreateDeclaration()));
	}

	/**
	 * Creates a new declaration.<br/>
	 * Get the {@link Builder} for the Declaration, as expected by the createDeclaration query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreateDeclarationResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "createDeclaration", RequestType.mutation,
			InputParameter.newBindParameter("", "declaration", "mutationCreateDeclarationDeclaration", MANDATORY,
				"DeclarationInput", true, 0, false));
	}

	/**
	 * Creates a new declaration.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the createDeclaration REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getCreateDeclarationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createDeclaration",
			InputParameter.newBindParameter("", "declaration", "mutationCreateDeclarationDeclaration", MANDATORY,
				"DeclarationInput", true, 0, false));
	}

	/**
	 * Updates an existing declaration. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Declaration> mono = executor.updateDeclarationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declaration, // A value for updateDeclaration's declaration input parameter
	 * 			params);
	 * 		Declaration field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param declaration Parameter for the updateDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Declaration>> updateDeclarationWithBindValues(String queryResponseDef,
		DeclarationInput declaration, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'updateDeclaration': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getUpdateDeclarationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateDeclarationWithBindValues(objectResponse, declaration, parameters);
	}

	/**
	 * Updates an existing declaration.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Declaration> mono = executor.updateDeclaration(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declaration, // A value for updateDeclaration's declaration input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Declaration field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param declaration Parameter for the updateDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Declaration>> updateDeclaration(String queryResponseDef, DeclarationInput declaration,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'updateDeclaration': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getUpdateDeclarationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateDeclarationWithBindValues(objectResponse, declaration,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Declaration> mono = executor.updateDeclarationWithBindValues(preparedRequest, declaration, // A
	 * 																										// value
	 * 																										// for
	 * 																										// updateDeclaration's
	 * 																										// declaration
	 * 																										// input
	 * 																										// parameter
	 * 			params);
	 * 		Declaration field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateDeclarationGraphQLRequest(String)} method.
	 * @param declaration Parameter for the updateDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Declaration>> updateDeclarationWithBindValues(ObjectResponse objectResponse,
		DeclarationInput declaration, Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'updateDeclaration' with parameters: {} ", declaration);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updateDeclaration'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdateDeclarationDeclaration", declaration);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getUpdateDeclaration() == null) ? Optional.empty() : Optional.of(t.getUpdateDeclaration()));
	}

	/**
	 * Updates an existing declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Declaration> mono = executor.updateDeclaration(preparedRequest, declaration, // A value for
	 * 																							// updateDeclaration's
	 * 																							// declaration input
	 * 																							// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Declaration field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateDeclarationGraphQLRequest(String)} method.
	 * @param declaration Parameter for the updateDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Declaration>> updateDeclaration(ObjectResponse objectResponse, DeclarationInput declaration,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updateDeclaration' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updateDeclaration' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdateDeclarationDeclaration", declaration);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getUpdateDeclaration() == null) ? Optional.empty() : Optional.of(t.getUpdateDeclaration()));
	}

	/**
	 * Updates an existing declaration.<br/>
	 * Get the {@link Builder} for the Declaration, as expected by the updateDeclaration query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdateDeclarationResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "updateDeclaration", RequestType.mutation,
			InputParameter.newBindParameter("", "declaration", "mutationUpdateDeclarationDeclaration", MANDATORY,
				"DeclarationInput", true, 0, false));
	}

	/**
	 * Updates an existing declaration.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updateDeclaration REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdateDeclarationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateDeclaration",
			InputParameter.newBindParameter("", "declaration", "mutationUpdateDeclarationDeclaration", MANDATORY,
				"DeclarationInput", true, 0, false));
	}

	/**
	 * Deletes an existing declaration. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Declaration> mono = executor.deleteDeclarationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declarationId, // A value for deleteDeclaration's declarationId input parameter
	 * 			params);
	 * 		Declaration field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param declarationId Parameter for the deleteDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Declaration>> deleteDeclarationWithBindValues(String queryResponseDef, Long declarationId,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'deleteDeclaration': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getDeleteDeclarationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteDeclarationWithBindValues(objectResponse, declarationId, parameters);
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Declaration> mono = executor.deleteDeclaration(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declarationId, // A value for deleteDeclaration's declarationId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Declaration field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param declarationId Parameter for the deleteDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Declaration>> deleteDeclaration(String queryResponseDef, Long declarationId,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'deleteDeclaration': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getDeleteDeclarationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteDeclarationWithBindValues(objectResponse, declarationId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Declaration> mono = executor.deleteDeclarationWithBindValues(preparedRequest, declarationId, // A
	 * 																											// value
	 * 																											// for
	 * 																											// deleteDeclaration's
	 * 																											// declarationId
	 * 																											// input
	 * 																											// parameter
	 * 			params);
	 * 		Declaration field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteDeclarationGraphQLRequest(String)} method.
	 * @param declarationId Parameter for the deleteDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Declaration>> deleteDeclarationWithBindValues(ObjectResponse objectResponse,
		Long declarationId, Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'deleteDeclaration' with parameters: {} ", declarationId);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deleteDeclaration'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationDeleteDeclarationDeclarationId", declarationId);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getDeleteDeclaration() == null) ? Optional.empty() : Optional.of(t.getDeleteDeclaration()));
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Declaration> mono = executor.deleteDeclaration(preparedRequest, declarationId, // A value for
	 * 																							// deleteDeclaration's
	 * 																							// declarationId
	 * 																							// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Declaration field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteDeclarationGraphQLRequest(String)} method.
	 * @param declarationId Parameter for the deleteDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Declaration>> deleteDeclaration(ObjectResponse objectResponse, Long declarationId,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'deleteDeclaration' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deleteDeclaration' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationDeleteDeclarationDeclarationId", declarationId);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getDeleteDeclaration() == null) ? Optional.empty() : Optional.of(t.getDeleteDeclaration()));
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * Get the {@link Builder} for the Declaration, as expected by the deleteDeclaration query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeleteDeclarationResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "deleteDeclaration", RequestType.mutation,
			InputParameter.newBindParameter("", "declarationId", "mutationDeleteDeclarationDeclarationId", MANDATORY,
				"ID", true, 0, false));
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the deleteDeclaration REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeleteDeclarationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteDeclaration",
			InputParameter.newBindParameter("", "declarationId", "mutationDeleteDeclarationDeclarationId", MANDATORY,
				"ID", true, 0, false));
	}

	/**
	 * Creates an entity link. This method executes a partial query against the GraphQL server. That is, the query that
	 * is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the query
	 * that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<EntityLink> mono = executor.createEntityLinkWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			link, // A value for createEntityLink's link input parameter
	 * 			params);
	 * 		EntityLink field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param link Parameter for the createEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public Mono<Optional<EntityLink>> createEntityLinkWithBindValues(String queryResponseDef, EntityLinkInput link,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'createEntityLink': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getCreateEntityLinkResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createEntityLinkWithBindValues(objectResponse, link, parameters);
	}

	/**
	 * Creates an entity link.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<EntityLink> mono = executor.createEntityLink(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			link, // A value for createEntityLink's link input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		EntityLink field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param link Parameter for the createEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public Mono<Optional<EntityLink>> createEntityLink(String queryResponseDef, EntityLinkInput link,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'createEntityLink': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getCreateEntityLinkResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createEntityLinkWithBindValues(objectResponse, link,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Creates an entity link.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateEntityLinkGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<EntityLink> mono = executor.createEntityLinkWithBindValues(preparedRequest, entityLink, // A value
	 * 																										// for
	 * 			// createEntityLink's
	 * 			// entityLink input
	 * 			// parameter
	 * 			params);
	 * 		EntityLink field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateEntityLinkGraphQLRequest(String)} method.
	 * @param entityLink Parameter for the createEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public Mono<Optional<EntityLink>> createEntityLinkWithBindValues(ObjectResponse objectResponse,
		EntityLinkInput entityLink, Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'createEntityLink' with parameters: {} ", entityLink);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createEntityLink'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationCreateEntityLinkEntityLink", entityLink);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getCreateEntityLink() == null) ? Optional.empty() : Optional.of(t.getCreateEntityLink()));
	}

	/**
	 * Creates an entity link.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateEntityLinkGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<EntityLink> mono = executor.createEntityLink(preparedRequest, link, // A value for
	 * 																					// createEntityLink's link
	 * 																					// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		EntityLink field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateEntityLinkGraphQLRequest(String)} method.
	 * @param entityLink Parameter for the createEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public Mono<Optional<EntityLink>> createEntityLink(ObjectResponse objectResponse, EntityLinkInput entityLink,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'createEntityLink' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createEntityLink' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationCreateEntityLinkEntityLink", entityLink);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getCreateEntityLink() == null) ? Optional.empty() : Optional.of(t.getCreateEntityLink()));
	}

	/**
	 * Creates an entity link.<br/>
	 * Get the {@link Builder} for the EntityLink, as expected by the createEntityLink query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreateEntityLinkResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "createEntityLink", RequestType.mutation,
			InputParameter.newBindParameter("", "entityLink", "mutationCreateEntityLinkEntityLink", MANDATORY,
				"EntityLinkInput", true, 0, false));
	}

	/**
	 * Creates an entity link.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the createEntityLink REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getCreateEntityLinkGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createEntityLink",
			InputParameter.newBindParameter("", "entityLink", "mutationCreateEntityLinkEntityLink", MANDATORY,
				"EntityLinkInput", true, 0, false));
	}

	/**
	 * Updates an existing entity link. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<EntityLink> mono = executor.updateEntityLinkWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			entityLink, // A value for updateEntityLink's entityLink input parameter
	 * 			params);
	 * 		EntityLink field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param entityLink Parameter for the updateEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public Mono<Optional<EntityLink>> updateEntityLinkWithBindValues(String queryResponseDef,
		EntityLinkInput entityLink, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'updateEntityLink': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getUpdateEntityLinkResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateEntityLinkWithBindValues(objectResponse, entityLink, parameters);
	}

	/**
	 * Updates an existing entity link.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<EntityLink> mono = executor.updateEntityLink(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			entityLink, // A value for updateEntityLink's entityLink input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		EntityLink field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param entityLink Parameter for the updateEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public Mono<Optional<EntityLink>> updateEntityLink(String queryResponseDef, EntityLinkInput entityLink,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'updateEntityLink': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getUpdateEntityLinkResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateEntityLinkWithBindValues(objectResponse, entityLink,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing entity link.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateEntityLinkGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<EntityLink> mono = executor.updateEntityLinkWithBindValues(preparedRequest, entityLink, // A value
	 * 																										// for
	 * 																										// updateEntityLink's
	 * 																										// entityLink
	 * 																										// input
	 * 																										// parameter
	 * 			params);
	 * 		EntityLink field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateEntityLinkGraphQLRequest(String)} method.
	 * @param entityLink Parameter for the updateEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public Mono<Optional<EntityLink>> updateEntityLinkWithBindValues(ObjectResponse objectResponse,
		EntityLinkInput entityLink, Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'updateEntityLink' with parameters: {} ", entityLink);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updateEntityLink'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdateEntityLinkEntityLink", entityLink);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getUpdateEntityLink() == null) ? Optional.empty() : Optional.of(t.getUpdateEntityLink()));
	}

	/**
	 * Updates an existing entity link.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateEntityLinkGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<EntityLink> mono = executor.updateEntityLink(preparedRequest, entityLink, // A value for
	 * 																						// updateEntityLink's
	 * 																						// entityLink input
	 * 																						// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		EntityLink field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateEntityLinkGraphQLRequest(String)} method.
	 * @param entityLink Parameter for the updateEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public Mono<Optional<EntityLink>> updateEntityLink(ObjectResponse objectResponse, EntityLinkInput entityLink,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updateEntityLink' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updateEntityLink' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdateEntityLinkEntityLink", entityLink);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getUpdateEntityLink() == null) ? Optional.empty() : Optional.of(t.getUpdateEntityLink()));
	}

	/**
	 * Updates an existing entity link.<br/>
	 * Get the {@link Builder} for the EntityLink, as expected by the updateEntityLink query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdateEntityLinkResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "updateEntityLink", RequestType.mutation,
			InputParameter.newBindParameter("", "entityLink", "mutationUpdateEntityLinkEntityLink", MANDATORY,
				"EntityLinkInput", true, 0, false));
	}

	/**
	 * Updates an existing entity link.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updateEntityLink REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdateEntityLinkGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateEntityLink",
			InputParameter.newBindParameter("", "entityLink", "mutationUpdateEntityLinkEntityLink", MANDATORY,
				"EntityLinkInput", true, 0, false));
	}

	/**
	 * Deletes an entity link. This method executes a partial query against the GraphQL server. That is, the query that
	 * is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the query
	 * that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<EntityLink> mono = executor.deleteEntityLinkWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			entityLinkId, // A value for deleteEntityLink's entityLinkId input parameter
	 * 			params);
	 * 		EntityLink field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param entityLinkId Parameter for the deleteEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "deleteEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public Mono<Optional<EntityLink>> deleteEntityLinkWithBindValues(String queryResponseDef, Long entityLinkId,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'deleteEntityLink': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getDeleteEntityLinkResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteEntityLinkWithBindValues(objectResponse, entityLinkId, parameters);
	}

	/**
	 * Deletes an entity link.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<EntityLink> mono = executor.deleteEntityLink(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			entityLinkId, // A value for deleteEntityLink's entityLinkId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		EntityLink field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param entityLinkId Parameter for the deleteEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "deleteEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public Mono<Optional<EntityLink>> deleteEntityLink(String queryResponseDef, Long entityLinkId,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'deleteEntityLink': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getDeleteEntityLinkResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteEntityLinkWithBindValues(objectResponse, entityLinkId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Deletes an entity link.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteEntityLinkGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<EntityLink> mono = executor.deleteEntityLinkWithBindValues(preparedRequest, entityLinkId, // A value
	 * 																										// for
	 * 																										// deleteEntityLink's
	 * 																										// entityLinkId
	 * 																										// input
	 * 																										// parameter
	 * 			params);
	 * 		EntityLink field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteEntityLinkGraphQLRequest(String)} method.
	 * @param entityLinkId Parameter for the deleteEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "deleteEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public Mono<Optional<EntityLink>> deleteEntityLinkWithBindValues(ObjectResponse objectResponse, Long entityLinkId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'deleteEntityLink' with parameters: {} ", entityLinkId);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deleteEntityLink'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationDeleteEntityLinkEntityLinkId", entityLinkId);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getDeleteEntityLink() == null) ? Optional.empty() : Optional.of(t.getDeleteEntityLink()));
	}

	/**
	 * Deletes an entity link.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteEntityLinkGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<EntityLink> mono = executor.deleteEntityLink(preparedRequest, entityLinkId, // A value for
	 * 			// deleteEntityLink's entityLinkId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		EntityLink field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteEntityLinkGraphQLRequest(String)} method.
	 * @param entityLinkId Parameter for the deleteEntityLink field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "deleteEntityLink", graphQLTypeSimpleName = "EntityLink",
		javaClass = EntityLink.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[LNK]" })
	public Mono<Optional<EntityLink>> deleteEntityLink(ObjectResponse objectResponse, Long entityLinkId,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'deleteEntityLink' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deleteEntityLink' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationDeleteEntityLinkEntityLinkId", entityLinkId);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getDeleteEntityLink() == null) ? Optional.empty() : Optional.of(t.getDeleteEntityLink()));
	}

	/**
	 * Deletes an entity link.<br/>
	 * Get the {@link Builder} for the EntityLink, as expected by the deleteEntityLink query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeleteEntityLinkResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "deleteEntityLink", RequestType.mutation,
			InputParameter.newBindParameter("", "entityLinkId", "mutationDeleteEntityLinkEntityLinkId", MANDATORY,
				"Long", true, 0, false));
	}

	/**
	 * Deletes an entity link.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the deleteEntityLink REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeleteEntityLinkGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteEntityLink",
			InputParameter.newBindParameter("", "entityLinkId", "mutationDeleteEntityLinkEntityLinkId", MANDATORY,
				"Long", true, 0, false));
	}

	/**
	 * Create a new journal. This method executes a partial query against the GraphQL server. That is, the query that is
	 * one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the query that
	 * <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Journal> mono = executor.createJournalWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journal, // A value for createJournal's journal input parameter
	 * 			params);
	 * 		Journal field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param journal Parameter for the createJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Journal>> createJournalWithBindValues(String queryResponseDef, JournalInput journal,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'createJournal': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getCreateJournalResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createJournalWithBindValues(objectResponse, journal, parameters);
	}

	/**
	 * Create a new journal.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Journal> mono = executor.createJournal(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journal, // A value for createJournal's journal input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Journal field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param journal Parameter for the createJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Journal>> createJournal(String queryResponseDef, JournalInput journal,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'createJournal': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getCreateJournalResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createJournalWithBindValues(objectResponse, journal,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Create a new journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Journal> mono = executor.createJournalWithBindValues(preparedRequest, journal, // A value for
	 * 																							// createJournal's
	 * 																							// journal input
	 * 																							// parameter
	 * 			params);
	 * 		Journal field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateJournalGraphQLRequest(String)} method.
	 * @param journal Parameter for the createJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Journal>> createJournalWithBindValues(ObjectResponse objectResponse, JournalInput journal,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'createJournal' with parameters: {} ", journal);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createJournal'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationCreateJournalJournal", journal);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getCreateJournal() == null) ? Optional.empty() : Optional.of(t.getCreateJournal()));
	}

	/**
	 * Create a new journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Journal> mono = executor.createJournal(preparedRequest, journal, // A value for createJournal's
	 * 																				// journal input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Journal field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateJournalGraphQLRequest(String)} method.
	 * @param journal Parameter for the createJournal field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Journal>> createJournal(ObjectResponse objectResponse, JournalInput journal,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'createJournal' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createJournal' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationCreateJournalJournal", journal);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getCreateJournal() == null) ? Optional.empty() : Optional.of(t.getCreateJournal()));
	}

	/**
	 * Create a new journal.<br/>
	 * Get the {@link Builder} for the Journal, as expected by the createJournal query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreateJournalResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "createJournal", RequestType.mutation,
			InputParameter.newBindParameter("", "journal", "mutationCreateJournalJournal", MANDATORY, "JournalInput",
				true, 0, false));
	}

	/**
	 * Create a new journal.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the createJournal REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getCreateJournalGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createJournal",
			InputParameter.newBindParameter("", "journal", "mutationCreateJournalJournal", MANDATORY, "JournalInput",
				true, 0, false));
	}

	/**
	 * Updates an existing journal. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Journal> mono = executor.updateJournalWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journal, // A value for updateJournal's journal input parameter
	 * 			params);
	 * 		Journal field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param journal Parameter for the updateJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Journal>> updateJournalWithBindValues(String queryResponseDef, JournalInput journal,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'updateJournal': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getUpdateJournalResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateJournalWithBindValues(objectResponse, journal, parameters);
	}

	/**
	 * Updates an existing journal.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Journal> mono = executor.updateJournal(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journal, // A value for updateJournal's journal input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Journal field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param journal Parameter for the updateJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Journal>> updateJournal(String queryResponseDef, JournalInput journal,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'updateJournal': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getUpdateJournalResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateJournalWithBindValues(objectResponse, journal,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Journal> mono = executor.updateJournalWithBindValues(preparedRequest, journal, // A value for
	 * 																							// updateJournal's
	 * 																							// journal input
	 * 																							// parameter
	 * 			params);
	 * 		Journal field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateJournalGraphQLRequest(String)} method.
	 * @param journal Parameter for the updateJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Journal>> updateJournalWithBindValues(ObjectResponse objectResponse, JournalInput journal,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'updateJournal' with parameters: {} ", journal);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updateJournal'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdateJournalJournal", journal);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getUpdateJournal() == null) ? Optional.empty() : Optional.of(t.getUpdateJournal()));
	}

	/**
	 * Updates an existing journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Journal> mono = executor.updateJournal(preparedRequest, journal, // A value for updateJournal's
	 * 																				// journal input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Journal field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateJournalGraphQLRequest(String)} method.
	 * @param journal Parameter for the updateJournal field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Journal>> updateJournal(ObjectResponse objectResponse, JournalInput journal,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updateJournal' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updateJournal' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdateJournalJournal", journal);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getUpdateJournal() == null) ? Optional.empty() : Optional.of(t.getUpdateJournal()));
	}

	/**
	 * Updates an existing journal.<br/>
	 * Get the {@link Builder} for the Journal, as expected by the updateJournal query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdateJournalResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "updateJournal", RequestType.mutation,
			InputParameter.newBindParameter("", "journal", "mutationUpdateJournalJournal", MANDATORY, "JournalInput",
				true, 0, false));
	}

	/**
	 * Updates an existing journal.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updateJournal REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdateJournalGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateJournal",
			InputParameter.newBindParameter("", "journal", "mutationUpdateJournalJournal", MANDATORY, "JournalInput",
				true, 0, false));
	}

	/**
	 * Deletes an existing journal. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Journal> mono = executor.deleteJournalWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journalId, // A value for deleteJournal's journalId input parameter
	 * 			params);
	 * 		Journal field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param journalId Parameter for the deleteJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Journal>> deleteJournalWithBindValues(String queryResponseDef, Long journalId,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'deleteJournal': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getDeleteJournalResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteJournalWithBindValues(objectResponse, journalId, parameters);
	}

	/**
	 * Deletes an existing journal.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Journal> mono = executor.deleteJournal(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journalId, // A value for deleteJournal's journalId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Journal field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param journalId Parameter for the deleteJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Journal>> deleteJournal(String queryResponseDef, Long journalId, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'deleteJournal': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getDeleteJournalResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteJournalWithBindValues(objectResponse, journalId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Deletes an existing journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Journal> mono = executor.deleteJournalWithBindValues(preparedRequest, journalId, // A value for
	 * 																								// deleteJournal's
	 * 																								// journalId
	 * 																								// input
	 * 																								// parameter
	 * 			params);
	 * 		Journal field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteJournalGraphQLRequest(String)} method.
	 * @param journalId Parameter for the deleteJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Journal>> deleteJournalWithBindValues(ObjectResponse objectResponse, Long journalId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'deleteJournal' with parameters: {} ", journalId);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deleteJournal'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationDeleteJournalJournalId", journalId);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getDeleteJournal() == null) ? Optional.empty() : Optional.of(t.getDeleteJournal()));
	}

	/**
	 * Deletes an existing journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Journal> mono = executor.deleteJournal(preparedRequest, journalId, // A value for deleteJournal's
	 * 																				// journalId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Journal field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteJournalGraphQLRequest(String)} method.
	 * @param journalId Parameter for the deleteJournal field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Journal>> deleteJournal(ObjectResponse objectResponse, Long journalId,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'deleteJournal' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deleteJournal' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationDeleteJournalJournalId", journalId);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getDeleteJournal() == null) ? Optional.empty() : Optional.of(t.getDeleteJournal()));
	}

	/**
	 * Deletes an existing journal.<br/>
	 * Get the {@link Builder} for the Journal, as expected by the deleteJournal query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeleteJournalResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "deleteJournal", RequestType.mutation,
			InputParameter.newBindParameter("", "journalId", "mutationDeleteJournalJournalId", MANDATORY, "ID", true, 0,
				false));
	}

	/**
	 * Deletes an existing journal.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the deleteJournal REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeleteJournalGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteJournal",
			InputParameter.newBindParameter("", "journalId", "mutationDeleteJournalJournalId", MANDATORY, "ID", true, 0,
				false));
	}

	/**
	 * Creates a new person. This method executes a partial query against the GraphQL server. That is, the query that is
	 * one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the query that
	 * <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Person> mono = executor.createPersonWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			person, // A value for createPerson's person input parameter
	 * 			params);
	 * 		Person field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param person Parameter for the createPerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Person>> createPersonWithBindValues(String queryResponseDef, PersonInput person,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'createPerson': {} ", queryResponseDef);
		ObjectResponse objectResponse = getCreatePersonResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createPersonWithBindValues(objectResponse, person, parameters);
	}

	/**
	 * Creates a new person.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Person> mono = executor.createPerson(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			person, // A value for createPerson's person input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Person field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param person Parameter for the createPerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Person>> createPerson(String queryResponseDef, PersonInput person, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'createPerson': {} ", queryResponseDef);
		ObjectResponse objectResponse = getCreatePersonResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createPersonWithBindValues(objectResponse, person,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Creates a new person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Person> mono = executor.createPersonWithBindValues(preparedRequest, person, // A value for
	 * 																							// createPerson's
	 * 																							// person input
	 * 																							// parameter
	 * 			params);
	 * 		Person field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePersonGraphQLRequest(String)} method.
	 * @param person Parameter for the createPerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Person>> createPersonWithBindValues(ObjectResponse objectResponse, PersonInput person,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'createPerson' with parameters: {} ", person);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createPerson'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationCreatePersonPerson", person);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getCreatePerson() == null) ? Optional.empty() : Optional.of(t.getCreatePerson()));
	}

	/**
	 * Creates a new person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Person> mono = executor.createPerson(preparedRequest, person, // A value for createPerson's person
	 * 																			// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Person field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePersonGraphQLRequest(String)} method.
	 * @param person Parameter for the createPerson field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Person>> createPerson(ObjectResponse objectResponse, PersonInput person,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'createPerson' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createPerson' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationCreatePersonPerson", person);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getCreatePerson() == null) ? Optional.empty() : Optional.of(t.getCreatePerson()));
	}

	/**
	 * Creates a new person.<br/>
	 * Get the {@link Builder} for the Person, as expected by the createPerson query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreatePersonResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "createPerson", RequestType.mutation,
			InputParameter.newBindParameter("", "person", "mutationCreatePersonPerson", MANDATORY, "PersonInput", true,
				0, false));
	}

	/**
	 * Creates a new person.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the createPerson REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getCreatePersonGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createPerson",
			InputParameter.newBindParameter("", "person", "mutationCreatePersonPerson", MANDATORY, "PersonInput", true,
				0, false));
	}

	/**
	 * Updates an existing person. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Person> mono = executor.updatePersonWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			person, // A value for updatePerson's person input parameter
	 * 			params);
	 * 		Person field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param person Parameter for the updatePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Person>> updatePersonWithBindValues(String queryResponseDef, PersonInput person,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'updatePerson': {} ", queryResponseDef);
		ObjectResponse objectResponse = getUpdatePersonResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updatePersonWithBindValues(objectResponse, person, parameters);
	}

	/**
	 * Updates an existing person.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Person> mono = executor.updatePerson(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			person, // A value for updatePerson's person input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Person field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param person Parameter for the updatePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Person>> updatePerson(String queryResponseDef, PersonInput person, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'updatePerson': {} ", queryResponseDef);
		ObjectResponse objectResponse = getUpdatePersonResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updatePersonWithBindValues(objectResponse, person,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Person> mono = executor.updatePersonWithBindValues(preparedRequest, person, // A value for
	 * 																							// updatePerson's
	 * 																							// person input
	 * 																							// parameter
	 * 			params);
	 * 		Person field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePersonGraphQLRequest(String)} method.
	 * @param person Parameter for the updatePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Person>> updatePersonWithBindValues(ObjectResponse objectResponse, PersonInput person,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'updatePerson' with parameters: {} ", person);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updatePerson'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdatePersonPerson", person);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getUpdatePerson() == null) ? Optional.empty() : Optional.of(t.getUpdatePerson()));
	}

	/**
	 * Updates an existing person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Person> mono = executor.updatePerson(preparedRequest, person, // A value for updatePerson's person
	 * 																			// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Person field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePersonGraphQLRequest(String)} method.
	 * @param person Parameter for the updatePerson field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Person>> updatePerson(ObjectResponse objectResponse, PersonInput person,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updatePerson' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updatePerson' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdatePersonPerson", person);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getUpdatePerson() == null) ? Optional.empty() : Optional.of(t.getUpdatePerson()));
	}

	/**
	 * Updates an existing person.<br/>
	 * Get the {@link Builder} for the Person, as expected by the updatePerson query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdatePersonResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "updatePerson", RequestType.mutation,
			InputParameter.newBindParameter("", "person", "mutationUpdatePersonPerson", MANDATORY, "PersonInput", true,
				0, false));
	}

	/**
	 * Updates an existing person.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updatePerson REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdatePersonGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updatePerson",
			InputParameter.newBindParameter("", "person", "mutationUpdatePersonPerson", MANDATORY, "PersonInput", true,
				0, false));
	}

	/**
	 * Deletes an existing person. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Journal> mono = executor.deletePersonWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			personId, // A value for deletePerson's personId input parameter
	 * 			params);
	 * 		Journal field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param personId Parameter for the deletePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Person>> deletePersonWithBindValues(String queryResponseDef, Long personId,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'deletePerson': {} ", queryResponseDef);
		ObjectResponse objectResponse = getDeletePersonResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deletePersonWithBindValues(objectResponse, personId, parameters);
	}

	/**
	 * Deletes an existing person.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Person> mono = executor.deletePerson(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			personId, // A value for deletePerson's personId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Person field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param personId Parameter for the deletePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Person>> deletePerson(String queryResponseDef, Long personId, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'deletePerson': {} ", queryResponseDef);
		ObjectResponse objectResponse = getDeletePersonResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deletePersonWithBindValues(objectResponse, personId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Deletes an existing person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Person> mono = executor.deletePersonWithBindValues(preparedRequest, personId, // A value for
	 * 																							// deletePerson's
	 * 																							// personId input
	 * 																							// parameter
	 * 			params);
	 * 		Person field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePersonGraphQLRequest(String)} method.
	 * @param personId Parameter for the deletePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Person>> deletePersonWithBindValues(ObjectResponse objectResponse, Long personId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'deletePerson' with parameters: {} ", personId);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deletePerson'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationDeletePersonPersonId", personId);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getDeletePerson() == null) ? Optional.empty() : Optional.of(t.getDeletePerson()));
	}

	/**
	 * Deletes an existing person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Person> mono = executor.deletePerson(preparedRequest, personId, // A value for deletePerson's
	 * 																				// personId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Person field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePersonGraphQLRequest(String)} method.
	 * @param personId Parameter for the deletePerson field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Person>> deletePerson(ObjectResponse objectResponse, Long personId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'deletePerson' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deletePerson' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationDeletePersonPersonId", personId);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getDeletePerson() == null) ? Optional.empty() : Optional.of(t.getDeletePerson()));
	}

	/**
	 * Deletes an existing person.<br/>
	 * Get the {@link Builder} for the Person, as expected by the deletePerson query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeletePersonResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "deletePerson", RequestType.mutation,
			InputParameter.newBindParameter("", "personId", "mutationDeletePersonPersonId", MANDATORY, "ID", true, 0,
				false));
	}

	/**
	 * Deletes an existing person.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the deletePerson REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeletePersonGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deletePerson",
			InputParameter.newBindParameter("", "personId", "mutationDeletePersonPersonId", MANDATORY, "ID", true, 0,
				false));
	}

	/**
	 * Creates a new publication. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Publication> mono = executor.createPublicationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publication, // A value for createPublication's publication input parameter
	 * 			params);
	 * 		Publication field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publication Parameter for the createPublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Publication>> createPublicationWithBindValues(String queryResponseDef,
		PublicationInput publication, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'createPublication': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getCreatePublicationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createPublicationWithBindValues(objectResponse, publication, parameters);
	}

	/**
	 * Creates a new publication.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.createPublication(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publication, // A value for createPublication's publication input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publication field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param publication Parameter for the createPublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Publication>> createPublication(String queryResponseDef, PublicationInput publication,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'createPublication': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getCreatePublicationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createPublicationWithBindValues(objectResponse, publication,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Creates a new publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.createPublicationWithBindValues(preparedRequest, publication, // A
	 * 																										// value
	 * 																										// for
	 * 																										// createPublication's
	 * 																										// publication
	 * 																										// input
	 * 																										// parameter
	 * 			params);
	 * 		Publication field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePublicationGraphQLRequest(String)} method.
	 * @param publication Parameter for the createPublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Publication>> createPublicationWithBindValues(ObjectResponse objectResponse,
		PublicationInput publication, Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'createPublication' with parameters: {} ", publication);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createPublication'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationCreatePublicationPublication", publication);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getCreatePublication() == null) ? Optional.empty() : Optional.of(t.getCreatePublication()));
	}

	/**
	 * Creates a new publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.createPublication(preparedRequest, publication, // A value for
	 * 																							// createPublication's
	 * 																							// publication input
	 * 																							// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publication field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePublicationGraphQLRequest(String)} method.
	 * @param publication Parameter for the createPublication field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Publication>> createPublication(ObjectResponse objectResponse, PublicationInput publication,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'createPublication' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createPublication' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationCreatePublicationPublication", publication);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getCreatePublication() == null) ? Optional.empty() : Optional.of(t.getCreatePublication()));
	}

	/**
	 * Creates a new publication.<br/>
	 * Get the {@link Builder} for the Publication, as expected by the createPublication query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreatePublicationResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "createPublication", RequestType.mutation,
			InputParameter.newBindParameter("", "publication", "mutationCreatePublicationPublication", MANDATORY,
				"PublicationInput", true, 0, false));
	}

	/**
	 * Creates a new publication.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the createPublication REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getCreatePublicationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createPublication",
			InputParameter.newBindParameter("", "publication", "mutationCreatePublicationPublication", MANDATORY,
				"PublicationInput", true, 0, false));
	}

	/**
	 * Updates an existing publication. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Publication> mono = executor.updatePublicationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publication, // A value for updatePublication's publication input parameter
	 * 			params);
	 * 		Publication field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publication Parameter for the updatePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Publication>> updatePublicationWithBindValues(String queryResponseDef,
		PublicationInput publication, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'updatePublication': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getUpdatePublicationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updatePublicationWithBindValues(objectResponse, publication, parameters);
	}

	/**
	 * Updates an existing publication.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.updatePublication(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publication, // A value for updatePublication's publication input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publication field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param publication Parameter for the updatePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Publication>> updatePublication(String queryResponseDef, PublicationInput publication,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'updatePublication': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getUpdatePublicationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updatePublicationWithBindValues(objectResponse, publication,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.updatePublicationWithBindValues(preparedRequest, publication, // A
	 * 																										// value
	 * 																										// for
	 * 																										// updatePublication's
	 * 																										// publication
	 * 																										// input
	 * 																										// parameter
	 * 			params);
	 * 		Publication field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePublicationGraphQLRequest(String)} method.
	 * @param publication Parameter for the updatePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Publication>> updatePublicationWithBindValues(ObjectResponse objectResponse,
		PublicationInput publication, Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'updatePublication' with parameters: {} ", publication);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updatePublication'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdatePublicationPublication", publication);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getUpdatePublication() == null) ? Optional.empty() : Optional.of(t.getUpdatePublication()));
	}

	/**
	 * Updates an existing publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.updatePublication(preparedRequest, publication, // A value for
	 * 																							// updatePublication's
	 * 																							// publication input
	 * 																							// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publication field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePublicationGraphQLRequest(String)} method.
	 * @param publication Parameter for the updatePublication field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Publication>> updatePublication(ObjectResponse objectResponse, PublicationInput publication,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updatePublication' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updatePublication' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdatePublicationPublication", publication);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getUpdatePublication() == null) ? Optional.empty() : Optional.of(t.getUpdatePublication()));
	}

	/**
	 * Updates an existing publication.<br/>
	 * Get the {@link Builder} for the Publication, as expected by the updatePublication query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdatePublicationResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "updatePublication", RequestType.mutation,
			InputParameter.newBindParameter("", "publication", "mutationUpdatePublicationPublication", MANDATORY,
				"PublicationInput", true, 0, false));
	}

	/**
	 * Updates an existing publication.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updatePublication REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdatePublicationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updatePublication",
			InputParameter.newBindParameter("", "publication", "mutationUpdatePublicationPublication", MANDATORY,
				"PublicationInput", true, 0, false));
	}

	/**
	 * Deletes an existing publication. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Publication> mono = executor.deletePublicationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publicationId, // A value for deletePublication's publicationId input parameter
	 * 			params);
	 * 		Publication field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publicationId Parameter for the deletePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Publication>> deletePublicationWithBindValues(String queryResponseDef, Long publicationId,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'deletePublication': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getDeletePublicationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deletePublicationWithBindValues(objectResponse, publicationId, parameters);
	}

	/**
	 * Deletes an existing publication.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.deletePublication(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publicationId, // A value for deletePublication's publicationId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publication field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param publicationId Parameter for the deletePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Publication>> deletePublication(String queryResponseDef, Long publicationId,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'deletePublication': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getDeletePublicationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deletePublicationWithBindValues(objectResponse, publicationId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Deletes an existing publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.deletePublicationWithBindValues(preparedRequest, publicationId, // A
	 * 																											// value
	 * 																											// for
	 * 																											// deletePublication's
	 * 																											// publicationId
	 * 																											// input
	 * 																											// parameter
	 * 			params);
	 * 		Publication field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePublicationGraphQLRequest(String)} method.
	 * @param publicationId Parameter for the deletePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Publication>> deletePublicationWithBindValues(ObjectResponse objectResponse,
		Long publicationId, Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'deletePublication' with parameters: {} ", publicationId);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deletePublication'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationDeletePublicationPublicationId", publicationId);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getDeletePublication() == null) ? Optional.empty() : Optional.of(t.getDeletePublication()));
	}

	/**
	 * Deletes an existing publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.deletePublication(preparedRequest, publicationId, // A value for
	 * 																							// deletePublication's
	 * 																							// publicationId
	 * 																							// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publication field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePublicationGraphQLRequest(String)} method.
	 * @param publicationId Parameter for the deletePublication field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Publication>> deletePublication(ObjectResponse objectResponse, Long publicationId,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'deletePublication' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deletePublication' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationDeletePublicationPublicationId", publicationId);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getDeletePublication() == null) ? Optional.empty() : Optional.of(t.getDeletePublication()));
	}

	/**
	 * Deletes an existing publication.<br/>
	 * Get the {@link Builder} for the Publication, as expected by the deletePublication query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeletePublicationResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "deletePublication", RequestType.mutation,
			InputParameter.newBindParameter("", "publicationId", "mutationDeletePublicationPublicationId", MANDATORY,
				"ID", true, 0, false));
	}

	/**
	 * Deletes an existing publication.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the deletePublication REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeletePublicationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deletePublication",
			InputParameter.newBindParameter("", "publicationId", "mutationDeletePublicationPublicationId", MANDATORY,
				"ID", true, 0, false));
	}

	/**
	 * Creates a new publisher. This method executes a partial query against the GraphQL server. That is, the query that
	 * is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the query
	 * that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Publisher> mono = executor.createPublisherWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisher, // A value for createPublisher's publisher input parameter
	 * 			params);
	 * 		Publisher field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publisher Parameter for the createPublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Publisher>> createPublisherWithBindValues(String queryResponseDef, PublisherInput publisher,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'createPublisher': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getCreatePublisherResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createPublisherWithBindValues(objectResponse, publisher, parameters);
	}

	/**
	 * Creates a new publisher.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publisher> mono = executor.createPublisher(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisher, // A value for createPublisher's publisher input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publisher field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param publisher Parameter for the createPublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Publisher>> createPublisher(String queryResponseDef, PublisherInput publisher,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'createPublisher': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getCreatePublisherResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createPublisherWithBindValues(objectResponse, publisher,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Creates a new publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publisher> mono = executor.createPublisherWithBindValues(preparedRequest, publisher, // A value for
	 * 																									// createPublisher's
	 * 																									// publisher
	 * 																									// input
	 * 																									// parameter
	 * 			params);
	 * 		Publisher field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePublisherGraphQLRequest(String)} method.
	 * @param publisher Parameter for the createPublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Publisher>> createPublisherWithBindValues(ObjectResponse objectResponse,
		PublisherInput publisher, Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'createPublisher' with parameters: {} ", publisher);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createPublisher'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationCreatePublisherPublisher", publisher);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getCreatePublisher() == null) ? Optional.empty() : Optional.of(t.getCreatePublisher()));
	}

	/**
	 * Creates a new publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publisher> mono = executor.createPublisher(preparedRequest, publisher, // A value for
	 * 																					// createPublisher's
	 * 																					// publisher input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publisher field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePublisherGraphQLRequest(String)} method.
	 * @param publisher Parameter for the createPublisher field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Publisher>> createPublisher(ObjectResponse objectResponse, PublisherInput publisher,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'createPublisher' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createPublisher' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationCreatePublisherPublisher", publisher);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getCreatePublisher() == null) ? Optional.empty() : Optional.of(t.getCreatePublisher()));
	}

	/**
	 * Creates a new publisher.<br/>
	 * Get the {@link Builder} for the Publisher, as expected by the createPublisher query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreatePublisherResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "createPublisher", RequestType.mutation,
			InputParameter.newBindParameter("", "publisher", "mutationCreatePublisherPublisher", MANDATORY,
				"PublisherInput", true, 0, false));
	}

	/**
	 * Creates a new publisher.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the createPublisher REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getCreatePublisherGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createPublisher",
			InputParameter.newBindParameter("", "publisher", "mutationCreatePublisherPublisher", MANDATORY,
				"PublisherInput", true, 0, false));
	}

	/**
	 * Updates an existing publisher. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Publisher> mono = executor.updatePublisherWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisher, // A value for updatePublisher's publisher input parameter
	 * 			params);
	 * 		Publisher field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publisher Parameter for the updatePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Publisher>> updatePublisherWithBindValues(String queryResponseDef, PublisherInput publisher,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'updatePublisher': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getUpdatePublisherResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updatePublisherWithBindValues(objectResponse, publisher, parameters);
	}

	/**
	 * Updates an existing publisher.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publisher> mono = executor.updatePublisher(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisher, // A value for updatePublisher's publisher input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publisher field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param publisher Parameter for the updatePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Publisher>> updatePublisher(String queryResponseDef, PublisherInput publisher,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'updatePublisher': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getUpdatePublisherResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updatePublisherWithBindValues(objectResponse, publisher,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publisher> mono = executor.updatePublisherWithBindValues(preparedRequest, publisher, // A value for
	 * 																									// updatePublisher's
	 * 																									// publisher
	 * 																									// input
	 * 																									// parameter
	 * 			params);
	 * 		Publisher field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePublisherGraphQLRequest(String)} method.
	 * @param publisher Parameter for the updatePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Publisher>> updatePublisherWithBindValues(ObjectResponse objectResponse,
		PublisherInput publisher, Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'updatePublisher' with parameters: {} ", publisher);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updatePublisher'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdatePublisherPublisher", publisher);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getUpdatePublisher() == null) ? Optional.empty() : Optional.of(t.getUpdatePublisher()));
	}

	/**
	 * Updates an existing publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publisher> mono = executor.updatePublisher(preparedRequest, publisher, // A value for
	 * 																					// updatePublisher's
	 * 																					// publisher input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publisher field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePublisherGraphQLRequest(String)} method.
	 * @param publisher Parameter for the updatePublisher field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Publisher>> updatePublisher(ObjectResponse objectResponse, PublisherInput publisher,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updatePublisher' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updatePublisher' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdatePublisherPublisher", publisher);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getUpdatePublisher() == null) ? Optional.empty() : Optional.of(t.getUpdatePublisher()));
	}

	/**
	 * Updates an existing publisher.<br/>
	 * Get the {@link Builder} for the Publisher, as expected by the updatePublisher query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdatePublisherResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "updatePublisher", RequestType.mutation,
			InputParameter.newBindParameter("", "publisher", "mutationUpdatePublisherPublisher", MANDATORY,
				"PublisherInput", true, 0, false));
	}

	/**
	 * Updates an existing publisher.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updatePublisher REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdatePublisherGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updatePublisher",
			InputParameter.newBindParameter("", "publisher", "mutationUpdatePublisherPublisher", MANDATORY,
				"PublisherInput", true, 0, false));
	}

	/**
	 * Deletes an existing publisher. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Publication> mono = executor.deletePublisherWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisherId, // A value for deletePublisher's publisherId input parameter
	 * 			params);
	 * 		Publication field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publisherId Parameter for the deletePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Publisher>> deletePublisherWithBindValues(String queryResponseDef, Long publisherId,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'deletePublisher': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getDeletePublisherResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deletePublisherWithBindValues(objectResponse, publisherId, parameters);
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.deletePublisher(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisherId, // A value for deletePublisher's publisherId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publication field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param publisherId Parameter for the deletePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Publisher>> deletePublisher(String queryResponseDef, Long publisherId,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'deletePublisher': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getDeletePublisherResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deletePublisherWithBindValues(objectResponse, publisherId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publisher> mono = executor.deletePublisherWithBindValues(preparedRequest, publisherId, // A value
	 * 																									// for
	 * 																									// deletePublisher's
	 * 																									// publisherId
	 * 																									// input
	 * 																									// parameter
	 * 			params);
	 * 		Publisher field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePublisherGraphQLRequest(String)} method.
	 * @param publisherId Parameter for the deletePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Publisher>> deletePublisherWithBindValues(ObjectResponse objectResponse, Long publisherId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'deletePublisher' with parameters: {} ", publisherId);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deletePublisher'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationDeletePublisherPublisherId", publisherId);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getDeletePublisher() == null) ? Optional.empty() : Optional.of(t.getDeletePublisher()));
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publisher> mono = executor.deletePublisher(preparedRequest, publisherId, // A value for
	 * 																						// deletePublisher's
	 * 																						// publisherId input
	 * 																						// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publisher field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePublisherGraphQLRequest(String)} method.
	 * @param publisherId Parameter for the deletePublisher field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Publisher>> deletePublisher(ObjectResponse objectResponse, Long publisherId,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'deletePublisher' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deletePublisher' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationDeletePublisherPublisherId", publisherId);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getDeletePublisher() == null) ? Optional.empty() : Optional.of(t.getDeletePublisher()));
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * Get the {@link Builder} for the Publisher, as expected by the deletePublisher query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeletePublisherResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "deletePublisher", RequestType.mutation,
			InputParameter.newBindParameter("", "publisherId", "mutationDeletePublisherPublisherId", MANDATORY, "ID",
				true, 0, false));
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the deletePublisher REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeletePublisherGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deletePublisher",
			InputParameter.newBindParameter("", "publisherId", "mutationDeletePublisherPublisherId", MANDATORY, "ID",
				true, 0, false));
	}

	/**
	 * Creates a new quotation. This method executes a partial query against the GraphQL server. That is, the query that
	 * is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the query
	 * that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Quotation> mono = executor.createQuotationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotation, // A value for createQuotation's quotation input parameter
	 * 			params);
	 * 		Quotation field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param quotation Parameter for the createQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Quotation>> createQuotationWithBindValues(String queryResponseDef, QuotationInput quotation,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'createQuotation': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getCreateQuotationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createQuotationWithBindValues(objectResponse, quotation, parameters);
	}

	/**
	 * Creates a new quotation.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Quotation> mono = executor.createQuotation(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotation, // A value for createQuotation's quotation input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Quotation field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param quotation Parameter for the createQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Quotation>> createQuotation(String queryResponseDef, QuotationInput quotation,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'createQuotation': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getCreateQuotationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createQuotationWithBindValues(objectResponse, quotation,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Creates a new quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Quotation> mono = executor.createQuotationWithBindValues(preparedRequest, quotation, // A value for
	 * 																									// createQuotation's
	 * 																									// quotation
	 * 																									// input
	 * 																									// parameter
	 * 			params);
	 * 		Quotation field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateQuotationGraphQLRequest(String)} method.
	 * @param quotation Parameter for the createQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Quotation>> createQuotationWithBindValues(ObjectResponse objectResponse,
		QuotationInput quotation, Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'createQuotation' with parameters: {} ", quotation);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createQuotation'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationCreateQuotationQuotation", quotation);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getCreateQuotation() == null) ? Optional.empty() : Optional.of(t.getCreateQuotation()));
	}

	/**
	 * Creates a new quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Quotation> mono = executor.createQuotation(preparedRequest, quotation, // A value for
	 * 																					// createQuotation's
	 * 																					// quotation input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Quotation field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateQuotationGraphQLRequest(String)} method.
	 * @param quotation Parameter for the createQuotation field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Quotation>> createQuotation(ObjectResponse objectResponse, QuotationInput quotation,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'createQuotation' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createQuotation' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationCreateQuotationQuotation", quotation);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getCreateQuotation() == null) ? Optional.empty() : Optional.of(t.getCreateQuotation()));
	}

	/**
	 * Creates a new quotation.<br/>
	 * Get the {@link Builder} for the Quotation, as expected by the createQuotation query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreateQuotationResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "createQuotation", RequestType.mutation,
			InputParameter.newBindParameter("", "quotation", "mutationCreateQuotationQuotation", MANDATORY,
				"QuotationInput", true, 0, false));
	}

	/**
	 * Creates a new quotation.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the createQuotation REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getCreateQuotationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createQuotation",
			InputParameter.newBindParameter("", "quotation", "mutationCreateQuotationQuotation", MANDATORY,
				"QuotationInput", true, 0, false));
	}

	/**
	 * Updates an existing quotation. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Quotation> mono = executor.updateQuotationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotation, // A value for updateQuotation's quotation input parameter
	 * 			params);
	 * 		Quotation field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param quotation Parameter for the updateQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Quotation>> updateQuotationWithBindValues(String queryResponseDef, QuotationInput quotation,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'updateQuotation': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getUpdateQuotationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateQuotationWithBindValues(objectResponse, quotation, parameters);
	}

	/**
	 * Updates an existing quotation.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Quotation> mono = executor.updateQuotation(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotation, // A value for updateQuotation's quotation input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Quotation field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param quotation Parameter for the updateQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Quotation>> updateQuotation(String queryResponseDef, QuotationInput quotation,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'updateQuotation': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getUpdateQuotationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateQuotationWithBindValues(objectResponse, quotation,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Quotation> mono = executor.updateQuotationWithBindValues(preparedRequest, quotation, // A value for
	 * 																									// updateQuotation's
	 * 																									// quotation
	 * 																									// input
	 * 																									// parameter
	 * 			params);
	 * 		Quotation field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateQuotationGraphQLRequest(String)} method.
	 * @param quotation Parameter for the updateQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Quotation>> updateQuotationWithBindValues(ObjectResponse objectResponse,
		QuotationInput quotation, Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'updateQuotation' with parameters: {} ", quotation);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updateQuotation'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdateQuotationQuotation", quotation);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getUpdateQuotation() == null) ? Optional.empty() : Optional.of(t.getUpdateQuotation()));
	}

	/**
	 * Updates an existing quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Quotation> mono = executor.updateQuotation(preparedRequest, quotation, // A value for
	 * 																					// updateQuotation's
	 * 																					// quotation input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Quotation field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateQuotationGraphQLRequest(String)} method.
	 * @param quotation Parameter for the updateQuotation field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Quotation>> updateQuotation(ObjectResponse objectResponse, QuotationInput quotation,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updateQuotation' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updateQuotation' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdateQuotationQuotation", quotation);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getUpdateQuotation() == null) ? Optional.empty() : Optional.of(t.getUpdateQuotation()));
	}

	/**
	 * Updates an existing quotation.<br/>
	 * Get the {@link Builder} for the Quotation, as expected by the updateQuotation query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdateQuotationResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "updateQuotation", RequestType.mutation,
			InputParameter.newBindParameter("", "quotation", "mutationUpdateQuotationQuotation", MANDATORY,
				"QuotationInput", true, 0, false));
	}

	/**
	 * Updates an existing quotation.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updateQuotation REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdateQuotationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateQuotation",
			InputParameter.newBindParameter("", "quotation", "mutationUpdateQuotationQuotation", MANDATORY,
				"QuotationInput", true, 0, false));
	}

	/**
	 * Deletes an existing quotation. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Quotation> mono = executor.deleteQuotationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotationId, // A value for deleteQuotation's quotationId input parameter
	 * 			params);
	 * 		Quotation field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param quotationId Parameter for the deleteQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Quotation>> deleteQuotationWithBindValues(String queryResponseDef, Long quotationId,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'deleteQuotation': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getDeleteQuotationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteQuotationWithBindValues(objectResponse, quotationId, parameters);
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Quotation> mono = executor.deleteQuotation(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotationId, // A value for deleteQuotation's quotationId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Quotation field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param quotationId Parameter for the deleteQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Quotation>> deleteQuotation(String queryResponseDef, Long quotationId,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'deleteQuotation': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getDeleteQuotationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteQuotationWithBindValues(objectResponse, quotationId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Quotation> mono = executor.deleteQuotationWithBindValues(preparedRequest, quotationId, // A value
	 * 																									// for
	 * 																									// deleteQuotation's
	 * 																									// quotationId
	 * 																									// input
	 * 																									// parameter
	 * 			params);
	 * 		Quotation field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteQuotationGraphQLRequest(String)} method.
	 * @param quotationId Parameter for the deleteQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Quotation>> deleteQuotationWithBindValues(ObjectResponse objectResponse, Long quotationId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'deleteQuotation' with parameters: {} ", quotationId);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deleteQuotation'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationDeleteQuotationQuotationId", quotationId);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getDeleteQuotation() == null) ? Optional.empty() : Optional.of(t.getDeleteQuotation()));
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Quotation> mono = executor.deleteQuotation(preparedRequest, quotationId, // A value for
	 * 																						// deleteQuotation's
	 * 																						// quotationId input
	 * 																						// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Quotation field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteQuotationGraphQLRequest(String)} method.
	 * @param quotationId Parameter for the deleteQuotation field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Quotation>> deleteQuotation(ObjectResponse objectResponse, Long quotationId,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'deleteQuotation' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deleteQuotation' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationDeleteQuotationQuotationId", quotationId);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getDeleteQuotation() == null) ? Optional.empty() : Optional.of(t.getDeleteQuotation()));
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * Get the {@link Builder} for the Quotation, as expected by the deleteQuotation query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeleteQuotationResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "deleteQuotation", RequestType.mutation,
			InputParameter.newBindParameter("", "quotationId", "mutationDeleteQuotationQuotationId", MANDATORY, "ID",
				true, 0, false));
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the deleteQuotation REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeleteQuotationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteQuotation",
			InputParameter.newBindParameter("", "quotationId", "mutationDeleteQuotationQuotationId", MANDATORY, "ID",
				true, 0, false));
	}

	/**
	 * Creates a new topic. This method executes a partial query against the GraphQL server. That is, the query that is
	 * one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the query that
	 * <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Topic> mono = executor.createTopicWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topic, // A value for createTopic's topic input parameter
	 * 			params);
	 * 		Topic field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topic Parameter for the createTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Topic>> createTopicWithBindValues(String queryResponseDef, TopicInput topic,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'createTopic': {} ", queryResponseDef);
		ObjectResponse objectResponse = getCreateTopicResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createTopicWithBindValues(objectResponse, topic, parameters);
	}

	/**
	 * Creates a new topic.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Topic> mono = executor.createTopic(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topic, // A value for createTopic's topic input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Topic field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param topic Parameter for the createTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Topic>> createTopic(String queryResponseDef, TopicInput topic, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'createTopic': {} ", queryResponseDef);
		ObjectResponse objectResponse = getCreateTopicResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createTopicWithBindValues(objectResponse, topic,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Creates a new topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Topic> mono = executor.createTopicWithBindValues(preparedRequest, topic, // A value for
	 * 																						// createTopic's topic
	 * 																						// input parameter
	 * 			params);
	 * 		Topic field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateTopicGraphQLRequest(String)} method.
	 * @param topic Parameter for the createTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Topic>> createTopicWithBindValues(ObjectResponse objectResponse, TopicInput topic,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'createTopic' with parameters: {} ", topic);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createTopic'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationCreateTopicTopic", topic);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getCreateTopic() == null) ? Optional.empty() : Optional.of(t.getCreateTopic()));
	}

	/**
	 * Creates a new topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Topic> mono = executor.createTopic(preparedRequest, topic, // A value for createTopic's topic input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Topic field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateTopicGraphQLRequest(String)} method.
	 * @param topic Parameter for the createTopic field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[CRE]" })
	public Mono<Optional<Topic>> createTopic(ObjectResponse objectResponse, TopicInput topic, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'createTopic' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createTopic' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationCreateTopicTopic", topic);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getCreateTopic() == null) ? Optional.empty() : Optional.of(t.getCreateTopic()));
	}

	/**
	 * Creates a new topic.<br/>
	 * Get the {@link Builder} for the Topic, as expected by the createTopic query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreateTopicResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "createTopic", RequestType.mutation,
			InputParameter.newBindParameter("", "topic", "mutationCreateTopicTopic", MANDATORY, "TopicInput", true, 0,
				false));
	}

	/**
	 * Creates a new topic.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the createTopic REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getCreateTopicGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createTopic",
			InputParameter.newBindParameter("", "topic", "mutationCreateTopicTopic", MANDATORY, "TopicInput", true, 0,
				false));
	}

	/**
	 * Updates an existing topic. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Topic> mono = executor.updateTopicWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topic, // A value for updateTopic's topic input parameter
	 * 			params);
	 * 		Topic field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topic Parameter for the updateTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Topic>> updateTopicWithBindValues(String queryResponseDef, TopicInput topic,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'updateTopic': {} ", queryResponseDef);
		ObjectResponse objectResponse = getUpdateTopicResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateTopicWithBindValues(objectResponse, topic, parameters);
	}

	/**
	 * Updates an existing topic.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Topic> mono = executor.updateTopic(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topic, // A value for updateTopic's topic input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Topic field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param topic Parameter for the updateTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Topic>> updateTopic(String queryResponseDef, TopicInput topic, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'updateTopic': {} ", queryResponseDef);
		ObjectResponse objectResponse = getUpdateTopicResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateTopicWithBindValues(objectResponse, topic,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Topic> mono = executor.updateTopicWithBindValues(preparedRequest, topic, // A value for
	 * 																						// updateTopic's topic
	 * 																						// input parameter
	 * 			params);
	 * 		Topic field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateTopicGraphQLRequest(String)} method.
	 * @param topic Parameter for the updateTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Topic>> updateTopicWithBindValues(ObjectResponse objectResponse, TopicInput topic,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'updateTopic' with parameters: {} ", topic);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updateTopic'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdateTopicTopic", topic);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getUpdateTopic() == null) ? Optional.empty() : Optional.of(t.getUpdateTopic()));
	}

	/**
	 * Updates an existing topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Topic> mono = executor.updateTopic(preparedRequest, topic, // A value for updateTopic's topic input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Topic field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateTopicGraphQLRequest(String)} method.
	 * @param topic Parameter for the updateTopic field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Topic>> updateTopic(ObjectResponse objectResponse, TopicInput topic, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updateTopic' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updateTopic' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdateTopicTopic", topic);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getUpdateTopic() == null) ? Optional.empty() : Optional.of(t.getUpdateTopic()));
	}

	/**
	 * Updates an existing topic.<br/>
	 * Get the {@link Builder} for the Topic, as expected by the updateTopic query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdateTopicResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "updateTopic", RequestType.mutation,
			InputParameter.newBindParameter("", "topic", "mutationUpdateTopicTopic", MANDATORY, "TopicInput", true, 0,
				false));
	}

	/**
	 * Updates an existing topic.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updateTopic REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdateTopicGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateTopic",
			InputParameter.newBindParameter("", "topic", "mutationUpdateTopicTopic", MANDATORY, "TopicInput", true, 0,
				false));
	}

	/**
	 * Deletes an existing topic. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Topic> mono = executor.deleteTopicWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topicId, // A value for deleteTopic's topicId input parameter
	 * 			params);
	 * 		Topic field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topicId Parameter for the deleteTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Topic>> deleteTopicWithBindValues(String queryResponseDef, Long topicId,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'deleteTopic': {} ", queryResponseDef);
		ObjectResponse objectResponse = getDeleteTopicResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteTopicWithBindValues(objectResponse, topicId, parameters);
	}

	/**
	 * Deletes an existing topic.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Topic> mono = executor.deleteTopic(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topicId, // A value for deleteTopic's topicId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Topic field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param topicId Parameter for the deleteTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Topic>> deleteTopic(String queryResponseDef, Long topicId, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'deleteTopic': {} ", queryResponseDef);
		ObjectResponse objectResponse = getDeleteTopicResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteTopicWithBindValues(objectResponse, topicId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Deletes an existing topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Topic> mono = executor.deleteTopicWithBindValues(preparedRequest, topicId, // A value for
	 * 																						// deleteTopic's topicId
	 * 																						// input parameter
	 * 			params);
	 * 		Topic field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteTopicGraphQLRequest(String)} method.
	 * @param topicId Parameter for the deleteTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Topic>> deleteTopicWithBindValues(ObjectResponse objectResponse, Long topicId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'deleteTopic' with parameters: {} ", topicId);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deleteTopic'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationDeleteTopicTopicId", topicId);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getDeleteTopic() == null) ? Optional.empty() : Optional.of(t.getDeleteTopic()));
	}

	/**
	 * Deletes an existing topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Topic> mono = executor.deleteTopic(preparedRequest, topicId, // A value for deleteTopic's topicId
	 * 																			// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Topic field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteTopicGraphQLRequest(String)} method.
	 * @param topicId Parameter for the deleteTopic field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[DEL]" })
	public Mono<Optional<Topic>> deleteTopic(ObjectResponse objectResponse, Long topicId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'deleteTopic' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deleteTopic' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationDeleteTopicTopicId", topicId);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getDeleteTopic() == null) ? Optional.empty() : Optional.of(t.getDeleteTopic()));
	}

	/**
	 * Deletes an existing topic.<br/>
	 * Get the {@link Builder} for the Topic, as expected by the deleteTopic query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeleteTopicResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "deleteTopic", RequestType.mutation,
			InputParameter.newBindParameter("", "topicId", "mutationDeleteTopicTopicId", MANDATORY, "ID", true, 0,
				false));
	}

	/**
	 * Deletes an existing topic.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the deleteTopic REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeleteTopicGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteTopic",
			InputParameter.newBindParameter("", "topicId", "mutationDeleteTopicTopicId", MANDATORY, "ID", true, 0,
				false));
	}

	/**
	 * Sets entity status. This method executes a partial query against the GraphQL server. That is, the query that is
	 * one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the query that
	 * <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Boolean> mono = executor.setEntityStatusWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			entityId, // A value for setEntityStatus's entityId input parameter
	 * 			status, // A value for setEntityStatus's status input parameter
	 * 			params);
	 * 		Boolean field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param entityId Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param status Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "setEntityStatus", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Boolean>> setEntityStatusWithBindValues(String queryResponseDef, Long entityId,
		StatusKind status, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'setEntityStatus': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getSetEntityStatusResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return setEntityStatusWithBindValues(objectResponse, entityId, status, parameters);
	}

	/**
	 * Sets entity status.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Boolean> mono = executor.setEntityStatus(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			entityId, // A value for setEntityStatus's entityId input parameter
	 * 			status, // A value for setEntityStatus's status input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Boolean field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param entityId Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param status Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "setEntityStatus", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Boolean>> setEntityStatus(String queryResponseDef, Long entityId, StatusKind status,
		Object... paramsAndValues) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'setEntityStatus': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getSetEntityStatusResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return setEntityStatusWithBindValues(objectResponse, entityId, status,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Sets entity status.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getSetEntityStatusGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Boolean> mono = executor.setEntityStatusWithBindValues(preparedRequest, entityKind, // A value for
	 * 																									// setEntityStatus's
	 * 																									// entityKind
	 * 																									// input
	 * 																									// parameter
	 * 			entityId, // A value for setEntityStatus's entityId input parameter
	 * 			status, // A value for setEntityStatus's status input parameter
	 * 			params);
	 * 		Boolean field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getSetEntityStatusGraphQLRequest(String)} method.
	 * @param entityId Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param status Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "setEntityStatus", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Boolean>> setEntityStatusWithBindValues(ObjectResponse objectResponse, Long entityId,
		StatusKind status, Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'setEntityStatus' with parameters: {}, {} ", entityId, status);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'setEntityStatus'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationSetEntityStatusEntityId", entityId);
		parametersLocal.put("mutationSetEntityStatusStatus", status);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getSetEntityStatus() == null) ? Optional.empty() : Optional.of(t.getSetEntityStatus()));
	}

	/**
	 * Sets entity status.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getSetEntityStatusGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Boolean> mono = executor.setEntityStatus(preparedRequest, entityId, // A value for setEntityStatus's
	 * 																					// entityId input parameter
	 * 			status, // A value for setEntityStatus's status input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Boolean field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getSetEntityStatusGraphQLRequest(String)} method.
	 * @param entityId Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param status Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "setEntityStatus", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[UPD]" })
	public Mono<Optional<Boolean>> setEntityStatus(ObjectResponse objectResponse, Long entityId, StatusKind status,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'setEntityStatus' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'setEntityStatus' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationSetEntityStatusEntityId", entityId);
		parameters.put("mutationSetEntityStatusStatus", status);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getSetEntityStatus() == null) ? Optional.empty() : Optional.of(t.getSetEntityStatus()));
	}

	/**
	 * Sets entity status.<br/>
	 * Get the {@link Builder} for the Boolean, as expected by the setEntityStatus query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getSetEntityStatusResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "setEntityStatus", RequestType.mutation,
			InputParameter.newBindParameter("", "entityId", "mutationSetEntityStatusEntityId", MANDATORY, "ID", true, 0,
				false),
			InputParameter.newBindParameter("", "status", "mutationSetEntityStatusStatus", MANDATORY, "StatusKind",
				true, 0, false));
	}

	/**
	 * Sets entity status.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the setEntityStatus REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getSetEntityStatusGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "setEntityStatus",
			InputParameter.newBindParameter("", "entityId", "mutationSetEntityStatusEntityId", MANDATORY, "ID", true, 0,
				false),
			InputParameter.newBindParameter("", "status", "mutationSetEntityStatusStatus", MANDATORY, "StatusKind",
				true, 0, false));
	}

	/**
	 * Creates a new user. This method executes a partial query against the GraphQL server. That is, the query that is
	 * one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the query that
	 * <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<User> mono = executor.createUserWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for createUser's user input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param user Parameter for the createUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> createUserWithBindValues(String queryResponseDef, UserInput user,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'createUser': {} ", queryResponseDef);
		ObjectResponse objectResponse = getCreateUserResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createUserWithBindValues(objectResponse, user, parameters);
	}

	/**
	 * Creates a new user.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.createUser(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for createUser's user input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param user Parameter for the createUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> createUser(String queryResponseDef, UserInput user, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'createUser': {} ", queryResponseDef);
		ObjectResponse objectResponse = getCreateUserResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createUserWithBindValues(objectResponse, user,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Creates a new user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.createUserWithBindValues(preparedRequest, user, // A value for createUser's
	 * 																					// user input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateUserGraphQLRequest(String)} method.
	 * @param user Parameter for the createUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> createUserWithBindValues(ObjectResponse objectResponse, UserInput user,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'createUser' with parameters: {} ", user);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createUser'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationCreateUserUser", user);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getCreateUser() == null) ? Optional.empty() : Optional.of(t.getCreateUser()));
	}

	/**
	 * Creates a new user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.createUser(preparedRequest, user, // A value for createUser's user input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateUserGraphQLRequest(String)} method.
	 * @param user Parameter for the createUser field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> createUser(ObjectResponse objectResponse, UserInput user, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'createUser' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createUser' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationCreateUserUser", user);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getCreateUser() == null) ? Optional.empty() : Optional.of(t.getCreateUser()));
	}

	/**
	 * Creates a new user.<br/>
	 * Get the {@link Builder} for the User, as expected by the createUser query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreateUserResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "createUser", RequestType.mutation,
			InputParameter.newBindParameter("", "user", "mutationCreateUserUser", MANDATORY, "UserInput", true, 0,
				false));
	}

	/**
	 * Creates a new user.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the createUser REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getCreateUserGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createUser",
			InputParameter.newBindParameter("", "user", "mutationCreateUserUser", MANDATORY, "UserInput", true, 0,
				false));
	}

	/**
	 * Updates an existing user. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<User> mono = executor.updateUserWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for updateUser's user input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param user Parameter for the updateUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> updateUserWithBindValues(String queryResponseDef, UserInput user,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'updateUser': {} ", queryResponseDef);
		ObjectResponse objectResponse = getUpdateUserResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateUserWithBindValues(objectResponse, user, parameters);
	}

	/**
	 * Updates an existing user.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.updateUser(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for updateUser's user input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param user Parameter for the updateUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> updateUser(String queryResponseDef, UserInput user, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'updateUser': {} ", queryResponseDef);
		ObjectResponse objectResponse = getUpdateUserResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateUserWithBindValues(objectResponse, user,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.updateUserWithBindValues(preparedRequest, user, // A value for updateUser's
	 * 																					// user input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateUserGraphQLRequest(String)} method.
	 * @param user Parameter for the updateUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> updateUserWithBindValues(ObjectResponse objectResponse, UserInput user,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'updateUser' with parameters: {} ", user);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updateUser'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdateUserUser", user);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getUpdateUser() == null) ? Optional.empty() : Optional.of(t.getUpdateUser()));
	}

	/**
	 * Updates an existing user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.updateUser(preparedRequest, user, // A value for updateUser's user input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateUserGraphQLRequest(String)} method.
	 * @param user Parameter for the updateUser field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> updateUser(ObjectResponse objectResponse, UserInput user, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updateUser' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updateUser' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdateUserUser", user);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getUpdateUser() == null) ? Optional.empty() : Optional.of(t.getUpdateUser()));
	}

	/**
	 * Updates an existing user.<br/>
	 * Get the {@link Builder} for the User, as expected by the updateUser query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdateUserResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "updateUser", RequestType.mutation,
			InputParameter.newBindParameter("", "user", "mutationUpdateUserUser", MANDATORY, "UserInput", true, 0,
				false));
	}

	/**
	 * Updates an existing user.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updateUser REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdateUserGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateUser",
			InputParameter.newBindParameter("", "user", "mutationUpdateUserUser", MANDATORY, "UserInput", true, 0,
				false));
	}

	/**
	 * Updates an existing user's password. This method executes a partial query against the GraphQL server. That is,
	 * the query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part
	 * of the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<User> mono = executor.updateUserPasswordWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for updateUserPassword's user input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param user Parameter for the updateUserPassword field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUserPassword", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> updateUserPasswordWithBindValues(String queryResponseDef, UserPasswordInput user,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		LOGGER.debug("Executing mutation 'updateUserPassword': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getUpdateUserPasswordResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateUserPasswordWithBindValues(objectResponse, user, parameters);
	}

	/**
	 * Updates an existing user's password.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.updateUserPassword(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for updateUserPassword's user input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param user Parameter for the updateUserPassword field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUserPassword", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> updateUserPassword(String queryResponseDef, UserPasswordInput user,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		LOGGER.debug("Executing mutation 'updateUserPassword': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getUpdateUserPasswordResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateUserPasswordWithBindValues(objectResponse, user,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing user's password.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateUserPasswordGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.updateUserPasswordWithBindValues(preparedRequest, user, // A value for
	 * 																							// updateUserPassword's
	 * 																							// user input
	 * 																							// parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateUserPasswordGraphQLRequest(String)} method.
	 * @param user Parameter for the updateUserPassword field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUserPassword", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> updateUserPasswordWithBindValues(ObjectResponse objectResponse, UserPasswordInput user,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'updateUserPassword' with parameters: {} ", user);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updateUserPassword'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdateUserPasswordUser", user);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getUpdateUserPassword() == null) ? Optional.empty() : Optional.of(t.getUpdateUserPassword()));
	}

	/**
	 * Updates an existing user's password.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateUserPasswordGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.updateUserPassword(preparedRequest, user, // A value for updateUserPassword's
	 * 																				// user input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateUserPasswordGraphQLRequest(String)} method.
	 * @param user Parameter for the updateUserPassword field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUserPassword", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> updateUserPassword(ObjectResponse objectResponse, UserPasswordInput user,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updateUserPassword' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updateUserPassword' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdateUserPasswordUser", user);

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getUpdateUserPassword() == null) ? Optional.empty() : Optional.of(t.getUpdateUserPassword()));
	}

	/**
	 * Updates an existing user's password.<br/>
	 * Get the {@link Builder} for the User, as expected by the updateUserPassword query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdateUserPasswordResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "updateUserPassword", RequestType.mutation,
			InputParameter.newBindParameter("", "user", "mutationUpdateUserPasswordUser", InputParameterType.MANDATORY,
				"UserPasswordInput", true, 0, false));
	}

	/**
	 * Updates an existing user's password.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updateUserPassword REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdateUserPasswordGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation,
			"updateUserPassword", InputParameter.newBindParameter("", "user", "mutationUpdateUserPasswordUser",
				InputParameterType.MANDATORY, "UserPasswordInput", true, 0, false));
	}

	/**
	 * Updates an existing user's profile. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<User> mono = executor.updateUserProfileWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for updateUserProfile's user input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param user Parameter for the updateUserProfile field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUserProfile", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> updateUserProfileWithBindValues(String queryResponseDef, UserProfileInput user,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		LOGGER.debug("Executing mutation 'updateUserProfile': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getUpdateUserProfileResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateUserProfileWithBindValues(objectResponse, user, parameters);
	}

	/**
	 * Updates an existing user's profile.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.updateUserProfile(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for updateUserProfile's user input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param user Parameter for the updateUserProfile field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUserProfile", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> updateUserProfile(String queryResponseDef, UserProfileInput user,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {

		LOGGER.debug("Executing mutation 'updateUserProfile': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getUpdateUserProfileResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateUserProfileWithBindValues(objectResponse, user,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing user's profile.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateUserProfileGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.updateUserProfileWithBindValues(preparedRequest, user, // A value for
	 * 																							// updateUserProfile's
	 * 																							// user input
	 * 																							// parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateUserProfileGraphQLRequest(String)} method.
	 * @param user Parameter for the updateUserProfile field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUserProfile", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> updateUserProfileWithBindValues(ObjectResponse objectResponse, UserProfileInput user,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'updateUserProfile' with parameters: {} ", user);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updateUserProfile'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdateUserProfileUser", user);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getUpdateUserProfile() == null) ? Optional.empty() : Optional.of(t.getUpdateUserProfile()));
	}

	/**
	 * Updates an existing user's profile.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateUserProfileGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.updateUserProfile(preparedRequest, user, // A value for updateUserProfile's
	 * 																			// user input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateUserProfileGraphQLRequest(String)} method.
	 * @param user Parameter for the updateUserProfile field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUserProfile", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> updateUserProfile(ObjectResponse objectResponse, UserProfileInput user,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updateUserProfile' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updateUserProfile' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdateUserProfileUser", user);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getUpdateUserProfile() == null) ? Optional.empty() : Optional.of(t.getUpdateUserProfile()));
	}

	/**
	 * Updates an existing user's profile.<br/>
	 * Get the {@link Builder} for the User, as expected by the updateUserProfile query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdateUserProfileResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "updateUserProfile", RequestType.mutation,
			InputParameter.newBindParameter("", "user", "mutationUpdateUserProfileUser", InputParameterType.MANDATORY,
				"UserProfileInput", true, 0, false));
	}

	/**
	 * Updates an existing user's profile.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updateUserProfile REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdateUserProfileGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateUserProfile",
			InputParameter.newBindParameter("", "user", "mutationUpdateUserProfileUser", InputParameterType.MANDATORY,
				"UserProfileInput", true, 0, false));
	}

	/**
	 * Deletes an existing user. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<User> mono = executor.deleteUserWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for deleteUser's userId input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param userId Parameter for the deleteUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> deleteUserWithBindValues(String queryResponseDef, Long userId,
		Map<String, Object> parameters) throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'deleteUser': {} ", queryResponseDef);
		ObjectResponse objectResponse = getDeleteUserResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteUserWithBindValues(objectResponse, userId, parameters);
	}

	/**
	 * Deletes an existing user.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.deleteUser(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for deleteUser's userId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param userId Parameter for the deleteUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> deleteUser(String queryResponseDef, Long userId, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'deleteUser': {} ", queryResponseDef);
		ObjectResponse objectResponse = getDeleteUserResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteUserWithBindValues(objectResponse, userId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Deletes an existing user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.deleteUserWithBindValues(preparedRequest, userId, // A value for deleteUser's
	 * 																						// userId input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteUserGraphQLRequest(String)} method.
	 * @param userId Parameter for the deleteUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> deleteUserWithBindValues(ObjectResponse objectResponse, Long userId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'deleteUser' with parameters: {} ", userId);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deleteUser'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationDeleteUserUserId", userId);

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.getDeleteUser() == null) ? Optional.empty() : Optional.of(t.getDeleteUser()));
	}

	/**
	 * Deletes an existing user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.deleteUser(preparedRequest, userId, // A value for deleteUser's userId input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteUserGraphQLRequest(String)} method.
	 * @param userId Parameter for the deleteUser field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> deleteUser(ObjectResponse objectResponse, Long userId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'deleteUser' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deleteUser' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationDeleteUserUserId", userId);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.getDeleteUser() == null) ? Optional.empty() : Optional.of(t.getDeleteUser()));
	}

	/**
	 * Deletes an existing user.<br/>
	 * Get the {@link Builder} for the User, as expected by the deleteUser query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeleteUserResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "deleteUser", RequestType.mutation,
			InputParameter.newBindParameter("", "userId", "mutationDeleteUserUserId", MANDATORY, "ID", true, 0, false));
	}

	/**
	 * Deletes an existing user.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the deleteUser REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeleteUserGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteUser",
			InputParameter.newBindParameter("", "userId", "mutationDeleteUserUserId", MANDATORY, "ID", true, 0, false));
	}

	/**
	 * Grants authorities to a user. The specified authorities are added to any existing ones. This method executes a
	 * partial query against the GraphQL server. That is, the query that is one of the queries defined in the GraphQL
	 * query object. The queryResponseDef contains the part of the query that <B><U>is after</U></B> the query
	 * name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<User> mono = executor.grantUserAuthoritiesWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for grantUserAuthorities's userId input parameter
	 * 			authorities, // A value for grantUserAuthorities's authorities input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param userId Parameter for the grantUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the grantUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantUserAuthorities", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> grantUserAuthoritiesWithBindValues(String queryResponseDef, Long userId,
		List<AuthorityKind> authorities, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'grantUserAuthorities': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getGrantUserAuthoritiesResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return grantUserAuthoritiesWithBindValues(objectResponse, userId, authorities, parameters);
	}

	/**
	 * Grants authorities to a user. The specified authorities are added to any existing ones.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.grantUserAuthorities(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for grantUserAuthorities's userId input parameter
	 * 			authorities, // A value for grantUserAuthorities's authorities input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param userId Parameter for the grantUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the grantUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantUserAuthorities", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> grantUserAuthorities(String queryResponseDef, Long userId,
		List<AuthorityKind> authorities, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'grantUserAuthorities': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getGrantUserAuthoritiesResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return grantUserAuthoritiesWithBindValues(objectResponse, userId, authorities,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Grants authorities to a user. The specified authorities are added to any existing ones.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getGrantUserAuthoritiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.grantUserAuthoritiesWithBindValues(preparedRequest, userId, // A value for
	 * 																								// grantUserAuthorities's
	 * 																								// userId input
	 * 																								// parameter
	 * 			authorities, // A value for grantUserAuthorities's authorities input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGrantUserAuthoritiesGraphQLRequest(String)} method.
	 * @param userId Parameter for the grantUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the grantUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantUserAuthorities", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> grantUserAuthoritiesWithBindValues(ObjectResponse objectResponse, Long userId,
		List<AuthorityKind> authorities, Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'grantUserAuthorities' with parameters: {}, {} ", userId, authorities);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'grantUserAuthorities'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationGrantUserAuthoritiesUserId", userId);
		parametersLocal.put("mutationGrantUserAuthoritiesAuthorities", authorities);

		return objectResponse.execReactive(Mutation.class, parametersLocal).map(
			t -> (t.getGrantUserAuthorities() == null) ? Optional.empty() : Optional.of(t.getGrantUserAuthorities()));
	}

	/**
	 * Grants authorities to a user. The specified authorities are added to any existing ones.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getGrantUserAuthoritiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.grantUserAuthorities(preparedRequest, userId, // A value for
	 * 																					// grantUserAuthorities's
	 * 																					// userId input parameter
	 * 			authorities, // A value for grantUserAuthorities's authorities input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGrantUserAuthoritiesGraphQLRequest(String)} method.
	 * @param userId Parameter for the grantUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the grantUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantUserAuthorities", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> grantUserAuthorities(ObjectResponse objectResponse, Long userId,
		List<AuthorityKind> authorities, Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'grantUserAuthorities' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'grantUserAuthorities' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationGrantUserAuthoritiesUserId", userId);
		parameters.put("mutationGrantUserAuthoritiesAuthorities", authorities);

		return objectResponse.execReactive(Mutation.class, parameters).map(
			t -> (t.getGrantUserAuthorities() == null) ? Optional.empty() : Optional.of(t.getGrantUserAuthorities()));
	}

	/**
	 * Grants authorities to a user. The specified authorities are added to any existing ones.<br/>
	 * Get the {@link Builder} for the User, as expected by the grantUserAuthorities query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getGrantUserAuthoritiesResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "grantUserAuthorities",
			RequestType.mutation,
			InputParameter.newBindParameter("", "userId", "mutationGrantUserAuthoritiesUserId", MANDATORY, "ID", true,
				0, false),
			InputParameter.newBindParameter("", "authorities", "mutationGrantUserAuthoritiesAuthorities", MANDATORY,
				"AuthorityKind", true, 1, true));
	}

	/**
	 * Grants authorities to a user. The specified authorities are added to any existing ones.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the grantUserAuthorities REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getGrantUserAuthoritiesGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation,
			"grantUserAuthorities",
			InputParameter.newBindParameter("", "userId", "mutationGrantUserAuthoritiesUserId", MANDATORY, "ID", true,
				0, false),
			InputParameter.newBindParameter("", "authorities", "mutationGrantUserAuthoritiesAuthorities", MANDATORY,
				"AuthorityKind", true, 1, true));
	}

	/**
	 * Revokes authorities from a user. The specified authorities are removed from the user; other authorities remain
	 * intact. This method executes a partial query against the GraphQL server. That is, the query that is one of the
	 * queries defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<User> mono = executor.revokeUserAuthoritiesWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for revokeUserAuthorities's userId input parameter
	 * 			authorities, // A value for revokeUserAuthorities's authorities input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param userId Parameter for the revokeUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the revokeUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeUserAuthorities", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> revokeUserAuthoritiesWithBindValues(String queryResponseDef, Long userId,
		List<AuthorityKind> authorities, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'revokeUserAuthorities': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getRevokeUserAuthoritiesResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return revokeUserAuthoritiesWithBindValues(objectResponse, userId, authorities, parameters);
	}

	/**
	 * Revokes authorities from a user. The specified authorities are removed from the user; other authorities remain
	 * intact.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.revokeUserAuthorities(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for revokeUserAuthorities's userId input parameter
	 * 			authorities, // A value for revokeUserAuthorities's authorities input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param userId Parameter for the revokeUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the revokeUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeUserAuthorities", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> revokeUserAuthorities(String queryResponseDef, Long userId,
		List<AuthorityKind> authorities, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation 'revokeUserAuthorities': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getRevokeUserAuthoritiesResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return revokeUserAuthoritiesWithBindValues(objectResponse, userId, authorities,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Revokes authorities from a user. The specified authorities are removed from the user; other authorities remain
	 * intact.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getRevokeUserAuthoritiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.revokeUserAuthoritiesWithBindValues(preparedRequest, userId, // A value for
	 * 																								// revokeUserAuthorities's
	 * 																								// userId input
	 * 																								// parameter
	 * 			authorities, // A value for revokeUserAuthorities's authorities input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getRevokeUserAuthoritiesGraphQLRequest(String)} method.
	 * @param userId Parameter for the revokeUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the revokeUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeUserAuthorities", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> revokeUserAuthoritiesWithBindValues(ObjectResponse objectResponse, Long userId,
		List<AuthorityKind> authorities, Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'revokeUserAuthorities' with parameters: {}, {} ", userId, authorities);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'revokeUserAuthorities'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationRevokeUserAuthoritiesUserId", userId);
		parametersLocal.put("mutationRevokeUserAuthoritiesAuthorities", authorities);

		return objectResponse.execReactive(Mutation.class, parametersLocal).map(
			t -> (t.getRevokeUserAuthorities() == null) ? Optional.empty() : Optional.of(t.getRevokeUserAuthorities()));
	}

	/**
	 * Revokes authorities from a user. The specified authorities are removed from the user; other authorities remain
	 * intact.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getRevokeUserAuthoritiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.revokeUserAuthorities(preparedRequest, userId, // A value for
	 * 																					// revokeUserAuthorities's
	 * 																					// userId input parameter
	 * 			authorities, // A value for revokeUserAuthorities's authorities input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getRevokeUserAuthoritiesGraphQLRequest(String)} method.
	 * @param userId Parameter for the revokeUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the revokeUserAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeUserAuthorities", graphQLTypeSimpleName = "User", javaClass = User.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<User>> revokeUserAuthorities(ObjectResponse objectResponse, Long userId,
		List<AuthorityKind> authorities, Object... paramsAndValues) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'revokeUserAuthorities' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'revokeUserAuthorities' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationRevokeUserAuthoritiesUserId", userId);
		parameters.put("mutationRevokeUserAuthoritiesAuthorities", authorities);

		return objectResponse.execReactive(Mutation.class, parameters).map(
			t -> (t.getRevokeUserAuthorities() == null) ? Optional.empty() : Optional.of(t.getRevokeUserAuthorities()));
	}

	/**
	 * Revokes authorities from a user. The specified authorities are removed from the user; other authorities remain
	 * intact.<br/>
	 * Get the {@link Builder} for the User, as expected by the revokeUserAuthorities query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getRevokeUserAuthoritiesResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "revokeUserAuthorities",
			RequestType.mutation,
			InputParameter.newBindParameter("", "userId", "mutationRevokeUserAuthoritiesUserId", MANDATORY, "ID", true,
				0, false),
			InputParameter.newBindParameter("", "authorities", "mutationRevokeUserAuthoritiesAuthorities", MANDATORY,
				"AuthorityKind", true, 1, true));
	}

	/**
	 * Revokes authorities from a user. The specified authorities are removed from the user; other authorities remain
	 * intact.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the revokeUserAuthorities REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getRevokeUserAuthoritiesGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation,
			"revokeUserAuthorities",
			InputParameter.newBindParameter("", "userId", "mutationRevokeUserAuthoritiesUserId", MANDATORY, "ID", true,
				0, false),
			InputParameter.newBindParameter("", "authorities", "mutationRevokeUserAuthoritiesAuthorities", MANDATORY,
				"AuthorityKind", true, 1, true));
	}

	/**
	 * Creates a new group. This method executes a partial query against the GraphQL server. That is, the query that is
	 * one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the query that
	 * <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Group> mono = executor.createGroupWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			group, // A value for createGroup's group input parameter
	 * 			params);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param group Parameter for the createGroup field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> createGroupWithBindValues(String queryResponseDef, GroupInput group,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		LOGGER.debug("Executing mutation 'createGroup': {} ", queryResponseDef);
		ObjectResponse objectResponse = getCreateGroupResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createGroupWithBindValues(objectResponse, group, parameters);
	}

	/**
	 * Creates a new group.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Group> mono = executor.createGroup(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			group, // A value for createGroup's group input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param group Parameter for the createGroup field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> createGroup(String queryResponseDef, GroupInput group, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		LOGGER.debug("Executing mutation 'createGroup': {} ", queryResponseDef);
		ObjectResponse objectResponse = getCreateGroupResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createGroupWithBindValues(objectResponse, group,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Creates a new group.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getCreateGroupGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Group> mono = executor.createGroupWithBindValues(preparedRequest, group, // A value for
	 * 																						// createGroup's group
	 * 																						// input parameter
	 * 			params);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateGroupGraphQLRequest(String)} method.
	 * @param group Parameter for the createGroup field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> createGroupWithBindValues(ObjectResponse objectResponse, GroupInput group,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'createGroup' with parameters: {} ", group);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createGroup'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationCreateGroupGroup", group);

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getCreateGroup() == null) ? Optional.empty() : Optional.of(t.getCreateGroup()));
	}

	/**
	 * Creates a new group.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getCreateGroupGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Group> mono = executor.createGroup(preparedRequest, group, // A value for createGroup's group input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateGroupGraphQLRequest(String)} method.
	 * @param group Parameter for the createGroup field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> createGroup(ObjectResponse objectResponse, GroupInput group, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'createGroup' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'createGroup' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationCreateGroupGroup", group);

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getCreateGroup() == null) ? Optional.empty() : Optional.of(t.getCreateGroup()));
	}

	/**
	 * Creates a new group.<br/>
	 * Get the {@link Builder} for the Group, as expected by the createGroup query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getCreateGroupResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "createGroup", RequestType.mutation,
			InputParameter.newBindParameter("", "group", "mutationCreateGroupGroup", InputParameterType.MANDATORY,
				"GroupInput", true, 0, false));
	}

	/**
	 * Creates a new group.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the createGroup REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF= "https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getCreateGroupGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createGroup",
			InputParameter.newBindParameter("", "group", "mutationCreateGroupGroup", InputParameterType.MANDATORY,
				"GroupInput", true, 0, false));
	}

	/**
	 * Updates an existing group. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Group> mono = executor.updateGroupWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			group, // A value for updateGroup's group input parameter
	 * 			params);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param group Parameter for the updateGroup field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> updateGroupWithBindValues(String queryResponseDef, GroupInput group,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		LOGGER.debug("Executing mutation 'updateGroup': {} ", queryResponseDef);
		ObjectResponse objectResponse = getUpdateGroupResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateGroupWithBindValues(objectResponse, group, parameters);
	}

	/**
	 * Updates an existing group.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Group> mono = executor.updateGroup(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			group, // A value for updateGroup's group input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param group Parameter for the updateGroup field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> updateGroup(String queryResponseDef, GroupInput group, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		LOGGER.debug("Executing mutation 'updateGroup': {} ", queryResponseDef);
		ObjectResponse objectResponse = getUpdateGroupResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateGroupWithBindValues(objectResponse, group,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing group.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getUpdateGroupGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Group> mono = executor.updateGroupWithBindValues(preparedRequest, group, // A value for
	 * 																						// updateGroup's group
	 * 																						// input parameter
	 * 			params);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateGroupGraphQLRequest(String)} method.
	 * @param group Parameter for the updateGroup field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> updateGroupWithBindValues(ObjectResponse objectResponse, GroupInput group,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'updateGroup' with parameters: {} ", group);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updateGroup'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdateGroupGroup", group);

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getUpdateGroup() == null) ? Optional.empty() : Optional.of(t.getUpdateGroup()));
	}

	/**
	 * Updates an existing group.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getUpdateGroupGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Group> mono = executor.updateGroup(preparedRequest, group, // A value for updateGroup's group input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateGroupGraphQLRequest(String)} method.
	 * @param group Parameter for the updateGroup field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> updateGroup(ObjectResponse objectResponse, GroupInput group, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updateGroup' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'updateGroup' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdateGroupGroup", group);

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getUpdateGroup() == null) ? Optional.empty() : Optional.of(t.getUpdateGroup()));
	}

	/**
	 * Updates an existing group.<br/>
	 * Get the {@link Builder} for the Group, as expected by the updateGroup query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getUpdateGroupResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "updateGroup", RequestType.mutation,
			InputParameter.newBindParameter("", "group", "mutationUpdateGroupGroup", InputParameterType.MANDATORY,
				"GroupInput", true, 0, false));
	}

	/**
	 * Updates an existing group.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updateGroup REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF= "https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdateGroupGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateGroup",
			InputParameter.newBindParameter("", "group", "mutationUpdateGroupGroup", InputParameterType.MANDATORY,
				"GroupInput", true, 0, false));
	}

	/**
	 * Deletes an existing group. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Group> mono = executor.deleteGroupWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			groupId, // A value for deleteGroup's groupId input parameter
	 * 			params);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param groupId Parameter for the deleteGroup field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "deleteGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> deleteGroupWithBindValues(String queryResponseDef, String groupId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		LOGGER.debug("Executing mutation 'deleteGroup': {} ", queryResponseDef);
		ObjectResponse objectResponse = getDeleteGroupResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteGroupWithBindValues(objectResponse, groupId, parameters);
	}

	/**
	 * Deletes an existing group.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Group> mono = executor.deleteGroup(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			groupId, // A value for deleteGroup's groupId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param groupId Parameter for the deleteGroup field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "deleteGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> deleteGroup(String queryResponseDef, String groupId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		LOGGER.debug("Executing mutation 'deleteGroup': {} ", queryResponseDef);
		ObjectResponse objectResponse = getDeleteGroupResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteGroupWithBindValues(objectResponse, groupId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Deletes an existing group.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getDeleteGroupGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Group> mono = executor.deleteGroupWithBindValues(preparedRequest, groupId, // A value for
	 * 																						// deleteGroup's groupId
	 * 																						// input parameter
	 * 			params);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteGroupGraphQLRequest(String)} method.
	 * @param groupId Parameter for the deleteGroup field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "deleteGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> deleteGroupWithBindValues(ObjectResponse objectResponse, String groupId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'deleteGroup' with parameters: {} ", groupId);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deleteGroup'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationDeleteGroupGroupId", groupId);

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getDeleteGroup() == null) ? Optional.empty() : Optional.of(t.getDeleteGroup()));
	}

	/**
	 * Deletes an existing group.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getDeleteGroupGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Group> mono = executor.deleteGroup(preparedRequest, groupId, // A value for deleteGroup's groupId
	 * 																			// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteGroupGraphQLRequest(String)} method.
	 * @param groupId Parameter for the deleteGroup field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "deleteGroup", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> deleteGroup(ObjectResponse objectResponse, String groupId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'deleteGroup' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'deleteGroup' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationDeleteGroupGroupId", groupId);

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getDeleteGroup() == null) ? Optional.empty() : Optional.of(t.getDeleteGroup()));
	}

	/**
	 * Deletes an existing group.<br/>
	 * Get the {@link Builder} for the Group, as expected by the deleteGroup query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getDeleteGroupResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "deleteGroup", RequestType.mutation,
			InputParameter.newBindParameter("", "groupId", "mutationDeleteGroupGroupId", InputParameterType.MANDATORY,
				"ID", true, 0, false));
	}

	/**
	 * Deletes an existing group.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the deleteGroup REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF= "https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeleteGroupGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteGroup",
			InputParameter.newBindParameter("", "groupId", "mutationDeleteGroupGroupId", InputParameterType.MANDATORY,
				"ID", true, 0, false));
	}

	/**
	 * Adds a user to a group. This method executes a partial query against the GraphQL server. That is, the query that
	 * is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the query
	 * that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Group> mono = executor.addGroupMemberWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			groupId, // A value for addGroupMember's groupId input parameter
	 * 			userId, // A value for addGroupMember's userId input parameter
	 * 			params);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param groupId Parameter for the addGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param userId Parameter for the addGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "addGroupMember", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> addGroupMemberWithBindValues(String queryResponseDef, String groupId, String userId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		LOGGER.debug("Executing mutation 'addGroupMember': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getAddGroupMemberResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return addGroupMemberWithBindValues(objectResponse, groupId, userId, parameters);
	}

	/**
	 * Adds a user to a group.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Group> mono = executor.addGroupMember(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			groupId, // A value for addGroupMember's groupId input parameter
	 * 			userId, // A value for addGroupMember's userId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param groupId Parameter for the addGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param userId Parameter for the addGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "addGroupMember", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> addGroupMember(String queryResponseDef, String groupId, String userId,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		LOGGER.debug("Executing mutation 'addGroupMember': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getAddGroupMemberResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return addGroupMemberWithBindValues(objectResponse, groupId, userId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Adds a user to a group.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getAddGroupMemberGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Group> mono = executor.addGroupMemberWithBindValues(preparedRequest, groupId, // A value for
	 * 																							// addGroupMember's
	 * 																							// groupId input
	 * 																							// parameter
	 * 			userId, // A value for addGroupMember's userId input parameter
	 * 			params);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getAddGroupMemberGraphQLRequest(String)} method.
	 * @param groupId Parameter for the addGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param userId Parameter for the addGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "addGroupMember", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> addGroupMemberWithBindValues(ObjectResponse objectResponse, String groupId,
		String userId, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'addGroupMember' with parameters: {}, {} ", groupId, userId);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'addGroupMember'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationAddGroupMemberGroupId", groupId);
		parametersLocal.put("mutationAddGroupMemberUserId", userId);

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getAddGroupMember() == null) ? Optional.empty() : Optional.of(t.getAddGroupMember()));
	}

	/**
	 * Adds a user to a group.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getAddGroupMemberGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Group> mono = executor.addGroupMember(preparedRequest, groupId, // A value for addGroupMember's
	 * 																				// groupId input parameter
	 * 			userId, // A value for addGroupMember's userId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getAddGroupMemberGraphQLRequest(String)} method.
	 * @param groupId Parameter for the addGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param userId Parameter for the addGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "addGroupMember", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> addGroupMember(ObjectResponse objectResponse, String groupId, String userId,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'addGroupMember' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'addGroupMember' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationAddGroupMemberGroupId", groupId);
		parameters.put("mutationAddGroupMemberUserId", userId);

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getAddGroupMember() == null) ? Optional.empty() : Optional.of(t.getAddGroupMember()));
	}

	/**
	 * Adds a user to a group.<br/>
	 * Get the {@link Builder} for the Group, as expected by the addGroupMember query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getAddGroupMemberResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "addGroupMember", RequestType.mutation,
			InputParameter.newBindParameter("", "groupId", "mutationAddGroupMemberGroupId",
				InputParameterType.MANDATORY, "ID", true, 0, false),
			InputParameter.newBindParameter("", "userId", "mutationAddGroupMemberUserId", InputParameterType.MANDATORY,
				"ID", true, 0, false));
	}

	/**
	 * Adds a user to a group.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the addGroupMember REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF= "https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getAddGroupMemberGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "addGroupMember",
			InputParameter.newBindParameter("", "groupId", "mutationAddGroupMemberGroupId",
				InputParameterType.MANDATORY, "ID", true, 0, false),
			InputParameter.newBindParameter("", "userId", "mutationAddGroupMemberUserId", InputParameterType.MANDATORY,
				"ID", true, 0, false));
	}

	/**
	 * Removes a user from a group. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Group> mono = executor.removeGroupMemberWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			groupId, // A value for removeGroupMember's groupId input parameter
	 * 			userId, // A value for removeGroupMember's userId input parameter
	 * 			params);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param groupId Parameter for the removeGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param userId Parameter for the removeGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "removeGroupMember", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> removeGroupMemberWithBindValues(String queryResponseDef, String groupId, String userId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		LOGGER.debug("Executing mutation 'removeGroupMember': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getRemoveGroupMemberResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return removeGroupMemberWithBindValues(objectResponse, groupId, userId, parameters);
	}

	/**
	 * Removes a user from a group.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Group> mono = executor.removeGroupMember(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			groupId, // A value for removeGroupMember's groupId input parameter
	 * 			userId, // A value for removeGroupMember's userId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param groupId Parameter for the removeGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param userId Parameter for the removeGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "removeGroupMember", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> removeGroupMember(String queryResponseDef, String groupId, String userId,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		LOGGER.debug("Executing mutation 'removeGroupMember': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getRemoveGroupMemberResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return removeGroupMemberWithBindValues(objectResponse, groupId, userId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Removes a user from a group.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getRemoveGroupMemberGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Group> mono = executor.removeGroupMemberWithBindValues(preparedRequest, groupId, // A value for
	 * 																								// removeGroupMember's
	 * 																								// groupId input
	 * 																								// parameter
	 * 			userId, // A value for removeGroupMember's userId input parameter
	 * 			params);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getRemoveGroupMemberGraphQLRequest(String)} method.
	 * @param groupId Parameter for the removeGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param userId Parameter for the removeGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "removeGroupMember", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> removeGroupMemberWithBindValues(ObjectResponse objectResponse, String groupId,
		String userId, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'removeGroupMember' with parameters: {}, {} ", groupId, userId);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'removeGroupMember'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationRemoveGroupMemberGroupId", groupId);
		parametersLocal.put("mutationRemoveGroupMemberUserId", userId);

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getRemoveGroupMember() == null) ? Optional.empty() : Optional.of(t.getRemoveGroupMember()));
	}

	/**
	 * Removes a user from a group.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getRemoveGroupMemberGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Group> mono = executor.removeGroupMember(preparedRequest, groupId, // A value for
	 * 																				// removeGroupMember's groupId
	 * 																				// input parameter
	 * 			userId, // A value for removeGroupMember's userId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getRemoveGroupMemberGraphQLRequest(String)} method.
	 * @param groupId Parameter for the removeGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param userId Parameter for the removeGroupMember field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "removeGroupMember", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> removeGroupMember(ObjectResponse objectResponse, String groupId, String userId,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'removeGroupMember' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'removeGroupMember' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationRemoveGroupMemberGroupId", groupId);
		parameters.put("mutationRemoveGroupMemberUserId", userId);

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getRemoveGroupMember() == null) ? Optional.empty() : Optional.of(t.getRemoveGroupMember()));
	}

	/**
	 * Removes a user from a group.<br/>
	 * Get the {@link Builder} for the Group, as expected by the removeGroupMember query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getRemoveGroupMemberResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "removeGroupMember", RequestType.mutation,
			InputParameter.newBindParameter("", "groupId", "mutationRemoveGroupMemberGroupId",
				InputParameterType.MANDATORY, "ID", true, 0, false),
			InputParameter.newBindParameter("", "userId", "mutationRemoveGroupMemberUserId",
				InputParameterType.MANDATORY, "ID", true, 0, false));
	}

	/**
	 * Removes a user from a group.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the removeGroupMember REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF= "https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getRemoveGroupMemberGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "removeGroupMember",
			InputParameter.newBindParameter("", "groupId", "mutationRemoveGroupMemberGroupId",
				InputParameterType.MANDATORY, "ID", true, 0, false),
			InputParameter.newBindParameter("", "userId", "mutationRemoveGroupMemberUserId",
				InputParameterType.MANDATORY, "ID", true, 0, false));
	}

	/**
	 * Grants authorities to a group. The specified authorities are added to any existing ones. This method executes a
	 * partial query against the GraphQL server. That is, the query that is one of the queries defined in the GraphQL
	 * query object. The queryResponseDef contains the part of the query that <B><U>is after</U></B> the query
	 * name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Group> mono = executor.grantGroupAuthoritiesWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for grantGroupAuthorities's userId input parameter
	 * 			authorities, // A value for grantGroupAuthorities's authorities input parameter
	 * 			params);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param groupId Parameter for the grantGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the grantGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantGroupAuthorities", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> grantGroupAuthoritiesWithBindValues(String queryResponseDef, String groupId,
		List<AuthorityKind> authorities, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		LOGGER.debug("Executing mutation 'grantGroupAuthorities': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getGrantGroupAuthoritiesResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return grantGroupAuthoritiesWithBindValues(objectResponse, groupId, authorities, parameters);
	}

	/**
	 * Grants authorities to a group. The specified authorities are added to any existing ones.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Group> mono = executor.grantGroupAuthorities(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for grantGroupAuthorities's userId input parameter
	 * 			authorities, // A value for grantGroupAuthorities's authorities input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param groupId Parameter for the grantGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the grantGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantGroupAuthorities", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> grantGroupAuthorities(String queryResponseDef, String groupId,
		List<AuthorityKind> authorities, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		LOGGER.debug("Executing mutation 'grantGroupAuthorities': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getGrantGroupAuthoritiesResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return grantGroupAuthoritiesWithBindValues(objectResponse, groupId, authorities,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Grants authorities to a group. The specified authorities are added to any existing ones.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getGrantGroupAuthoritiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Group> mono = executor.grantGroupAuthoritiesWithBindValues(preparedRequest, userId, // A value for
	 * 																									// grantGroupAuthorities's
	 * 																									// userId
	 * 																									// input
	 * 																									// parameter
	 * 			authorities, // A value for grantGroupAuthorities's authorities input parameter
	 * 			params);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGrantGroupAuthoritiesGraphQLRequest(String)} method.
	 * @param groupId Parameter for the grantGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the grantGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantGroupAuthorities", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> grantGroupAuthoritiesWithBindValues(ObjectResponse objectResponse, String groupId,
		List<AuthorityKind> authorities, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'grantGroupAuthorities' with parameters: {}, {} ", groupId, authorities);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'grantGroupAuthorities'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationGrantGroupAuthoritiesGroupId", groupId);
		parametersLocal.put("mutationGrantGroupAuthoritiesAuthorities", authorities);

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getGrantGroupAuthorities() == null) ? Optional.empty()
				: Optional.of(t.getGrantGroupAuthorities()));
	}

	/**
	 * Grants authorities to a group. The specified authorities are added to any existing ones.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getGrantGroupAuthoritiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Group> mono = executor.grantGroupAuthorities(preparedRequest, userId, // A value for
	 * 																					// grantGroupAuthorities's
	 * 																					// userId input parameter
	 * 			authorities, // A value for grantGroupAuthorities's authorities input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGrantGroupAuthoritiesGraphQLRequest(String)} method.
	 * @param groupId Parameter for the grantGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the grantGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantGroupAuthorities", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> grantGroupAuthorities(ObjectResponse objectResponse, String groupId,
		List<AuthorityKind> authorities, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'grantGroupAuthorities' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'grantGroupAuthorities' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationGrantGroupAuthoritiesGroupId", groupId);
		parameters.put("mutationGrantGroupAuthoritiesAuthorities", authorities);

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getGrantGroupAuthorities() == null) ? Optional.empty()
				: Optional.of(t.getGrantGroupAuthorities()));
	}

	/**
	 * Grants authorities to a group. The specified authorities are added to any existing ones.<br/>
	 * Get the {@link Builder} for the Group, as expected by the grantGroupAuthorities query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getGrantGroupAuthoritiesResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "grantGroupAuthorities",
			RequestType.mutation,
			InputParameter.newBindParameter("", "groupId", "mutationGrantGroupAuthoritiesGroupId",
				InputParameterType.MANDATORY, "ID", true, 0, false),
			InputParameter.newBindParameter("", "authorities", "mutationGrantGroupAuthoritiesAuthorities",
				InputParameterType.MANDATORY, "AuthorityKind", true, 1, true));
	}

	/**
	 * Grants authorities to a group. The specified authorities are added to any existing ones.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the grantGroupAuthorities REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF= "https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getGrantGroupAuthoritiesGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation,
			"grantGroupAuthorities",
			InputParameter.newBindParameter("", "groupId", "mutationGrantGroupAuthoritiesGroupId",
				InputParameterType.MANDATORY, "ID", true, 0, false),
			InputParameter.newBindParameter("", "authorities", "mutationGrantGroupAuthoritiesAuthorities",
				InputParameterType.MANDATORY, "AuthorityKind", true, 1, true));
	}

	/**
	 * Revokes authorities from a group. The specified authorities are removed from the group; other authorities remain
	 * intact. This method executes a partial query against the GraphQL server. That is, the query that is one of the
	 * queries defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Group> mono = executor.revokeGroupAuthoritiesWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for revokeGroupAuthorities's userId input parameter
	 * 			authorities, // A value for revokeGroupAuthorities's authorities input parameter
	 * 			params);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param groupId Parameter for the revokeGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the revokeGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeGroupAuthorities", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> revokeGroupAuthoritiesWithBindValues(String queryResponseDef, String groupId,
		List<AuthorityKind> authorities, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		LOGGER.debug("Executing mutation 'revokeGroupAuthorities': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getRevokeGroupAuthoritiesResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return revokeGroupAuthoritiesWithBindValues(objectResponse, groupId, authorities, parameters);
	}

	/**
	 * Revokes authorities from a group. The specified authorities are removed from the group; other authorities remain
	 * intact.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Group> mono = executor.revokeGroupAuthorities(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for revokeGroupAuthorities's userId input parameter
	 * 			authorities, // A value for revokeGroupAuthorities's authorities input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param groupId Parameter for the revokeGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the revokeGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeGroupAuthorities", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> revokeGroupAuthorities(String queryResponseDef, String groupId,
		List<AuthorityKind> authorities, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		LOGGER.debug("Executing mutation 'revokeGroupAuthorities': {} ", queryResponseDef);
		ObjectResponse objectResponse =
			getRevokeGroupAuthoritiesResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return revokeGroupAuthoritiesWithBindValues(objectResponse, groupId, authorities,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Revokes authorities from a group. The specified authorities are removed from the group; other authorities remain
	 * intact.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getRevokeGroupAuthoritiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Group> mono = executor.revokeGroupAuthoritiesWithBindValues(preparedRequest, userId, // A value for
	 * 																									// revokeGroupAuthorities's
	 * 																									// userId
	 * 																									// input
	 * 																									// parameter
	 * 			authorities, // A value for revokeGroupAuthorities's authorities input parameter
	 * 			params);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getRevokeGroupAuthoritiesGraphQLRequest(String)} method.
	 * @param groupId Parameter for the revokeGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the revokeGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeGroupAuthorities", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> revokeGroupAuthoritiesWithBindValues(ObjectResponse objectResponse, String groupId,
		List<AuthorityKind> authorities, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation 'revokeGroupAuthorities' with parameters: {}, {} ", groupId, authorities);
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'revokeGroupAuthorities'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationRevokeGroupAuthoritiesGroupId", groupId);
		parametersLocal.put("mutationRevokeGroupAuthoritiesAuthorities", authorities);

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getRevokeGroupAuthorities() == null) ? Optional.empty()
				: Optional.of(t.getRevokeGroupAuthorities()));
	}

	/**
	 * Revokes authorities from a group. The specified authorities are removed from the group; other authorities remain
	 * intact.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed
	 * 		// several times
	 * 		preparedRequest = executor.getRevokeGroupAuthoritiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Group> mono = executor.revokeGroupAuthorities(preparedRequest, userId, // A value for
	 * 																					// revokeGroupAuthorities's
	 * 																					// userId input parameter
	 * 			authorities, // A value for revokeGroupAuthorities's authorities input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Group field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getRevokeGroupAuthoritiesGraphQLRequest(String)} method.
	 * @param groupId Parameter for the revokeGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param authorities Parameter for the revokeGroupAuthorities field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeGroupAuthorities", graphQLTypeSimpleName = "Group", javaClass = Group.class)
	@GraphQLDirective(name = "@auth", parameterNames = { "authority" }, parameterTypes = { "[AuthorityKind!]" },
		parameterValues = { "[ADM]" })
	public Mono<Optional<Group>> revokeGroupAuthorities(ObjectResponse objectResponse, String groupId,
		List<AuthorityKind> authorities, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'revokeGroupAuthorities' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation 'revokeGroupAuthorities' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationRevokeGroupAuthoritiesGroupId", groupId);
		parameters.put("mutationRevokeGroupAuthoritiesAuthorities", authorities);

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getRevokeGroupAuthorities() == null) ? Optional.empty()
				: Optional.of(t.getRevokeGroupAuthorities()));
	}

	/**
	 * Revokes authorities from a group. The specified authorities are removed from the group; other authorities remain
	 * intact.<br/>
	 * Get the {@link Builder} for the Group, as expected by the revokeGroupAuthorities query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder getRevokeGroupAuthoritiesResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "revokeGroupAuthorities",
			RequestType.mutation,
			InputParameter.newBindParameter("", "groupId", "mutationRevokeGroupAuthoritiesGroupId",
				InputParameterType.MANDATORY, "ID", true, 0, false),
			InputParameter.newBindParameter("", "authorities", "mutationRevokeGroupAuthoritiesAuthorities",
				InputParameterType.MANDATORY, "AuthorityKind", true, 1, true));
	}

	/**
	 * Revokes authorities from a group. The specified authorities are removed from the group; other authorities remain
	 * intact.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the revokeGroupAuthorities REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF= "https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getRevokeGroupAuthoritiesGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation,
			"revokeGroupAuthorities",
			InputParameter.newBindParameter("", "groupId", "mutationRevokeGroupAuthoritiesGroupId",
				InputParameterType.MANDATORY, "ID", true, 0, false),
			InputParameter.newBindParameter("", "authorities", "mutationRevokeGroupAuthoritiesAuthorities",
				InputParameterType.MANDATORY, "AuthorityKind", true, 1, true));
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<String> mono = executor.__typenameWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			params);
	 * 		String field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "__typename", graphQLTypeSimpleName = "String", javaClass = String.class)
	public Mono<Optional<String>> __typenameWithBindValues(String queryResponseDef, Map<String, Object> parameters)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation '__typename': {} ", queryResponseDef);
		ObjectResponse objectResponse = get__typenameResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return __typenameWithBindValues(objectResponse, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<String> mono = executor.__typename(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		String field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "__typename", graphQLTypeSimpleName = "String", javaClass = String.class)
	public Mono<Optional<String>> __typename(String queryResponseDef, Object... paramsAndValues)
		throws GraphQLRequestPreparationException, GraphQLRequestExecutionException {

		LOGGER.debug("Executing mutation '__typename': {} ", queryResponseDef);
		ObjectResponse objectResponse = get__typenameResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return __typenameWithBindValues(objectResponse,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.get__typenameGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<String> mono = executor.__typenameWithBindValues(preparedRequest, params);
	 * 		String field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link get__typenameGraphQLRequest(String)} method.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "__typename", graphQLTypeSimpleName = "String", javaClass = String.class)
	public Mono<Optional<String>> __typenameWithBindValues(ObjectResponse objectResponse,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			LOGGER.trace("Executing mutation '__typename' with parameters: ");
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation '__typename'");
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();

		return objectResponse.execReactive(Mutation.class, parametersLocal)
			.map(t -> (t.get__typename() == null) ? Optional.empty() : Optional.of(t.get__typename()));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.get__typenameGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<String> mono = executor.__typename(preparedRequest, "param", paramValue, // param is optional, as it
	 * 																						// is marked by a "?" in
	 * 																						// the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		String field = mono.block();
	 * 	}
	 * 
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link get__typenameGraphQLRequest(String)} method.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "__typename", graphQLTypeSimpleName = "String", javaClass = String.class)
	public Mono<Optional<String>> __typename(ObjectResponse objectResponse, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {

		if (LOGGER.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation '__typename' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			LOGGER.trace(sb.toString());
		} else if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Executing mutation '__typename' (with bind variables)");
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);

		return objectResponse.execReactive(Mutation.class, parameters)
			.map(t -> (t.get__typename() == null) ? Optional.empty() : Optional.of(t.get__typename()));
	}

	/**
	 * Get the {@link Builder} for the String, as expected by the __typename query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public Builder get__typenameResponseBuilder() throws GraphQLRequestPreparationException {
		return new Builder(this.graphQlClient, GraphQLReactiveRequest.class, "__typename", RequestType.mutation);
	}

	/**
	 * Get the {@link GraphQLReactiveRequest} for the __typename REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest get__typenameGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "__typename");
	}

}
