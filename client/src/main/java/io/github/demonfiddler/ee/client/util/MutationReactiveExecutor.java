/*----------------------------------------------------------------------------------------------------------------------
 * Evidence Engine: A system for managing evidence on arbitrary scientific topics.
 * Comprises an SQL database, GraphQL public API, Java app server, Java and web clients.
 * Copyright Â© 2024 Adrian Price. All rights reserved.
 *
 * This file is part of Evidence Engine.
 *
 * Evidence Engine is free software: you can redistribute it and/or modify it under the terms of the
 * GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * Evidence Engine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License along with Evidence Engine.
 * If not, see <https://www.gnu.org/licenses/>. 
 *--------------------------------------------------------------------------------------------------------------------*/

package io.github.demonfiddler.ee.client.util;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.graphql.client.GraphQlClient;
import org.springframework.stereotype.Component;

import com.graphql_java_generator.annotation.GraphQLNonScalar;
import com.graphql_java_generator.annotation.GraphQLScalar;
import com.graphql_java_generator.annotation.RequestType;
import com.graphql_java_generator.client.GraphQLMutationReactiveExecutor;
import com.graphql_java_generator.client.GraphqlClientUtils;
import com.graphql_java_generator.client.request.InputParameter;
import com.graphql_java_generator.client.request.InputParameter.InputParameterType;
import com.graphql_java_generator.client.request.ObjectResponse;
import com.graphql_java_generator.customscalars.GraphQLScalarTypeDate;
import com.graphql_java_generator.exception.GraphQLRequestExecutionException;
import com.graphql_java_generator.exception.GraphQLRequestPreparationException;
import com.graphql_java_generator.util.GraphqlUtils;

import io.github.demonfiddler.ee.client.Claim;
import io.github.demonfiddler.ee.client.ClaimInput;
import io.github.demonfiddler.ee.client.Declaration;
import io.github.demonfiddler.ee.client.DeclarationInput;
import io.github.demonfiddler.ee.client.EntityKind;
import io.github.demonfiddler.ee.client.Journal;
import io.github.demonfiddler.ee.client.JournalInput;
import io.github.demonfiddler.ee.client.LinkEntitiesInput;
import io.github.demonfiddler.ee.client.Mutation;
import io.github.demonfiddler.ee.client.PermissionKind;
import io.github.demonfiddler.ee.client.Person;
import io.github.demonfiddler.ee.client.PersonInput;
import io.github.demonfiddler.ee.client.Publication;
import io.github.demonfiddler.ee.client.PublicationInput;
import io.github.demonfiddler.ee.client.Publisher;
import io.github.demonfiddler.ee.client.PublisherInput;
import io.github.demonfiddler.ee.client.Quotation;
import io.github.demonfiddler.ee.client.QuotationInput;
import io.github.demonfiddler.ee.client.StatusKind;
import io.github.demonfiddler.ee.client.Topic;
import io.github.demonfiddler.ee.client.TopicInput;
import io.github.demonfiddler.ee.client.TopicRefInput;
import io.github.demonfiddler.ee.client.User;
import io.github.demonfiddler.ee.client.UserInput;
import reactor.core.publisher.Mono;

/**
 * Available mutations. <BR/>
 * This class contains the methods that allows the execution of the queries or mutations that are defined in the
 * Mutation of the GraphQL schema. All the methods for this executor are in spring reactive, that is: they return a
 * {@link Mono}.<BR/>
 * These methods allows:
 * <UL>
 * <LI>Preparation of full requests</LI>
 * <LI>Execution of prepared full requests</LI>
 * <LI>Execution of direct full direct requests</LI>
 * <LI>Preparation of partial requests</LI>
 * <LI>Execution of prepared partial requests</LI>
 * <LI>Execution of direct partial requests</LI>
 * </UL>
 * You'll find all the documentation on the
 * <A HREF="https://github.com/graphql-java-generator/graphql-maven-plugin-project/wiki/client_spring">client page
 * doc</A>.
 * @author generated by graphql-java-generator
 */
@Component
public class MutationReactiveExecutor implements GraphQLMutationReactiveExecutor {

	/** Logger for this class */
	private static Logger logger = LoggerFactory.getLogger(MutationReactiveExecutor.class);

	@Autowired
	@Qualifier("httpGraphQlClient")
	GraphQlClient graphQlClient;

	GraphqlUtils graphqlUtils = GraphqlUtils.graphqlUtils; // must be set that way, to be used in the constructor

	@Autowired
	GraphqlClientUtils graphqlClientUtils;

	public MutationReactiveExecutor() {
		if (!"2.8".equals(this.graphqlUtils.getRuntimeVersion())) { //$NON-NLS-1$
			throw new RuntimeException(
				"The GraphQL runtime version doesn't match the GraphQL plugin version. The runtime's version is '" //$NON-NLS-1$
					+ this.graphqlUtils.getRuntimeVersion() + "' whereas the GraphQL plugin version is '2.8'"); //$NON-NLS-1$
		}
		CustomScalarRegistryInitializer.initCustomScalarRegistry();
		DirectiveRegistryInitializer.initDirectiveRegistry();
	}

	/**
	 * This method takes a <B>full request</B> definition, and executes it against the GraphQL server. As this class is
	 * a mutation executor, the provided request must be a mutation full request. This request will be executed in
	 * reactive mode, that is: it returns a {@link Mono}<Mutation><BR/>
	 * This method offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace
	 * mode).<BR/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 *     @Autowired
	 *     MutationExecutor executor;
	 * 
	 *     void myMethod() {
	 * 	        Map<String, Object> params = new HashMap<>();
	 *          params.put("param", paramValue);   // param is optional, as it is marked by a "?" in the request
	 *          params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 *          
	 *          Mono<Mutation> mono = executor.execWithBindValues(
	 *              "mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}",
	 *              callback,
	 *              params);
	 *          Mutation mutation = mono.block();
	 *          FieldType field = mutation.getSampleQueryOrMutationField();
	 *
	 *          .... do something with this field's value
	 *     }
	 * }
	 * 
	 * 
	 * 
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("heroParam", heroParamValue);
	 * params.put("skip", Boolean.FALSE);
	 * 
	 * Mono<Mutation> mono = myQueryType.execWithBindValues(
	 * 		"{hero(param:?heroParam) @include(if:true) {id name @skip(if: ?skip) appearsIn friends {id name}}}",
	 * 		params);
	 * ...
	 * Mutation response = mono.block();
	 * Character c = response.getHero();
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the mutation, in the native GraphQL format (see here above).
	 * It must ommit the query/mutation/subscription keyword, and start by the first { that follows.It may contain
	 * directives, as explained in the GraphQL specs.
	 * @param parameters The map of values, for the bind variables defined in the query. If there is no bind variable in
	 * the defined Query, this argument may be null or an empty {@link Map}. The key is the parameter name, as defined
	 * in the query (in the above sample: heroParam is an optional parameter and skip is a mandatory one). The value is
	 * the parameter vale in its Java type (for instance a {@link Date} for the {@link GraphQLScalarTypeDate}). The
	 * parameters which value is missing in this map will no be transmitted toward the GraphQL server.
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	public Mono<Mutation> execWithBindValues(String queryResponseDef, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return execWithBindValues(objectResponse, parameters);
	}

	/**
	 * This method takes a <B>full request</B> definition, and executes it against the GraphQL server. As this class is
	 * a mutation executor, the provided request must be a mutation full request. This request will be executed in
	 * reactive mode, that is: it returns a {@link Mono}<Mutation><BR/>
	 * This method offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace
	 * mode).<BR/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 *     @Autowired
	 *     MutationExecutor executor;
	 * 
	 *     void myMethod() {
	 *          Mono<Mutation> mono = executor.exec(
	 *              "mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}",
	 *              "param", paramValue,   // param is optional, as it is marked by a "?" in the request
	 *              "skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 *              );
	 *          Mutation mutation = mono.block();
	 *          FieldType field = mutation.getSampleQueryOrMutationField();
	 *
	 *          .... do something with this field's value
	 *     }
	 * }
	 * </PRE>
	 * 
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above). It
	 * must ommit the query/mutation/subscription keyword, and start by the first { that follows.It may contain
	 * directives, as explained in the GraphQL specs.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	public Mono<Mutation> exec(String queryResponseDef, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return execWithBindValues(objectResponse,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method takes a <B>full request</B> definition, and executes it against the GraphQL server. As this class is
	 * a mutation executor, the provided request must be a mutation full request. This request will be executed in
	 * reactive mode, that is: it returns a {@link Mono}<Mutation><BR/>
	 * This method offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace
	 * mode).<BR/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 *     &#64;Autowired
	 *     MutationExecutor executor;
	 *     
	 *     GraphQLRequest preparedRequest;
	 *     
	 *     @PostConstruct
	 *     public void setup() {
	 *         // Preparation of the query, so that it is prepared once then executed several times
	 *         preparedRequest = executor
	 *             .getResponseBuilder()
	 *             .withQueryResponseDef("mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}")
	 *             .build();
	 *     }
	 * 
	 *     void myMethod() {
	 * 	        Map<String, Object> params = new HashMap<>();
	 *          params.put("param", paramValue);   // param is optional, as it is marked by a "?" in the request
	 *          params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 *          
	 *          Mono<Mutation> mono = executor.execWithBindValues(
	 *              preparedRequest,
	 *              params);
	 *          Mutation mutation = mono.block();
	 *          FieldType field = mutation.getSampleQueryOrMutationField();
	 *
	 *          .... do something with this field's value
	 *     }
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGraphQLRequest(String)} method or one of the <code>getXxxxGraphQLRequest(String)</code> methods.
	 * @param parameters The list of values, for the bind variables defined in the query. If there is no bind variable
	 * in the defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	public Mono<Mutation> execWithBindValues(ObjectResponse objectResponse, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			if (parameters == null) {
				logger.trace("Executing mutation without parameters"); //$NON-NLS-1$
			} else {
				StringBuilder sb = new StringBuilder("Executing root mutation with parameters: "); //$NON-NLS-1$
				boolean addComma = false;
				for (String key : parameters.keySet()) {
					sb.append(key).append(":").append(parameters.get(key)); //$NON-NLS-1$
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
				logger.trace(sb.toString());
			}
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'Mutation'"); //$NON-NLS-1$
		}

		return objectResponse.execReactive(Mutation.class, (parameters != null) ? parameters : new HashMap<>());
	}

	/**
	 * This method takes a <B>full request</B> definition, and executes it against the GraphQL server. As this class is
	 * a mutation executor, the provided request must be a mutation full request. This request will be executed in
	 * reactive mode, that is: it returns a {@link Mono}<Mutation><BR/>
	 * This method offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace
	 * mode).<BR/>
	 * Here is a sample on how to use it:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 *     &#64;Autowired
	 *     MutationExecutor executor;
	 *     
	 *     GraphQLRequest preparedRequest;
	 *     
	 *     @PostConstruct
	 *     public void setup() {
	 *         // Preparation of the query, so that it is prepared once then executed several times
	 *         preparedRequest = executor
	 *             .getResponseBuilder()
	 *             .withQueryResponseDef("mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}")
	 *             .build();
	 *     }
	 * 
	 *     void myMethod() {
	 *          Mono<Mutation> mono = executor.exec(
	 *              preparedRequest,
	 *              "param", paramValue,   // param is optional, as it is marked by a "?" in the request
	 *              "skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 *              );
	 *          Mutation mutation = mono.block();
	 *          FieldType field = mutation.getSampleQueryOrMutationField();
	 *
	 *          .... do something with this field's value
	 *     }
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGraphQLRequest(String)} method or one of the <code>getXxxxGraphQLRequest(String)</code> methods.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	public Mono<Mutation> exec(ObjectResponse objectResponse, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		return execWithBindValues(objectResponse,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for a <B>full request</B>, as expected by the
	 * exec and execWithBindValues methods.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class);
	}

	/**
	 * Get the {@link GraphQLReactiveRequest} for <B>full request</B>. For instance:
	 * 
	 * <PRE>
	 * GraphQLReactiveRequest request = new GraphQLRequest(fullRequest);
	 * </PRE>
	 * 
	 * @param fullRequest The full GraphQL Request, as specified in the GraphQL specification
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getGraphQLRequest(String fullRequest) throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(fullRequest);
	}

	/**
	 * Creates a new claim. This method executes a partial query against the GraphQL server. That is, the query that is
	 * one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the query that
	 * <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Claim> mono = executor.createClaimWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claim, // A value for createClaim's claim input parameter
	 * 			params);
	 * 		Claim field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param claim Parameter for the createClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Mono<Optional<Claim>> createClaimWithBindValues(String queryResponseDef, ClaimInput claim,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'createClaim': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getCreateClaimResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createClaimWithBindValues(objectResponse, claim, parameters);
	}

	/**
	 * Creates a new claim.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Claim> mono = executor.createClaim(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claim, // A value for createClaim's claim input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Claim field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param claim Parameter for the createClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Mono<Optional<Claim>> createClaim(String queryResponseDef, ClaimInput claim, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'createClaim': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getCreateClaimResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createClaimWithBindValues(objectResponse, claim,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Creates a new claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Claim> mono = executor.createClaimWithBindValues(preparedRequest, claim, // A value for
	 * 																						// createClaim's claim
	 * 																						// input parameter
	 * 			params);
	 * 		Claim field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateClaimGraphQLRequest(String)} method.
	 * @param claim Parameter for the createClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Mono<Optional<Claim>> createClaimWithBindValues(ObjectResponse objectResponse, ClaimInput claim,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'createClaim' with parameters: {} ", claim); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'createClaim'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationCreateClaimClaim", claim); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getCreateClaim() == null) ? Optional.empty() : Optional.of(t.getCreateClaim()));
	}

	/**
	 * Creates a new claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Claim> mono = executor.createClaim(preparedRequest, claim, // A value for createClaim's claim input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Claim field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateClaimGraphQLRequest(String)} method.
	 * @param claim Parameter for the createClaim field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Mono<Optional<Claim>> createClaim(ObjectResponse objectResponse, ClaimInput claim, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'createClaim' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'createClaim' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationCreateClaimClaim", claim); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getCreateClaim() == null) ? Optional.empty() : Optional.of(t.getCreateClaim()));
	}

	/**
	 * Creates a new claim.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Claim, as expected by the createClaim
	 * query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getCreateClaimResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"createClaim", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "claim", "mutationCreateClaimClaim", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"ClaimInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new claim.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the createClaim REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getCreateClaimGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createClaim" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "claim", "mutationCreateClaimClaim", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"ClaimInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing claim. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Claim> mono = executor.updateClaimWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claim, // A value for updateClaim's claim input parameter
	 * 			params);
	 * 		Claim field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param claim Parameter for the updateClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Mono<Optional<Claim>> updateClaimWithBindValues(String queryResponseDef, ClaimInput claim,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'updateClaim': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getUpdateClaimResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateClaimWithBindValues(objectResponse, claim, parameters);
	}

	/**
	 * Updates an existing claim.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Claim> mono = executor.updateClaim(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claim, // A value for updateClaim's claim input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Claim field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param claim Parameter for the updateClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Mono<Optional<Claim>> updateClaim(String queryResponseDef, ClaimInput claim, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'updateClaim': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getUpdateClaimResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateClaimWithBindValues(objectResponse, claim,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Claim> mono = executor.updateClaimWithBindValues(preparedRequest, claim, // A value for
	 * 																						// updateClaim's claim
	 * 																						// input parameter
	 * 			params);
	 * 		Claim field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateClaimGraphQLRequest(String)} method.
	 * @param claim Parameter for the updateClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)

	public Mono<Optional<Claim>> updateClaimWithBindValues(ObjectResponse objectResponse, ClaimInput claim,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'updateClaim' with parameters: {} ", claim); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'updateClaim'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdateClaimClaim", claim); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getUpdateClaim() == null) ? Optional.empty() : Optional.of(t.getUpdateClaim()));
	}

	/**
	 * Updates an existing claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Claim> mono = executor.updateClaim(preparedRequest, claim, // A value for updateClaim's claim input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Claim field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateClaimGraphQLRequest(String)} method.
	 * @param claim Parameter for the updateClaim field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Mono<Optional<Claim>> updateClaim(ObjectResponse objectResponse, ClaimInput claim, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updateClaim' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'updateClaim' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdateClaimClaim", claim); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getUpdateClaim() == null) ? Optional.empty() : Optional.of(t.getUpdateClaim()));
	}

	/**
	 * Updates an existing claim.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Claim, as expected by the updateClaim
	 * query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getUpdateClaimResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"updateClaim", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "claim", "mutationUpdateClaimClaim", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"ClaimInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing claim.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updateClaim REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdateClaimGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateClaim" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "claim", "mutationUpdateClaimClaim", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"ClaimInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing claim. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Claim> mono = executor.deleteClaimWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claimId, // A value for deleteClaim's claimId input parameter
	 * 			params);
	 * 		Claim field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param claimId Parameter for the deleteClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Mono<Optional<Claim>> deleteClaimWithBindValues(String queryResponseDef, Long claimId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'deleteClaim': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getDeleteClaimResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteClaimWithBindValues(objectResponse, claimId, parameters);
	}

	/**
	 * Deletes an existing claim.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Claim> mono = executor.deleteClaim(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			claimId, // A value for deleteClaim's claimId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Claim field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param claimId Parameter for the deleteClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Mono<Optional<Claim>> deleteClaim(String queryResponseDef, Long claimId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'deleteClaim': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getDeleteClaimResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteClaimWithBindValues(objectResponse, claimId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Deletes an existing claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Claim> mono = executor.deleteClaimWithBindValues(preparedRequest, claimId, // A value for
	 * 																						// deleteClaim's claimId
	 * 																						// input parameter
	 * 			params);
	 * 		Claim field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteClaimGraphQLRequest(String)} method.
	 * @param claimId Parameter for the deleteClaim field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Mono<Optional<Claim>> deleteClaimWithBindValues(ObjectResponse objectResponse, Long claimId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'deleteClaim' with parameters: {} ", claimId); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'deleteClaim'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationDeleteClaimClaimId", claimId); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getDeleteClaim() == null) ? Optional.empty() : Optional.of(t.getDeleteClaim()));
	}

	/**
	 * Deletes an existing claim.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteClaimGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Claim> mono = executor.deleteClaim(preparedRequest, claimId, // A value for deleteClaim's claimId
	 * 																			// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Claim field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteClaimGraphQLRequest(String)} method.
	 * @param claimId Parameter for the deleteClaim field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteClaim", graphQLTypeSimpleName = "Claim", javaClass = Claim.class)
	public Mono<Optional<Claim>> deleteClaim(ObjectResponse objectResponse, Long claimId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'deleteClaim' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'deleteClaim' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationDeleteClaimClaimId", claimId); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getDeleteClaim() == null) ? Optional.empty() : Optional.of(t.getDeleteClaim()));
	}

	/**
	 * Deletes an existing claim.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Claim, as expected by the deleteClaim
	 * query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getDeleteClaimResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"deleteClaim", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "claimId", "mutationDeleteClaimClaimId", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing claim.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the deleteClaim REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeleteClaimGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteClaim" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "claimId", "mutationDeleteClaimClaimId", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new declaration. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Declaration> mono = executor.createDeclarationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declaration, // A value for createDeclaration's declaration input parameter
	 * 			params);
	 * 		Declaration field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param declaration Parameter for the createDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Mono<Optional<Declaration>> createDeclarationWithBindValues(String queryResponseDef,
		DeclarationInput declaration, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'createDeclaration': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getCreateDeclarationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createDeclarationWithBindValues(objectResponse, declaration, parameters);
	}

	/**
	 * Creates a new declaration.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Declaration> mono = executor.createDeclaration(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declaration, // A value for createDeclaration's declaration input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Declaration field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param declaration Parameter for the createDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Mono<Optional<Declaration>> createDeclaration(String queryResponseDef, DeclarationInput declaration,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'createDeclaration': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getCreateDeclarationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createDeclarationWithBindValues(objectResponse, declaration,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Creates a new declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Declaration> mono = executor.createDeclarationWithBindValues(preparedRequest, declaration, // A
	 * 																										// value
	 * 																										// for
	 * 																										// createDeclaration's
	 * 																										// declaration
	 * 																										// input
	 * 																										// parameter
	 * 			params);
	 * 		Declaration field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateDeclarationGraphQLRequest(String)} method.
	 * @param declaration Parameter for the createDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)

	public Mono<Optional<Declaration>> createDeclarationWithBindValues(ObjectResponse objectResponse,
		DeclarationInput declaration, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'createDeclaration' with parameters: {} ", declaration); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'createDeclaration'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationCreateDeclarationDeclaration", declaration); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getCreateDeclaration() == null) ? Optional.empty() : Optional.of(t.getCreateDeclaration()));
	}

	/**
	 * Creates a new declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Declaration> mono = executor.createDeclaration(preparedRequest, declaration, // A value for
	 * 																							// createDeclaration's
	 * 																							// declaration input
	 * 																							// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Declaration field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateDeclarationGraphQLRequest(String)} method.
	 * @param declaration Parameter for the createDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Mono<Optional<Declaration>> createDeclaration(ObjectResponse objectResponse, DeclarationInput declaration,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'createDeclaration' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'createDeclaration' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationCreateDeclarationDeclaration", declaration); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getCreateDeclaration() == null) ? Optional.empty() : Optional.of(t.getCreateDeclaration()));
	}

	/**
	 * Creates a new declaration.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Declaration, as expected by the
	 * createDeclaration query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getCreateDeclarationResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"createDeclaration", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "declaration", "mutationCreateDeclarationDeclaration", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "DeclarationInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new declaration.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the createDeclaration REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getCreateDeclarationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createDeclaration" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "declaration", "mutationCreateDeclarationDeclaration", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "DeclarationInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing declaration. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Declaration> mono = executor.updateDeclarationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declaration, // A value for updateDeclaration's declaration input parameter
	 * 			params);
	 * 		Declaration field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param declaration Parameter for the updateDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Mono<Optional<Declaration>> updateDeclarationWithBindValues(String queryResponseDef,
		DeclarationInput declaration, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'updateDeclaration': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getUpdateDeclarationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateDeclarationWithBindValues(objectResponse, declaration, parameters);
	}

	/**
	 * Updates an existing declaration.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Declaration> mono = executor.updateDeclaration(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declaration, // A value for updateDeclaration's declaration input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Declaration field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param declaration Parameter for the updateDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Mono<Optional<Declaration>> updateDeclaration(String queryResponseDef, DeclarationInput declaration,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'updateDeclaration': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getUpdateDeclarationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateDeclarationWithBindValues(objectResponse, declaration,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Declaration> mono = executor.updateDeclarationWithBindValues(preparedRequest, declaration, // A
	 * 																										// value
	 * 																										// for
	 * 																										// updateDeclaration's
	 * 																										// declaration
	 * 																										// input
	 * 																										// parameter
	 * 			params);
	 * 		Declaration field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateDeclarationGraphQLRequest(String)} method.
	 * @param declaration Parameter for the updateDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)

	public Mono<Optional<Declaration>> updateDeclarationWithBindValues(ObjectResponse objectResponse,
		DeclarationInput declaration, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'updateDeclaration' with parameters: {} ", declaration); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'updateDeclaration'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdateDeclarationDeclaration", declaration); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getUpdateDeclaration() == null) ? Optional.empty() : Optional.of(t.getUpdateDeclaration()));
	}

	/**
	 * Updates an existing declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Declaration> mono = executor.updateDeclaration(preparedRequest, declaration, // A value for
	 * 																							// updateDeclaration's
	 * 																							// declaration input
	 * 																							// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Declaration field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateDeclarationGraphQLRequest(String)} method.
	 * @param declaration Parameter for the updateDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Mono<Optional<Declaration>> updateDeclaration(ObjectResponse objectResponse, DeclarationInput declaration,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updateDeclaration' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'updateDeclaration' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdateDeclarationDeclaration", declaration); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getUpdateDeclaration() == null) ? Optional.empty() : Optional.of(t.getUpdateDeclaration()));
	}

	/**
	 * Updates an existing declaration.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Declaration, as expected by the
	 * updateDeclaration query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getUpdateDeclarationResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"updateDeclaration", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "declaration", "mutationUpdateDeclarationDeclaration", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "DeclarationInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing declaration.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updateDeclaration REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdateDeclarationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateDeclaration" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "declaration", "mutationUpdateDeclarationDeclaration", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "DeclarationInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing declaration. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Declaration> mono = executor.deleteDeclarationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declarationId, // A value for deleteDeclaration's declarationId input parameter
	 * 			params);
	 * 		Declaration field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param declarationId Parameter for the deleteDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Mono<Optional<Declaration>> deleteDeclarationWithBindValues(String queryResponseDef, Long declarationId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'deleteDeclaration': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getDeleteDeclarationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteDeclarationWithBindValues(objectResponse, declarationId, parameters);
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Declaration> mono = executor.deleteDeclaration(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			declarationId, // A value for deleteDeclaration's declarationId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Declaration field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param declarationId Parameter for the deleteDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Mono<Optional<Declaration>> deleteDeclaration(String queryResponseDef, Long declarationId,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'deleteDeclaration': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getDeleteDeclarationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteDeclarationWithBindValues(objectResponse, declarationId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Declaration> mono = executor.deleteDeclarationWithBindValues(preparedRequest, declarationId, // A
	 * 																											// value
	 * 																											// for
	 * 																											// deleteDeclaration's
	 * 																											// declarationId
	 * 																											// input
	 * 																											// parameter
	 * 			params);
	 * 		Declaration field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteDeclarationGraphQLRequest(String)} method.
	 * @param declarationId Parameter for the deleteDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)

	public Mono<Optional<Declaration>> deleteDeclarationWithBindValues(ObjectResponse objectResponse,
		Long declarationId, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'deleteDeclaration' with parameters: {} ", declarationId); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'deleteDeclaration'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationDeleteDeclarationDeclarationId", declarationId); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getDeleteDeclaration() == null) ? Optional.empty() : Optional.of(t.getDeleteDeclaration()));
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteDeclarationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Declaration> mono = executor.deleteDeclaration(preparedRequest, declarationId, // A value for
	 * 																							// deleteDeclaration's
	 * 																							// declarationId
	 * 																							// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Declaration field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteDeclarationGraphQLRequest(String)} method.
	 * @param declarationId Parameter for the deleteDeclaration field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteDeclaration", graphQLTypeSimpleName = "Declaration",
		javaClass = Declaration.class)
	public Mono<Optional<Declaration>> deleteDeclaration(ObjectResponse objectResponse, Long declarationId,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'deleteDeclaration' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'deleteDeclaration' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationDeleteDeclarationDeclarationId", declarationId); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getDeleteDeclaration() == null) ? Optional.empty() : Optional.of(t.getDeleteDeclaration()));
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Declaration, as expected by the
	 * deleteDeclaration query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getDeleteDeclarationResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"deleteDeclaration", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "declarationId", "mutationDeleteDeclarationDeclarationId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing declaration.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the deleteDeclaration REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeleteDeclarationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteDeclaration" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "declarationId", "mutationDeleteDeclarationDeclarationId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Create a new journal. This method executes a partial query against the GraphQL server. That is, the query that is
	 * one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the query that
	 * <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Journal> mono = executor.createJournalWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journal, // A value for createJournal's journal input parameter
	 * 			params);
	 * 		Journal field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param journal Parameter for the createJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Mono<Optional<Journal>> createJournalWithBindValues(String queryResponseDef, JournalInput journal,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'createJournal': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getCreateJournalResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createJournalWithBindValues(objectResponse, journal, parameters);
	}

	/**
	 * Create a new journal.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Journal> mono = executor.createJournal(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journal, // A value for createJournal's journal input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Journal field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param journal Parameter for the createJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Mono<Optional<Journal>> createJournal(String queryResponseDef, JournalInput journal,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'createJournal': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getCreateJournalResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createJournalWithBindValues(objectResponse, journal,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Create a new journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Journal> mono = executor.createJournalWithBindValues(preparedRequest, journal, // A value for
	 * 																							// createJournal's
	 * 																							// journal input
	 * 																							// parameter
	 * 			params);
	 * 		Journal field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateJournalGraphQLRequest(String)} method.
	 * @param journal Parameter for the createJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)

	public Mono<Optional<Journal>> createJournalWithBindValues(ObjectResponse objectResponse, JournalInput journal,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'createJournal' with parameters: {} ", journal); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'createJournal'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationCreateJournalJournal", journal); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getCreateJournal() == null) ? Optional.empty() : Optional.of(t.getCreateJournal()));
	}

	/**
	 * Create a new journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Journal> mono = executor.createJournal(preparedRequest, journal, // A value for createJournal's
	 * 																				// journal input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Journal field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateJournalGraphQLRequest(String)} method.
	 * @param journal Parameter for the createJournal field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Mono<Optional<Journal>> createJournal(ObjectResponse objectResponse, JournalInput journal,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'createJournal' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'createJournal' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationCreateJournalJournal", journal); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getCreateJournal() == null) ? Optional.empty() : Optional.of(t.getCreateJournal()));
	}

	/**
	 * Create a new journal.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Journal, as expected by the
	 * createJournal query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getCreateJournalResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"createJournal", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "journal", "mutationCreateJournalJournal", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "JournalInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Create a new journal.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the createJournal REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getCreateJournalGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createJournal" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "journal", "mutationCreateJournalJournal", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "JournalInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing journal. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Journal> mono = executor.updateJournalWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journal, // A value for updateJournal's journal input parameter
	 * 			params);
	 * 		Journal field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param journal Parameter for the updateJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Mono<Optional<Journal>> updateJournalWithBindValues(String queryResponseDef, JournalInput journal,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'updateJournal': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getUpdateJournalResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateJournalWithBindValues(objectResponse, journal, parameters);
	}

	/**
	 * Updates an existing journal.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Journal> mono = executor.updateJournal(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journal, // A value for updateJournal's journal input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Journal field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param journal Parameter for the updateJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Mono<Optional<Journal>> updateJournal(String queryResponseDef, JournalInput journal,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'updateJournal': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getUpdateJournalResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateJournalWithBindValues(objectResponse, journal,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Journal> mono = executor.updateJournalWithBindValues(preparedRequest, journal, // A value for
	 * 																							// updateJournal's
	 * 																							// journal input
	 * 																							// parameter
	 * 			params);
	 * 		Journal field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateJournalGraphQLRequest(String)} method.
	 * @param journal Parameter for the updateJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)

	public Mono<Optional<Journal>> updateJournalWithBindValues(ObjectResponse objectResponse, JournalInput journal,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'updateJournal' with parameters: {} ", journal); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'updateJournal'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdateJournalJournal", journal); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getUpdateJournal() == null) ? Optional.empty() : Optional.of(t.getUpdateJournal()));
	}

	/**
	 * Updates an existing journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Journal> mono = executor.updateJournal(preparedRequest, journal, // A value for updateJournal's
	 * 																				// journal input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Journal field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateJournalGraphQLRequest(String)} method.
	 * @param journal Parameter for the updateJournal field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Mono<Optional<Journal>> updateJournal(ObjectResponse objectResponse, JournalInput journal,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updateJournal' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'updateJournal' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdateJournalJournal", journal); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getUpdateJournal() == null) ? Optional.empty() : Optional.of(t.getUpdateJournal()));
	}

	/**
	 * Updates an existing journal.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Journal, as expected by the
	 * updateJournal query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getUpdateJournalResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"updateJournal", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "journal", "mutationUpdateJournalJournal", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "JournalInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing journal.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updateJournal REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdateJournalGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateJournal" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "journal", "mutationUpdateJournalJournal", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "JournalInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing journal. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Journal> mono = executor.deleteJournalWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journalId, // A value for deleteJournal's journalId input parameter
	 * 			params);
	 * 		Journal field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param journalId Parameter for the deleteJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Mono<Optional<Journal>> deleteJournalWithBindValues(String queryResponseDef, Long journalId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'deleteJournal': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getDeleteJournalResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteJournalWithBindValues(objectResponse, journalId, parameters);
	}

	/**
	 * Deletes an existing journal.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Journal> mono = executor.deleteJournal(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			journalId, // A value for deleteJournal's journalId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Journal field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param journalId Parameter for the deleteJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Mono<Optional<Journal>> deleteJournal(String queryResponseDef, Long journalId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'deleteJournal': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getDeleteJournalResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteJournalWithBindValues(objectResponse, journalId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Deletes an existing journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Journal> mono = executor.deleteJournalWithBindValues(preparedRequest, journalId, // A value for
	 * 																								// deleteJournal's
	 * 																								// journalId
	 * 																								// input
	 * 																								// parameter
	 * 			params);
	 * 		Journal field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteJournalGraphQLRequest(String)} method.
	 * @param journalId Parameter for the deleteJournal field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)

	public Mono<Optional<Journal>> deleteJournalWithBindValues(ObjectResponse objectResponse, Long journalId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'deleteJournal' with parameters: {} ", journalId); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'deleteJournal'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationDeleteJournalJournalId", journalId); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getDeleteJournal() == null) ? Optional.empty() : Optional.of(t.getDeleteJournal()));
	}

	/**
	 * Deletes an existing journal.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteJournalGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Journal> mono = executor.deleteJournal(preparedRequest, journalId, // A value for deleteJournal's
	 * 																				// journalId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Journal field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteJournalGraphQLRequest(String)} method.
	 * @param journalId Parameter for the deleteJournal field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteJournal", graphQLTypeSimpleName = "Journal", javaClass = Journal.class)
	public Mono<Optional<Journal>> deleteJournal(ObjectResponse objectResponse, Long journalId,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'deleteJournal' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'deleteJournal' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationDeleteJournalJournalId", journalId); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getDeleteJournal() == null) ? Optional.empty() : Optional.of(t.getDeleteJournal()));
	}

	/**
	 * Deletes an existing journal.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Journal, as expected by the
	 * deleteJournal query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getDeleteJournalResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"deleteJournal", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "journalId", "mutationDeleteJournalJournalId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing journal.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the deleteJournal REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeleteJournalGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteJournal" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "journalId", "mutationDeleteJournalJournalId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new person. This method executes a partial query against the GraphQL server. That is, the query that is
	 * one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the query that
	 * <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Person> mono = executor.createPersonWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			person, // A value for createPerson's person input parameter
	 * 			params);
	 * 		Person field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param person Parameter for the createPerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Mono<Optional<Person>> createPersonWithBindValues(String queryResponseDef, PersonInput person,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'createPerson': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getCreatePersonResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createPersonWithBindValues(objectResponse, person, parameters);
	}

	/**
	 * Creates a new person.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Person> mono = executor.createPerson(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			person, // A value for createPerson's person input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Person field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param person Parameter for the createPerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Mono<Optional<Person>> createPerson(String queryResponseDef, PersonInput person, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'createPerson': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getCreatePersonResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createPersonWithBindValues(objectResponse, person,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Creates a new person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Person> mono = executor.createPersonWithBindValues(preparedRequest, person, // A value for
	 * 																							// createPerson's
	 * 																							// person input
	 * 																							// parameter
	 * 			params);
	 * 		Person field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePersonGraphQLRequest(String)} method.
	 * @param person Parameter for the createPerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)

	public Mono<Optional<Person>> createPersonWithBindValues(ObjectResponse objectResponse, PersonInput person,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'createPerson' with parameters: {} ", person); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'createPerson'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationCreatePersonPerson", person); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getCreatePerson() == null) ? Optional.empty() : Optional.of(t.getCreatePerson()));
	}

	/**
	 * Creates a new person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Person> mono = executor.createPerson(preparedRequest, person, // A value for createPerson's person
	 * 																			// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Person field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePersonGraphQLRequest(String)} method.
	 * @param person Parameter for the createPerson field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Mono<Optional<Person>> createPerson(ObjectResponse objectResponse, PersonInput person,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'createPerson' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'createPerson' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationCreatePersonPerson", person); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getCreatePerson() == null) ? Optional.empty() : Optional.of(t.getCreatePerson()));
	}

	/**
	 * Creates a new person.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Person, as expected by the createPerson
	 * query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getCreatePersonResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"createPerson", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "person", "mutationCreatePersonPerson", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PersonInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new person.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the createPerson REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getCreatePersonGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createPerson" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "person", "mutationCreatePersonPerson", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PersonInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing person. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Person> mono = executor.updatePersonWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			person, // A value for updatePerson's person input parameter
	 * 			params);
	 * 		Person field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param person Parameter for the updatePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Mono<Optional<Person>> updatePersonWithBindValues(String queryResponseDef, PersonInput person,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'updatePerson': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getUpdatePersonResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updatePersonWithBindValues(objectResponse, person, parameters);
	}

	/**
	 * Updates an existing person.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Person> mono = executor.updatePerson(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			person, // A value for updatePerson's person input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Person field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param person Parameter for the updatePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Mono<Optional<Person>> updatePerson(String queryResponseDef, PersonInput person, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'updatePerson': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getUpdatePersonResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updatePersonWithBindValues(objectResponse, person,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Person> mono = executor.updatePersonWithBindValues(preparedRequest, person, // A value for
	 * 																							// updatePerson's
	 * 																							// person input
	 * 																							// parameter
	 * 			params);
	 * 		Person field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePersonGraphQLRequest(String)} method.
	 * @param person Parameter for the updatePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)

	public Mono<Optional<Person>> updatePersonWithBindValues(ObjectResponse objectResponse, PersonInput person,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'updatePerson' with parameters: {} ", person); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'updatePerson'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdatePersonPerson", person); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getUpdatePerson() == null) ? Optional.empty() : Optional.of(t.getUpdatePerson()));
	}

	/**
	 * Updates an existing person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Person> mono = executor.updatePerson(preparedRequest, person, // A value for updatePerson's person
	 * 																			// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Person field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePersonGraphQLRequest(String)} method.
	 * @param person Parameter for the updatePerson field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Mono<Optional<Person>> updatePerson(ObjectResponse objectResponse, PersonInput person,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updatePerson' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'updatePerson' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdatePersonPerson", person); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getUpdatePerson() == null) ? Optional.empty() : Optional.of(t.getUpdatePerson()));
	}

	/**
	 * Updates an existing person.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Person, as expected by the updatePerson
	 * query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getUpdatePersonResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"updatePerson", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "person", "mutationUpdatePersonPerson", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PersonInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing person.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updatePerson REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdatePersonGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updatePerson" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "person", "mutationUpdatePersonPerson", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"PersonInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing person. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Journal> mono = executor.deletePersonWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			personId, // A value for deletePerson's personId input parameter
	 * 			params);
	 * 		Journal field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param personId Parameter for the deletePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Mono<Optional<Person>> deletePersonWithBindValues(String queryResponseDef, Long personId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'deletePerson': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getDeletePersonResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deletePersonWithBindValues(objectResponse, personId, parameters);
	}

	/**
	 * Deletes an existing person.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Person> mono = executor.deletePerson(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			personId, // A value for deletePerson's personId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Person field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param personId Parameter for the deletePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Mono<Optional<Person>> deletePerson(String queryResponseDef, Long personId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'deletePerson': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getDeletePersonResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deletePersonWithBindValues(objectResponse, personId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Deletes an existing person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Person> mono = executor.deletePersonWithBindValues(preparedRequest, personId, // A value for
	 * 																							// deletePerson's
	 * 																							// personId input
	 * 																							// parameter
	 * 			params);
	 * 		Person field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePersonGraphQLRequest(String)} method.
	 * @param personId Parameter for the deletePerson field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Mono<Optional<Person>> deletePersonWithBindValues(ObjectResponse objectResponse, Long personId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'deletePerson' with parameters: {} ", personId); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'deletePerson'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationDeletePersonPersonId", personId); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getDeletePerson() == null) ? Optional.empty() : Optional.of(t.getDeletePerson()));
	}

	/**
	 * Deletes an existing person.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePersonGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Person> mono = executor.deletePerson(preparedRequest, personId, // A value for deletePerson's
	 * 																				// personId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Person field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePersonGraphQLRequest(String)} method.
	 * @param personId Parameter for the deletePerson field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePerson", graphQLTypeSimpleName = "Person", javaClass = Person.class)
	public Mono<Optional<Person>> deletePerson(ObjectResponse objectResponse, Long personId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'deletePerson' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'deletePerson' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationDeletePersonPersonId", personId); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getDeletePerson() == null) ? Optional.empty() : Optional.of(t.getDeletePerson()));
	}

	/**
	 * Deletes an existing person.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Person, as expected by the deletePerson
	 * query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getDeletePersonResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"deletePerson", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "personId", "mutationDeletePersonPersonId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing person.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the deletePerson REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeletePersonGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deletePerson" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "personId", "mutationDeletePersonPersonId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new publication. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Publication> mono = executor.createPublicationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publication, // A value for createPublication's publication input parameter
	 * 			params);
	 * 		Publication field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publication Parameter for the createPublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Mono<Optional<Publication>> createPublicationWithBindValues(String queryResponseDef,
		PublicationInput publication, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'createPublication': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getCreatePublicationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createPublicationWithBindValues(objectResponse, publication, parameters);
	}

	/**
	 * Creates a new publication.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.createPublication(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publication, // A value for createPublication's publication input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publication field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param publication Parameter for the createPublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Mono<Optional<Publication>> createPublication(String queryResponseDef, PublicationInput publication,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'createPublication': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getCreatePublicationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createPublicationWithBindValues(objectResponse, publication,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Creates a new publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.createPublicationWithBindValues(preparedRequest, publication, // A
	 * 																										// value
	 * 																										// for
	 * 																										// createPublication's
	 * 																										// publication
	 * 																										// input
	 * 																										// parameter
	 * 			params);
	 * 		Publication field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePublicationGraphQLRequest(String)} method.
	 * @param publication Parameter for the createPublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)

	public Mono<Optional<Publication>> createPublicationWithBindValues(ObjectResponse objectResponse,
		PublicationInput publication, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'createPublication' with parameters: {} ", publication); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'createPublication'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationCreatePublicationPublication", publication); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getCreatePublication() == null) ? Optional.empty() : Optional.of(t.getCreatePublication()));
	}

	/**
	 * Creates a new publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.createPublication(preparedRequest, publication, // A value for
	 * 																							// createPublication's
	 * 																							// publication input
	 * 																							// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publication field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePublicationGraphQLRequest(String)} method.
	 * @param publication Parameter for the createPublication field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Mono<Optional<Publication>> createPublication(ObjectResponse objectResponse, PublicationInput publication,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'createPublication' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'createPublication' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationCreatePublicationPublication", publication); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getCreatePublication() == null) ? Optional.empty() : Optional.of(t.getCreatePublication()));
	}

	/**
	 * Creates a new publication.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Publication, as expected by the
	 * createPublication query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getCreatePublicationResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"createPublication", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "publication", "mutationCreatePublicationPublication", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "PublicationInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new publication.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the createPublication REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getCreatePublicationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createPublication" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "publication", "mutationCreatePublicationPublication", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "PublicationInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing publication. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Publication> mono = executor.updatePublicationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publication, // A value for updatePublication's publication input parameter
	 * 			params);
	 * 		Publication field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publication Parameter for the updatePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Mono<Optional<Publication>> updatePublicationWithBindValues(String queryResponseDef,
		PublicationInput publication, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'updatePublication': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getUpdatePublicationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updatePublicationWithBindValues(objectResponse, publication, parameters);
	}

	/**
	 * Updates an existing publication.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.updatePublication(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publication, // A value for updatePublication's publication input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publication field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param publication Parameter for the updatePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Mono<Optional<Publication>> updatePublication(String queryResponseDef, PublicationInput publication,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'updatePublication': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getUpdatePublicationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updatePublicationWithBindValues(objectResponse, publication,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.updatePublicationWithBindValues(preparedRequest, publication, // A
	 * 																										// value
	 * 																										// for
	 * 																										// updatePublication's
	 * 																										// publication
	 * 																										// input
	 * 																										// parameter
	 * 			params);
	 * 		Publication field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePublicationGraphQLRequest(String)} method.
	 * @param publication Parameter for the updatePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)

	public Mono<Optional<Publication>> updatePublicationWithBindValues(ObjectResponse objectResponse,
		PublicationInput publication, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'updatePublication' with parameters: {} ", publication); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'updatePublication'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdatePublicationPublication", publication); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getUpdatePublication() == null) ? Optional.empty() : Optional.of(t.getUpdatePublication()));
	}

	/**
	 * Updates an existing publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.updatePublication(preparedRequest, publication, // A value for
	 * 																							// updatePublication's
	 * 																							// publication input
	 * 																							// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publication field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePublicationGraphQLRequest(String)} method.
	 * @param publication Parameter for the updatePublication field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Mono<Optional<Publication>> updatePublication(ObjectResponse objectResponse, PublicationInput publication,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updatePublication' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'updatePublication' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdatePublicationPublication", publication); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getUpdatePublication() == null) ? Optional.empty() : Optional.of(t.getUpdatePublication()));
	}

	/**
	 * Updates an existing publication.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Publication, as expected by the
	 * updatePublication query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getUpdatePublicationResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"updatePublication", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "publication", "mutationUpdatePublicationPublication", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "PublicationInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing publication.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updatePublication REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdatePublicationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updatePublication" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "publication", "mutationUpdatePublicationPublication", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "PublicationInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing publication. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Publication> mono = executor.deletePublicationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publicationId, // A value for deletePublication's publicationId input parameter
	 * 			params);
	 * 		Publication field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publicationId Parameter for the deletePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Mono<Optional<Publication>> deletePublicationWithBindValues(String queryResponseDef, Long publicationId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'deletePublication': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getDeletePublicationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deletePublicationWithBindValues(objectResponse, publicationId, parameters);
	}

	/**
	 * Deletes an existing publication.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.deletePublication(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publicationId, // A value for deletePublication's publicationId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publication field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param publicationId Parameter for the deletePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Mono<Optional<Publication>> deletePublication(String queryResponseDef, Long publicationId,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'deletePublication': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getDeletePublicationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deletePublicationWithBindValues(objectResponse, publicationId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Deletes an existing publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.deletePublicationWithBindValues(preparedRequest, publicationId, // A
	 * 																											// value
	 * 																											// for
	 * 																											// deletePublication's
	 * 																											// publicationId
	 * 																											// input
	 * 																											// parameter
	 * 			params);
	 * 		Publication field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePublicationGraphQLRequest(String)} method.
	 * @param publicationId Parameter for the deletePublication field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Mono<Optional<Publication>> deletePublicationWithBindValues(ObjectResponse objectResponse,
		Long publicationId, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'deletePublication' with parameters: {} ", publicationId); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'deletePublication'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationDeletePublicationPublicationId", publicationId); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getDeletePublication() == null) ? Optional.empty() : Optional.of(t.getDeletePublication()));
	}

	/**
	 * Deletes an existing publication.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePublicationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.deletePublication(preparedRequest, publicationId, // A value for
	 * 																							// deletePublication's
	 * 																							// publicationId
	 * 																							// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publication field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePublicationGraphQLRequest(String)} method.
	 * @param publicationId Parameter for the deletePublication field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublication", graphQLTypeSimpleName = "Publication",
		javaClass = Publication.class)
	public Mono<Optional<Publication>> deletePublication(ObjectResponse objectResponse, Long publicationId,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'deletePublication' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'deletePublication' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationDeletePublicationPublicationId", publicationId); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getDeletePublication() == null) ? Optional.empty() : Optional.of(t.getDeletePublication()));
	}

	/**
	 * Deletes an existing publication.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Publication, as expected by the
	 * deletePublication query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getDeletePublicationResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"deletePublication", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "publicationId", "mutationDeletePublicationPublicationId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing publication.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the deletePublication REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeletePublicationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deletePublication" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "publicationId", "mutationDeletePublicationPublicationId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new publisher. This method executes a partial query against the GraphQL server. That is, the query that
	 * is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the query
	 * that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Publisher> mono = executor.createPublisherWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisher, // A value for createPublisher's publisher input parameter
	 * 			params);
	 * 		Publisher field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publisher Parameter for the createPublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Mono<Optional<Publisher>> createPublisherWithBindValues(String queryResponseDef, PublisherInput publisher,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'createPublisher': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getCreatePublisherResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createPublisherWithBindValues(objectResponse, publisher, parameters);
	}

	/**
	 * Creates a new publisher.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publisher> mono = executor.createPublisher(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisher, // A value for createPublisher's publisher input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publisher field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param publisher Parameter for the createPublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Mono<Optional<Publisher>> createPublisher(String queryResponseDef, PublisherInput publisher,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'createPublisher': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getCreatePublisherResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createPublisherWithBindValues(objectResponse, publisher,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Creates a new publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publisher> mono = executor.createPublisherWithBindValues(preparedRequest, publisher, // A value for
	 * 																									// createPublisher's
	 * 																									// publisher
	 * 																									// input
	 * 																									// parameter
	 * 			params);
	 * 		Publisher field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePublisherGraphQLRequest(String)} method.
	 * @param publisher Parameter for the createPublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)

	public Mono<Optional<Publisher>> createPublisherWithBindValues(ObjectResponse objectResponse,
		PublisherInput publisher, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'createPublisher' with parameters: {} ", publisher); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'createPublisher'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationCreatePublisherPublisher", publisher); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getCreatePublisher() == null) ? Optional.empty() : Optional.of(t.getCreatePublisher()));
	}

	/**
	 * Creates a new publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreatePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publisher> mono = executor.createPublisher(preparedRequest, publisher, // A value for
	 * 																					// createPublisher's
	 * 																					// publisher input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publisher field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreatePublisherGraphQLRequest(String)} method.
	 * @param publisher Parameter for the createPublisher field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createPublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Mono<Optional<Publisher>> createPublisher(ObjectResponse objectResponse, PublisherInput publisher,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'createPublisher' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'createPublisher' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationCreatePublisherPublisher", publisher); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getCreatePublisher() == null) ? Optional.empty() : Optional.of(t.getCreatePublisher()));
	}

	/**
	 * Creates a new publisher.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Publisher, as expected by the
	 * createPublisher query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getCreatePublisherResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"createPublisher", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "publisher", "mutationCreatePublisherPublisher", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "PublisherInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new publisher.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the createPublisher REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getCreatePublisherGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createPublisher" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "publisher", "mutationCreatePublisherPublisher", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "PublisherInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing publisher. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Publisher> mono = executor.updatePublisherWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisher, // A value for updatePublisher's publisher input parameter
	 * 			params);
	 * 		Publisher field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publisher Parameter for the updatePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Mono<Optional<Publisher>> updatePublisherWithBindValues(String queryResponseDef, PublisherInput publisher,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'updatePublisher': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getUpdatePublisherResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updatePublisherWithBindValues(objectResponse, publisher, parameters);
	}

	/**
	 * Updates an existing publisher.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publisher> mono = executor.updatePublisher(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisher, // A value for updatePublisher's publisher input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publisher field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param publisher Parameter for the updatePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Mono<Optional<Publisher>> updatePublisher(String queryResponseDef, PublisherInput publisher,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'updatePublisher': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getUpdatePublisherResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updatePublisherWithBindValues(objectResponse, publisher,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publisher> mono = executor.updatePublisherWithBindValues(preparedRequest, publisher, // A value for
	 * 																									// updatePublisher's
	 * 																									// publisher
	 * 																									// input
	 * 																									// parameter
	 * 			params);
	 * 		Publisher field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePublisherGraphQLRequest(String)} method.
	 * @param publisher Parameter for the updatePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)

	public Mono<Optional<Publisher>> updatePublisherWithBindValues(ObjectResponse objectResponse,
		PublisherInput publisher, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'updatePublisher' with parameters: {} ", publisher); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'updatePublisher'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdatePublisherPublisher", publisher); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getUpdatePublisher() == null) ? Optional.empty() : Optional.of(t.getUpdatePublisher()));
	}

	/**
	 * Updates an existing publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdatePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publisher> mono = executor.updatePublisher(preparedRequest, publisher, // A value for
	 * 																					// updatePublisher's
	 * 																					// publisher input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publisher field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdatePublisherGraphQLRequest(String)} method.
	 * @param publisher Parameter for the updatePublisher field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updatePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Mono<Optional<Publisher>> updatePublisher(ObjectResponse objectResponse, PublisherInput publisher,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updatePublisher' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'updatePublisher' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdatePublisherPublisher", publisher); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getUpdatePublisher() == null) ? Optional.empty() : Optional.of(t.getUpdatePublisher()));
	}

	/**
	 * Updates an existing publisher.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Publisher, as expected by the
	 * updatePublisher query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getUpdatePublisherResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"updatePublisher", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "publisher", "mutationUpdatePublisherPublisher", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "PublisherInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing publisher.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updatePublisher REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdatePublisherGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updatePublisher" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "publisher", "mutationUpdatePublisherPublisher", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "PublisherInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing publisher. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Publication> mono = executor.deletePublisherWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisherId, // A value for deletePublisher's publisherId input parameter
	 * 			params);
	 * 		Publication field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param publisherId Parameter for the deletePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Mono<Optional<Publisher>> deletePublisherWithBindValues(String queryResponseDef, Long publisherId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'deletePublisher': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getDeletePublisherResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deletePublisherWithBindValues(objectResponse, publisherId, parameters);
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publication> mono = executor.deletePublisher(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			publisherId, // A value for deletePublisher's publisherId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publication field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param publisherId Parameter for the deletePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Mono<Optional<Publisher>> deletePublisher(String queryResponseDef, Long publisherId,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'deletePublisher': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getDeletePublisherResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deletePublisherWithBindValues(objectResponse, publisherId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publisher> mono = executor.deletePublisherWithBindValues(preparedRequest, publisherId, // A value
	 * 																									// for
	 * 																									// deletePublisher's
	 * 																									// publisherId
	 * 																									// input
	 * 																									// parameter
	 * 			params);
	 * 		Publisher field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePublisherGraphQLRequest(String)} method.
	 * @param publisherId Parameter for the deletePublisher field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)

	public Mono<Optional<Publisher>> deletePublisherWithBindValues(ObjectResponse objectResponse, Long publisherId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'deletePublisher' with parameters: {} ", publisherId); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'deletePublisher'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationDeletePublisherPublisherId", publisherId); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getDeletePublisher() == null) ? Optional.empty() : Optional.of(t.getDeletePublisher()));
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeletePublisherGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Publisher> mono = executor.deletePublisher(preparedRequest, publisherId, // A value for
	 * 																						// deletePublisher's
	 * 																						// publisherId input
	 * 																						// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Publisher field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeletePublisherGraphQLRequest(String)} method.
	 * @param publisherId Parameter for the deletePublisher field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deletePublisher", graphQLTypeSimpleName = "Publisher", javaClass = Publisher.class)
	public Mono<Optional<Publisher>> deletePublisher(ObjectResponse objectResponse, Long publisherId,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'deletePublisher' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'deletePublisher' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationDeletePublisherPublisherId", publisherId); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getDeletePublisher() == null) ? Optional.empty() : Optional.of(t.getDeletePublisher()));
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Publisher, as expected by the
	 * deletePublisher query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getDeletePublisherResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"deletePublisher", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "publisherId", "mutationDeletePublisherPublisherId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing publisher.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the deletePublisher REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeletePublisherGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deletePublisher" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "publisherId", "mutationDeletePublisherPublisherId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new quotation. This method executes a partial query against the GraphQL server. That is, the query that
	 * is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the query
	 * that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Quotation> mono = executor.createQuotationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotation, // A value for createQuotation's quotation input parameter
	 * 			params);
	 * 		Quotation field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param quotation Parameter for the createQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Mono<Optional<Quotation>> createQuotationWithBindValues(String queryResponseDef, QuotationInput quotation,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'createQuotation': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getCreateQuotationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createQuotationWithBindValues(objectResponse, quotation, parameters);
	}

	/**
	 * Creates a new quotation.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Quotation> mono = executor.createQuotation(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotation, // A value for createQuotation's quotation input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Quotation field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param quotation Parameter for the createQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Mono<Optional<Quotation>> createQuotation(String queryResponseDef, QuotationInput quotation,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'createQuotation': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getCreateQuotationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createQuotationWithBindValues(objectResponse, quotation,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Creates a new quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Quotation> mono = executor.createQuotationWithBindValues(preparedRequest, quotation, // A value for
	 * 																									// createQuotation's
	 * 																									// quotation
	 * 																									// input
	 * 																									// parameter
	 * 			params);
	 * 		Quotation field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateQuotationGraphQLRequest(String)} method.
	 * @param quotation Parameter for the createQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)

	public Mono<Optional<Quotation>> createQuotationWithBindValues(ObjectResponse objectResponse,
		QuotationInput quotation, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'createQuotation' with parameters: {} ", quotation); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'createQuotation'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationCreateQuotationQuotation", quotation); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getCreateQuotation() == null) ? Optional.empty() : Optional.of(t.getCreateQuotation()));
	}

	/**
	 * Creates a new quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Quotation> mono = executor.createQuotation(preparedRequest, quotation, // A value for
	 * 																					// createQuotation's
	 * 																					// quotation input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Quotation field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateQuotationGraphQLRequest(String)} method.
	 * @param quotation Parameter for the createQuotation field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Mono<Optional<Quotation>> createQuotation(ObjectResponse objectResponse, QuotationInput quotation,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'createQuotation' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'createQuotation' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationCreateQuotationQuotation", quotation); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getCreateQuotation() == null) ? Optional.empty() : Optional.of(t.getCreateQuotation()));
	}

	/**
	 * Creates a new quotation.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Quotation, as expected by the
	 * createQuotation query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getCreateQuotationResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"createQuotation", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "quotation", "mutationCreateQuotationQuotation", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "QuotationInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new quotation.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the createQuotation REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getCreateQuotationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createQuotation" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "quotation", "mutationCreateQuotationQuotation", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "QuotationInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing quotation. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Quotation> mono = executor.updateQuotationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotation, // A value for updateQuotation's quotation input parameter
	 * 			params);
	 * 		Quotation field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param quotation Parameter for the updateQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Mono<Optional<Quotation>> updateQuotationWithBindValues(String queryResponseDef, QuotationInput quotation,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'updateQuotation': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getUpdateQuotationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateQuotationWithBindValues(objectResponse, quotation, parameters);
	}

	/**
	 * Updates an existing quotation.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Quotation> mono = executor.updateQuotation(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotation, // A value for updateQuotation's quotation input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Quotation field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param quotation Parameter for the updateQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Mono<Optional<Quotation>> updateQuotation(String queryResponseDef, QuotationInput quotation,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'updateQuotation': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getUpdateQuotationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateQuotationWithBindValues(objectResponse, quotation,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Quotation> mono = executor.updateQuotationWithBindValues(preparedRequest, quotation, // A value for
	 * 																									// updateQuotation's
	 * 																									// quotation
	 * 																									// input
	 * 																									// parameter
	 * 			params);
	 * 		Quotation field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateQuotationGraphQLRequest(String)} method.
	 * @param quotation Parameter for the updateQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)

	public Mono<Optional<Quotation>> updateQuotationWithBindValues(ObjectResponse objectResponse,
		QuotationInput quotation, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'updateQuotation' with parameters: {} ", quotation); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'updateQuotation'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdateQuotationQuotation", quotation); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getUpdateQuotation() == null) ? Optional.empty() : Optional.of(t.getUpdateQuotation()));
	}

	/**
	 * Updates an existing quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Quotation> mono = executor.updateQuotation(preparedRequest, quotation, // A value for
	 * 																					// updateQuotation's
	 * 																					// quotation input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Quotation field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateQuotationGraphQLRequest(String)} method.
	 * @param quotation Parameter for the updateQuotation field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Mono<Optional<Quotation>> updateQuotation(ObjectResponse objectResponse, QuotationInput quotation,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updateQuotation' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'updateQuotation' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdateQuotationQuotation", quotation); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getUpdateQuotation() == null) ? Optional.empty() : Optional.of(t.getUpdateQuotation()));
	}

	/**
	 * Updates an existing quotation.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Quotation, as expected by the
	 * updateQuotation query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getUpdateQuotationResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"updateQuotation", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "quotation", "mutationUpdateQuotationQuotation", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "QuotationInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing quotation.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updateQuotation REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdateQuotationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateQuotation" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "quotation", "mutationUpdateQuotationQuotation", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "QuotationInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing quotation. This method executes a partial query against the GraphQL server. That is, the
	 * query that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of
	 * the query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Quotation> mono = executor.deleteQuotationWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotationId, // A value for deleteQuotation's quotationId input parameter
	 * 			params);
	 * 		Quotation field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param quotationId Parameter for the deleteQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Mono<Optional<Quotation>> deleteQuotationWithBindValues(String queryResponseDef, Long quotationId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'deleteQuotation': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getDeleteQuotationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteQuotationWithBindValues(objectResponse, quotationId, parameters);
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Quotation> mono = executor.deleteQuotation(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			quotationId, // A value for deleteQuotation's quotationId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Quotation field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param quotationId Parameter for the deleteQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Mono<Optional<Quotation>> deleteQuotation(String queryResponseDef, Long quotationId,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'deleteQuotation': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getDeleteQuotationResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteQuotationWithBindValues(objectResponse, quotationId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Quotation> mono = executor.deleteQuotationWithBindValues(preparedRequest, quotationId, // A value
	 * 																									// for
	 * 																									// deleteQuotation's
	 * 																									// quotationId
	 * 																									// input
	 * 																									// parameter
	 * 			params);
	 * 		Quotation field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteQuotationGraphQLRequest(String)} method.
	 * @param quotationId Parameter for the deleteQuotation field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Mono<Optional<Quotation>> deleteQuotationWithBindValues(ObjectResponse objectResponse, Long quotationId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'deleteQuotation' with parameters: {} ", quotationId); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'deleteQuotation'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationDeleteQuotationQuotationId", quotationId); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getDeleteQuotation() == null) ? Optional.empty() : Optional.of(t.getDeleteQuotation()));
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteQuotationGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Quotation> mono = executor.deleteQuotation(preparedRequest, quotationId, // A value for
	 * 																						// deleteQuotation's
	 * 																						// quotationId input
	 * 																						// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Quotation field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteQuotationGraphQLRequest(String)} method.
	 * @param quotationId Parameter for the deleteQuotation field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteQuotation", graphQLTypeSimpleName = "Quotation", javaClass = Quotation.class)
	public Mono<Optional<Quotation>> deleteQuotation(ObjectResponse objectResponse, Long quotationId,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'deleteQuotation' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'deleteQuotation' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationDeleteQuotationQuotationId", quotationId); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getDeleteQuotation() == null) ? Optional.empty() : Optional.of(t.getDeleteQuotation()));
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Quotation, as expected by the
	 * deleteQuotation query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getDeleteQuotationResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"deleteQuotation", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "quotationId", "mutationDeleteQuotationQuotationId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing quotation.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the deleteQuotation REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeleteQuotationGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteQuotation" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "quotationId", "mutationDeleteQuotationQuotationId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new topic. This method executes a partial query against the GraphQL server. That is, the query that is
	 * one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the query that
	 * <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Topic> mono = executor.createTopicWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topic, // A value for createTopic's topic input parameter
	 * 			params);
	 * 		Topic field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topic Parameter for the createTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Mono<Optional<Topic>> createTopicWithBindValues(String queryResponseDef, TopicInput topic,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'createTopic': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getCreateTopicResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createTopicWithBindValues(objectResponse, topic, parameters);
	}

	/**
	 * Creates a new topic.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Topic> mono = executor.createTopic(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topic, // A value for createTopic's topic input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Topic field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param topic Parameter for the createTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Mono<Optional<Topic>> createTopic(String queryResponseDef, TopicInput topic, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'createTopic': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getCreateTopicResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createTopicWithBindValues(objectResponse, topic,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Creates a new topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Topic> mono = executor.createTopicWithBindValues(preparedRequest, topic, // A value for
	 * 																						// createTopic's topic
	 * 																						// input parameter
	 * 			params);
	 * 		Topic field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateTopicGraphQLRequest(String)} method.
	 * @param topic Parameter for the createTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)

	public Mono<Optional<Topic>> createTopicWithBindValues(ObjectResponse objectResponse, TopicInput topic,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'createTopic' with parameters: {} ", topic); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'createTopic'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationCreateTopicTopic", topic); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getCreateTopic() == null) ? Optional.empty() : Optional.of(t.getCreateTopic()));
	}

	/**
	 * Creates a new topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Topic> mono = executor.createTopic(preparedRequest, topic, // A value for createTopic's topic input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Topic field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateTopicGraphQLRequest(String)} method.
	 * @param topic Parameter for the createTopic field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Mono<Optional<Topic>> createTopic(ObjectResponse objectResponse, TopicInput topic, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'createTopic' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'createTopic' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationCreateTopicTopic", topic); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getCreateTopic() == null) ? Optional.empty() : Optional.of(t.getCreateTopic()));
	}

	/**
	 * Creates a new topic.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Topic, as expected by the createTopic
	 * query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getCreateTopicResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"createTopic", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "topic", "mutationCreateTopicTopic", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TopicInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new topic.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the createTopic REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getCreateTopicGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createTopic" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "topic", "mutationCreateTopicTopic", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TopicInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing topic. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Topic> mono = executor.updateTopicWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topic, // A value for updateTopic's topic input parameter
	 * 			params);
	 * 		Topic field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topic Parameter for the updateTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Mono<Optional<Topic>> updateTopicWithBindValues(String queryResponseDef, TopicInput topic,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'updateTopic': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getUpdateTopicResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateTopicWithBindValues(objectResponse, topic, parameters);
	}

	/**
	 * Updates an existing topic.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Topic> mono = executor.updateTopic(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topic, // A value for updateTopic's topic input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Topic field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param topic Parameter for the updateTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Mono<Optional<Topic>> updateTopic(String queryResponseDef, TopicInput topic, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'updateTopic': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getUpdateTopicResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateTopicWithBindValues(objectResponse, topic,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Topic> mono = executor.updateTopicWithBindValues(preparedRequest, topic, // A value for
	 * 																						// updateTopic's topic
	 * 																						// input parameter
	 * 			params);
	 * 		Topic field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateTopicGraphQLRequest(String)} method.
	 * @param topic Parameter for the updateTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)

	public Mono<Optional<Topic>> updateTopicWithBindValues(ObjectResponse objectResponse, TopicInput topic,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'updateTopic' with parameters: {} ", topic); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'updateTopic'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdateTopicTopic", topic); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getUpdateTopic() == null) ? Optional.empty() : Optional.of(t.getUpdateTopic()));
	}

	/**
	 * Updates an existing topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Topic> mono = executor.updateTopic(preparedRequest, topic, // A value for updateTopic's topic input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Topic field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateTopicGraphQLRequest(String)} method.
	 * @param topic Parameter for the updateTopic field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Mono<Optional<Topic>> updateTopic(ObjectResponse objectResponse, TopicInput topic, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updateTopic' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'updateTopic' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdateTopicTopic", topic); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getUpdateTopic() == null) ? Optional.empty() : Optional.of(t.getUpdateTopic()));
	}

	/**
	 * Updates an existing topic.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Topic, as expected by the updateTopic
	 * query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getUpdateTopicResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"updateTopic", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "topic", "mutationUpdateTopicTopic", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TopicInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing topic.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updateTopic REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdateTopicGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateTopic" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "topic", "mutationUpdateTopicTopic", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"TopicInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing topic. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Topic> mono = executor.deleteTopicWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topicId, // A value for deleteTopic's topicId input parameter
	 * 			params);
	 * 		Topic field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topicId Parameter for the deleteTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Mono<Optional<Topic>> deleteTopicWithBindValues(String queryResponseDef, Long topicId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'deleteTopic': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getDeleteTopicResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteTopicWithBindValues(objectResponse, topicId, parameters);
	}

	/**
	 * Deletes an existing topic.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Topic> mono = executor.deleteTopic(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topicId, // A value for deleteTopic's topicId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Topic field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param topicId Parameter for the deleteTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Mono<Optional<Topic>> deleteTopic(String queryResponseDef, Long topicId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'deleteTopic': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getDeleteTopicResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteTopicWithBindValues(objectResponse, topicId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Deletes an existing topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Topic> mono = executor.deleteTopicWithBindValues(preparedRequest, topicId, // A value for
	 * 																						// deleteTopic's topicId
	 * 																						// input parameter
	 * 			params);
	 * 		Topic field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteTopicGraphQLRequest(String)} method.
	 * @param topicId Parameter for the deleteTopic field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Mono<Optional<Topic>> deleteTopicWithBindValues(ObjectResponse objectResponse, Long topicId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'deleteTopic' with parameters: {} ", topicId); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'deleteTopic'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationDeleteTopicTopicId", topicId); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getDeleteTopic() == null) ? Optional.empty() : Optional.of(t.getDeleteTopic()));
	}

	/**
	 * Deletes an existing topic.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteTopicGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Topic> mono = executor.deleteTopic(preparedRequest, topicId, // A value for deleteTopic's topicId
	 * 																			// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Topic field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteTopicGraphQLRequest(String)} method.
	 * @param topicId Parameter for the deleteTopic field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteTopic", graphQLTypeSimpleName = "Topic", javaClass = Topic.class)
	public Mono<Optional<Topic>> deleteTopic(ObjectResponse objectResponse, Long topicId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'deleteTopic' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'deleteTopic' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationDeleteTopicTopicId", topicId); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getDeleteTopic() == null) ? Optional.empty() : Optional.of(t.getDeleteTopic()));
	}

	/**
	 * Deletes an existing topic.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Topic, as expected by the deleteTopic
	 * query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getDeleteTopicResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"deleteTopic", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "topicId", "mutationDeleteTopicTopicId", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Deletes an existing topic.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the deleteTopic REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeleteTopicGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteTopic" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "topicId", "mutationDeleteTopicTopicId", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Adds a new topic reference. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Boolean> mono = executor.addTopicRefWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topicRef, // A value for addTopicRef's topicRef input parameter
	 * 			params);
	 * 		Boolean field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topicRef Parameter for the addTopicRef field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "addTopicRef", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Mono<Optional<Boolean>> addTopicRefWithBindValues(String queryResponseDef, TopicRefInput topicRef,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'addTopicRef': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getAddTopicRefResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return addTopicRefWithBindValues(objectResponse, topicRef, parameters);
	}

	/**
	 * Adds a new topic reference.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Boolean> mono = executor.addTopicRef(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topicRef, // A value for addTopicRef's topicRef input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Boolean field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param topicRef Parameter for the addTopicRef field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "addTopicRef", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Mono<Optional<Boolean>> addTopicRef(String queryResponseDef, TopicRefInput topicRef,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'addTopicRef': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getAddTopicRefResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return addTopicRefWithBindValues(objectResponse, topicRef,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Adds a new topic reference.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getAddTopicRefGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Boolean> mono = executor.addTopicRefWithBindValues(preparedRequest, topicRef, // A value for
	 * 																							// addTopicRef's
	 * 																							// topicRef input
	 * 																							// parameter
	 * 			params);
	 * 		Boolean field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getAddTopicRefGraphQLRequest(String)} method.
	 * @param topicRef Parameter for the addTopicRef field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "addTopicRef", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)

	public Mono<Optional<Boolean>> addTopicRefWithBindValues(ObjectResponse objectResponse, TopicRefInput topicRef,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'addTopicRef' with parameters: {} ", topicRef); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'addTopicRef'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationAddTopicRefTopicRef", topicRef); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getAddTopicRef() == null) ? Optional.empty() : Optional.of(t.getAddTopicRef()));
	}

	/**
	 * Adds a new topic reference.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getAddTopicRefGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Boolean> mono = executor.addTopicRef(preparedRequest, topicRef, // A value for addTopicRef's
	 * 																				// topicRef input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Boolean field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getAddTopicRefGraphQLRequest(String)} method.
	 * @param topicRef Parameter for the addTopicRef field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "addTopicRef", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Mono<Optional<Boolean>> addTopicRef(ObjectResponse objectResponse, TopicRefInput topicRef,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'addTopicRef' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'addTopicRef' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationAddTopicRefTopicRef", topicRef); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getAddTopicRef() == null) ? Optional.empty() : Optional.of(t.getAddTopicRef()));
	}

	/**
	 * Adds a new topic reference.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Boolean, as expected by the addTopicRef
	 * query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getAddTopicRefResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"addTopicRef", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "topicRef", "mutationAddTopicRefTopicRef", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "TopicRefInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Adds a new topic reference.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the addTopicRef REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getAddTopicRefGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "addTopicRef" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "topicRef", "mutationAddTopicRefTopicRef", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "TopicRefInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Removes a topic reference. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Boolean> mono = executor.removeTopicRefWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topicRef, // A value for removeTopicRef's topicRef input parameter
	 * 			params);
	 * 		Boolean field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param topicRef Parameter for the removeTopicRef field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "removeTopicRef", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Mono<Optional<Boolean>> removeTopicRefWithBindValues(String queryResponseDef, TopicRefInput topicRef,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'removeTopicRef': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getRemoveTopicRefResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return removeTopicRefWithBindValues(objectResponse, topicRef, parameters);
	}

	/**
	 * Removes a topic reference.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Boolean> mono = executor.removeTopicRef(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			topicRef, // A value for removeTopicRef's topicRef input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Boolean field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param topicRef Parameter for the removeTopicRef field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "removeTopicRef", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Mono<Optional<Boolean>> removeTopicRef(String queryResponseDef, TopicRefInput topicRef,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'removeTopicRef': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getRemoveTopicRefResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return removeTopicRefWithBindValues(objectResponse, topicRef,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Removes a topic reference.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getRemoveTopicRefGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Boolean> mono = executor.removeTopicRefWithBindValues(preparedRequest, topicRef, // A value for
	 * 																								// removeTopicRef's
	 * 																								// topicRef input
	 * 																								// parameter
	 * 			params);
	 * 		Boolean field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getRemoveTopicRefGraphQLRequest(String)} method.
	 * @param topicRef Parameter for the removeTopicRef field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "removeTopicRef", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)

	public Mono<Optional<Boolean>> removeTopicRefWithBindValues(ObjectResponse objectResponse, TopicRefInput topicRef,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'removeTopicRef' with parameters: {} ", topicRef); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'removeTopicRef'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationRemoveTopicRefTopicRef", topicRef); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getRemoveTopicRef() == null) ? Optional.empty() : Optional.of(t.getRemoveTopicRef()));
	}

	/**
	 * Removes a topic reference.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getRemoveTopicRefGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Boolean> mono = executor.removeTopicRef(preparedRequest, topicRef, // A value for removeTopicRef's
	 * 																				// topicRef input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Boolean field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getRemoveTopicRefGraphQLRequest(String)} method.
	 * @param topicRef Parameter for the removeTopicRef field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "removeTopicRef", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Mono<Optional<Boolean>> removeTopicRef(ObjectResponse objectResponse, TopicRefInput topicRef,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'removeTopicRef' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'removeTopicRef' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationRemoveTopicRefTopicRef", topicRef); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getRemoveTopicRef() == null) ? Optional.empty() : Optional.of(t.getRemoveTopicRef()));
	}

	/**
	 * Removes a topic reference.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Boolean, as expected by the
	 * removeTopicRef query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getRemoveTopicRefResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"removeTopicRef", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "topicRef", "mutationRemoveTopicRefTopicRef", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "TopicRefInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Removes a topic reference.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the removeTopicRef REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getRemoveTopicRefGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "removeTopicRef" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "topicRef", "mutationRemoveTopicRefTopicRef", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "TopicRefInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Links two entities. This method executes a partial query against the GraphQL server. That is, the query that is
	 * one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the query that
	 * <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Boolean> mono = executor.linkEntitiesWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			link, // A value for linkEntities's link input parameter
	 * 			params);
	 * 		Boolean field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param link Parameter for the linkEntities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "linkEntities", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Mono<Optional<Boolean>> linkEntitiesWithBindValues(String queryResponseDef, LinkEntitiesInput link,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'linkEntities': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getLinkEntitiesResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return linkEntitiesWithBindValues(objectResponse, link, parameters);
	}

	/**
	 * Links two entities.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Boolean> mono = executor.linkEntities(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			link, // A value for linkEntities's link input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Boolean field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param link Parameter for the linkEntities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "linkEntities", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Mono<Optional<Boolean>> linkEntities(String queryResponseDef, LinkEntitiesInput link,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'linkEntities': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getLinkEntitiesResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return linkEntitiesWithBindValues(objectResponse, link,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Links two entities.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getLinkEntitiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Boolean> mono = executor.linkEntitiesWithBindValues(preparedRequest, link, // A value for
	 * 																						// linkEntities's link
	 * 																						// input parameter
	 * 			params);
	 * 		Boolean field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getLinkEntitiesGraphQLRequest(String)} method.
	 * @param link Parameter for the linkEntities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "linkEntities", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)

	public Mono<Optional<Boolean>> linkEntitiesWithBindValues(ObjectResponse objectResponse, LinkEntitiesInput link,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'linkEntities' with parameters: {} ", link); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'linkEntities'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationLinkEntitiesLink", link); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getLinkEntities() == null) ? Optional.empty() : Optional.of(t.getLinkEntities()));
	}

	/**
	 * Links two entities.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getLinkEntitiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Boolean> mono = executor.linkEntities(preparedRequest, link, // A value for linkEntities's link
	 * 																			// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Boolean field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getLinkEntitiesGraphQLRequest(String)} method.
	 * @param link Parameter for the linkEntities field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "linkEntities", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Mono<Optional<Boolean>> linkEntities(ObjectResponse objectResponse, LinkEntitiesInput link,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'linkEntities' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'linkEntities' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationLinkEntitiesLink", link); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getLinkEntities() == null) ? Optional.empty() : Optional.of(t.getLinkEntities()));
	}

	/**
	 * Links two entities.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Boolean, as expected by the
	 * linkEntities query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getLinkEntitiesResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"linkEntities", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "link", "mutationLinkEntitiesLink", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"LinkEntitiesInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Links two entities.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the linkEntities REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getLinkEntitiesGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "linkEntities" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "link", "mutationLinkEntitiesLink", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"LinkEntitiesInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Unlinks two linked entities. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Boolean> mono = executor.unlinkEntitiesWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			link, // A value for unlinkEntities's link input parameter
	 * 			params);
	 * 		Boolean field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param link Parameter for the unlinkEntities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "unlinkEntities", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Mono<Optional<Boolean>> unlinkEntitiesWithBindValues(String queryResponseDef, LinkEntitiesInput link,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'unlinkEntities': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getUnlinkEntitiesResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return unlinkEntitiesWithBindValues(objectResponse, link, parameters);
	}

	/**
	 * Unlinks two linked entities.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Boolean> mono = executor.unlinkEntities(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			link, // A value for unlinkEntities's link input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Boolean field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param link Parameter for the unlinkEntities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "unlinkEntities", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Mono<Optional<Boolean>> unlinkEntities(String queryResponseDef, LinkEntitiesInput link,
		Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'unlinkEntities': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getUnlinkEntitiesResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return unlinkEntitiesWithBindValues(objectResponse, link,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Unlinks two linked entities.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUnlinkEntitiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Boolean> mono = executor.unlinkEntitiesWithBindValues(preparedRequest, link, // A value for
	 * 																							// unlinkEntities's
	 * 																							// link input
	 * 																							// parameter
	 * 			params);
	 * 		Boolean field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUnlinkEntitiesGraphQLRequest(String)} method.
	 * @param link Parameter for the unlinkEntities field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "unlinkEntities", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)

	public Mono<Optional<Boolean>> unlinkEntitiesWithBindValues(ObjectResponse objectResponse, LinkEntitiesInput link,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'unlinkEntities' with parameters: {} ", link); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'unlinkEntities'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUnlinkEntitiesLink", link); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getUnlinkEntities() == null) ? Optional.empty() : Optional.of(t.getUnlinkEntities()));
	}

	/**
	 * Unlinks two linked entities.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUnlinkEntitiesGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Boolean> mono = executor.unlinkEntities(preparedRequest, link, // A value for unlinkEntities's link
	 * 																			// input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Boolean field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUnlinkEntitiesGraphQLRequest(String)} method.
	 * @param link Parameter for the unlinkEntities field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "unlinkEntities", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Mono<Optional<Boolean>> unlinkEntities(ObjectResponse objectResponse, LinkEntitiesInput link,
		Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'unlinkEntities' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'unlinkEntities' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUnlinkEntitiesLink", link); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getUnlinkEntities() == null) ? Optional.empty() : Optional.of(t.getUnlinkEntities()));
	}

	/**
	 * Unlinks two linked entities.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Boolean, as expected by the
	 * unlinkEntities query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getUnlinkEntitiesResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"unlinkEntities", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "link", "mutationUnlinkEntitiesLink", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"LinkEntitiesInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Unlinks two linked entities.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the unlinkEntities REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUnlinkEntitiesGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "unlinkEntities" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "link", "mutationUnlinkEntitiesLink", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"LinkEntitiesInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Sets entity status. This method executes a partial query against the GraphQL server. That is, the query that is
	 * one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the query that
	 * <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<Boolean> mono = executor.setEntityStatusWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			entityKind, // A value for setEntityStatus's entityKind input parameter
	 * 			entityId, // A value for setEntityStatus's entityId input parameter
	 * 			status, // A value for setEntityStatus's status input parameter
	 * 			params);
	 * 		Boolean field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param entityKind Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param entityId Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param status Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "setEntityStatus", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Mono<Optional<Boolean>> setEntityStatusWithBindValues(String queryResponseDef, EntityKind entityKind,
		Long entityId, StatusKind status, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'setEntityStatus': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getSetEntityStatusResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return setEntityStatusWithBindValues(objectResponse, entityKind, entityId, status, parameters);
	}

	/**
	 * Sets entity status.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<Boolean> mono = executor.setEntityStatus(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			entityKind, // A value for setEntityStatus's entityKind input parameter
	 * 			entityId, // A value for setEntityStatus's entityId input parameter
	 * 			status, // A value for setEntityStatus's status input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Boolean field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param entityKind Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param entityId Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param status Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "setEntityStatus", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Mono<Optional<Boolean>> setEntityStatus(String queryResponseDef, EntityKind entityKind, Long entityId,
		StatusKind status, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'setEntityStatus': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getSetEntityStatusResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return setEntityStatusWithBindValues(objectResponse, entityKind, entityId, status,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Sets entity status.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getSetEntityStatusGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Boolean> mono = executor.setEntityStatusWithBindValues(preparedRequest, entityKind, // A value for
	 * 																									// setEntityStatus's
	 * 																									// entityKind
	 * 																									// input
	 * 																									// parameter
	 * 			entityId, // A value for setEntityStatus's entityId input parameter
	 * 			status, // A value for setEntityStatus's status input parameter
	 * 			params);
	 * 		Boolean field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getSetEntityStatusGraphQLRequest(String)} method.
	 * @param entityKind Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param entityId Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param status Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "setEntityStatus", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)

	public Mono<Optional<Boolean>> setEntityStatusWithBindValues(ObjectResponse objectResponse, EntityKind entityKind,
		Long entityId, StatusKind status, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'setEntityStatus' with parameters: {}, {}, {} ", entityKind, entityId, //$NON-NLS-1$
				status);
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'setEntityStatus'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationSetEntityStatusEntityKind", entityKind); //$NON-NLS-1$
		parametersLocal.put("mutationSetEntityStatusEntityId", entityId); //$NON-NLS-1$
		parametersLocal.put("mutationSetEntityStatusStatus", status); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getSetEntityStatus() == null) ? Optional.empty() : Optional.of(t.getSetEntityStatus()));
	}

	/**
	 * Sets entity status.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getSetEntityStatusGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<Boolean> mono = executor.setEntityStatus(preparedRequest, entityKind, // A value for
	 * 																					// setEntityStatus's
	 * 																					// entityKind input parameter
	 * 			entityId, // A value for setEntityStatus's entityId input parameter
	 * 			status, // A value for setEntityStatus's status input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		Boolean field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getSetEntityStatusGraphQLRequest(String)} method.
	 * @param entityKind Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param entityId Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param status Parameter for the setEntityStatus field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "setEntityStatus", graphQLTypeSimpleName = "Boolean", javaClass = Boolean.class)
	public Mono<Optional<Boolean>> setEntityStatus(ObjectResponse objectResponse, EntityKind entityKind, Long entityId,
		StatusKind status, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'setEntityStatus' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'setEntityStatus' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationSetEntityStatusEntityKind", entityKind); //$NON-NLS-1$
		parameters.put("mutationSetEntityStatusEntityId", entityId); //$NON-NLS-1$
		parameters.put("mutationSetEntityStatusStatus", status); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getSetEntityStatus() == null) ? Optional.empty() : Optional.of(t.getSetEntityStatus()));
	}

	/**
	 * Sets entity status.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Boolean, as expected by the
	 * setEntityStatus query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getSetEntityStatusResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"setEntityStatus", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "entityKind", "mutationSetEntityStatusEntityKind", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "EntityKind", true, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "entityId", "mutationSetEntityStatusEntityId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "Long", true, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "status", "mutationSetEntityStatusStatus", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "StatusKind", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Sets entity status.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the setEntityStatus REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getSetEntityStatusGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "setEntityStatus" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "entityKind", "mutationSetEntityStatusEntityKind", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "EntityKind", true, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "entityId", "mutationSetEntityStatusEntityId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "Long", true, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "status", "mutationSetEntityStatusStatus", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "StatusKind", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new user. This method executes a partial query against the GraphQL server. That is, the query that is
	 * one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the query that
	 * <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<User> mono = executor.createUserWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for createUser's user input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param user Parameter for the createUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> createUserWithBindValues(String queryResponseDef, UserInput user,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'createUser': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getCreateUserResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createUserWithBindValues(objectResponse, user, parameters);
	}

	/**
	 * Creates a new user.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.createUser(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for createUser's user input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param user Parameter for the createUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> createUser(String queryResponseDef, UserInput user, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'createUser': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getCreateUserResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return createUserWithBindValues(objectResponse, user,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Creates a new user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.createUserWithBindValues(preparedRequest, user, // A value for createUser's
	 * 																					// user input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateUserGraphQLRequest(String)} method.
	 * @param user Parameter for the createUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createUser", graphQLTypeSimpleName = "User", javaClass = User.class)

	public Mono<Optional<User>> createUserWithBindValues(ObjectResponse objectResponse, UserInput user,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'createUser' with parameters: {} ", user); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'createUser'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationCreateUserUser", user); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getCreateUser() == null) ? Optional.empty() : Optional.of(t.getCreateUser()));
	}

	/**
	 * Creates a new user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getCreateUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.createUser(preparedRequest, user, // A value for createUser's user input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getCreateUserGraphQLRequest(String)} method.
	 * @param user Parameter for the createUser field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "createUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> createUser(ObjectResponse objectResponse, UserInput user, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'createUser' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'createUser' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationCreateUserUser", user); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getCreateUser() == null) ? Optional.empty() : Optional.of(t.getCreateUser()));
	}

	/**
	 * Creates a new user.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the User, as expected by the createUser
	 * query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getCreateUserResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"createUser", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "user", "mutationCreateUserUser", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"UserInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Creates a new user.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the createUser REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getCreateUserGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "createUser" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "user", "mutationCreateUserUser", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"UserInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing user. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<User> mono = executor.updateUserWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for updateUser's user input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param user Parameter for the updateUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> updateUserWithBindValues(String queryResponseDef, UserInput user,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'updateUser': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getUpdateUserResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateUserWithBindValues(objectResponse, user, parameters);
	}

	/**
	 * Updates an existing user.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.updateUser(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			user, // A value for updateUser's user input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param user Parameter for the updateUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> updateUser(String queryResponseDef, UserInput user, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'updateUser': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getUpdateUserResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return updateUserWithBindValues(objectResponse, user,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.updateUserWithBindValues(preparedRequest, user, // A value for updateUser's
	 * 																					// user input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateUserGraphQLRequest(String)} method.
	 * @param user Parameter for the updateUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUser", graphQLTypeSimpleName = "User", javaClass = User.class)

	public Mono<Optional<User>> updateUserWithBindValues(ObjectResponse objectResponse, UserInput user,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'updateUser' with parameters: {} ", user); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'updateUser'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationUpdateUserUser", user); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getUpdateUser() == null) ? Optional.empty() : Optional.of(t.getUpdateUser()));
	}

	/**
	 * Updates an existing user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getUpdateUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.updateUser(preparedRequest, user, // A value for updateUser's user input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getUpdateUserGraphQLRequest(String)} method.
	 * @param user Parameter for the updateUser field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "updateUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> updateUser(ObjectResponse objectResponse, UserInput user, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'updateUser' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'updateUser' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationUpdateUserUser", user); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getUpdateUser() == null) ? Optional.empty() : Optional.of(t.getUpdateUser()));
	}

	/**
	 * Updates an existing user.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the User, as expected by the updateUser
	 * query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getUpdateUserResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"updateUser", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "user", "mutationUpdateUserUser", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"UserInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing user.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the updateUser REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getUpdateUserGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "updateUser" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "user", "mutationUpdateUserUser", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"UserInput", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing user. This method executes a partial query against the GraphQL server. That is, the query
	 * that is one of the queries defined in the GraphQL query object. The queryResponseDef contains the part of the
	 * query that <B><U>is after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<User> mono = executor.deleteUserWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for deleteUser's userId input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param userId Parameter for the deleteUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> deleteUserWithBindValues(String queryResponseDef, Long userId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'deleteUser': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getDeleteUserResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteUserWithBindValues(objectResponse, userId, parameters);
	}

	/**
	 * Updates an existing user.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.deleteUser(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for deleteUser's userId input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param userId Parameter for the deleteUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> deleteUser(String queryResponseDef, Long userId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'deleteUser': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = getDeleteUserResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return deleteUserWithBindValues(objectResponse, userId,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Updates an existing user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.deleteUserWithBindValues(preparedRequest, userId, // A value for deleteUser's
	 * 																						// userId input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteUserGraphQLRequest(String)} method.
	 * @param userId Parameter for the deleteUser field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> deleteUserWithBindValues(ObjectResponse objectResponse, Long userId,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'deleteUser' with parameters: {} ", userId); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'deleteUser'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationDeleteUserUserId", userId); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getDeleteUser() == null) ? Optional.empty() : Optional.of(t.getDeleteUser()));
	}

	/**
	 * Updates an existing user.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getDeleteUserGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.deleteUser(preparedRequest, userId, // A value for deleteUser's userId input
	 * 																		// parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getDeleteUserGraphQLRequest(String)} method.
	 * @param userId Parameter for the deleteUser field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "deleteUser", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> deleteUser(ObjectResponse objectResponse, Long userId, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'deleteUser' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'deleteUser' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationDeleteUserUserId", userId); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getDeleteUser() == null) ? Optional.empty() : Optional.of(t.getDeleteUser()));
	}

	/**
	 * Updates an existing user.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the User, as expected by the deleteUser
	 * query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getDeleteUserResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"deleteUser", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "userId", "mutationDeleteUserUserId", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Updates an existing user.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the deleteUser REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getDeleteUserGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "deleteUser" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "userId", "mutationDeleteUserUserId", InputParameterType.MANDATORY, //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				"ID", true, 0, false) //$NON-NLS-1$
		);
	}

	/**
	 * Grants permissions to a user. The specified permissions are added to any existing ones. This method executes a
	 * partial query against the GraphQL server. That is, the query that is one of the queries defined in the GraphQL
	 * query object. The queryResponseDef contains the part of the query that <B><U>is after</U></B> the query
	 * name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<User> mono = executor.grantUserPermissionsWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for grantUserPermissions's userId input parameter
	 * 			permissions, // A value for grantUserPermissions's permissions input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param userId Parameter for the grantUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param permissions Parameter for the grantUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantUserPermissions", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> grantUserPermissionsWithBindValues(String queryResponseDef, Long userId,
		List<PermissionKind> permissions, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'grantUserPermissions': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getGrantUserPermissionsResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return grantUserPermissionsWithBindValues(objectResponse, userId, permissions, parameters);
	}

	/**
	 * Grants permissions to a user. The specified permissions are added to any existing ones.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.grantUserPermissions(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for grantUserPermissions's userId input parameter
	 * 			permissions, // A value for grantUserPermissions's permissions input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param userId Parameter for the grantUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param permissions Parameter for the grantUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantUserPermissions", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> grantUserPermissions(String queryResponseDef, Long userId,
		List<PermissionKind> permissions, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'grantUserPermissions': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getGrantUserPermissionsResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return grantUserPermissionsWithBindValues(objectResponse, userId, permissions,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Grants permissions to a user. The specified permissions are added to any existing ones.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getGrantUserPermissionsGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.grantUserPermissionsWithBindValues(preparedRequest, userId, // A value for
	 * 																								// grantUserPermissions's
	 * 																								// userId input
	 * 																								// parameter
	 * 			permissions, // A value for grantUserPermissions's permissions input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGrantUserPermissionsGraphQLRequest(String)} method.
	 * @param userId Parameter for the grantUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param permissions Parameter for the grantUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantUserPermissions", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> grantUserPermissionsWithBindValues(ObjectResponse objectResponse, Long userId,
		List<PermissionKind> permissions, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'grantUserPermissions' with parameters: {}, {} ", userId, permissions); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'grantUserPermissions'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationGrantUserPermissionsUserId", userId); //$NON-NLS-1$
		parametersLocal.put("mutationGrantUserPermissionsPermissions", permissions); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getGrantUserPermissions() == null) ? Optional.empty()
				: Optional.of(t.getGrantUserPermissions()));
	}

	/**
	 * Grants permissions to a user. The specified permissions are added to any existing ones.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getGrantUserPermissionsGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.grantUserPermissions(preparedRequest, userId, // A value for
	 * 																					// grantUserPermissions's
	 * 																					// userId input parameter
	 * 			permissions, // A value for grantUserPermissions's permissions input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getGrantUserPermissionsGraphQLRequest(String)} method.
	 * @param userId Parameter for the grantUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param permissions Parameter for the grantUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "grantUserPermissions", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> grantUserPermissions(ObjectResponse objectResponse, Long userId,
		List<PermissionKind> permissions, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'grantUserPermissions' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'grantUserPermissions' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationGrantUserPermissionsUserId", userId); //$NON-NLS-1$
		parameters.put("mutationGrantUserPermissionsPermissions", permissions); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getGrantUserPermissions() == null) ? Optional.empty()
				: Optional.of(t.getGrantUserPermissions()));
	}

	/**
	 * Grants permissions to a user. The specified permissions are added to any existing ones.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the User, as expected by the
	 * grantUserPermissions query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getGrantUserPermissionsResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"grantUserPermissions", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "userId", "mutationGrantUserPermissionsUserId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "permissions", "mutationGrantUserPermissionsPermissions", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "PermissionKind", true, 1, true) //$NON-NLS-1$
		);
	}

	/**
	 * Grants permissions to a user. The specified permissions are added to any existing ones.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the grantUserPermissions REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getGrantUserPermissionsGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation,
			"grantUserPermissions" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "userId", "mutationGrantUserPermissionsUserId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "permissions", "mutationGrantUserPermissionsPermissions", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "PermissionKind", true, 1, true) //$NON-NLS-1$
		);
	}

	/**
	 * Revokes permissions from a user. The specified permissions are removed from the user; other permissions remain
	 * intact. This method executes a partial query against the GraphQL server. That is, the query that is one of the
	 * queries defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<User> mono = executor.revokeUserPermissionsWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for revokeUserPermissions's userId input parameter
	 * 			permissions, // A value for revokeUserPermissions's permissions input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param userId Parameter for the revokeUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param permissions Parameter for the revokeUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeUserPermissions", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> revokeUserPermissionsWithBindValues(String queryResponseDef, Long userId,
		List<PermissionKind> permissions, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'revokeUserPermissions': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getRevokeUserPermissionsResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return revokeUserPermissionsWithBindValues(objectResponse, userId, permissions, parameters);
	}

	/**
	 * Revokes permissions from a user. The specified permissions are removed from the user; other permissions remain
	 * intact.<br/>
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.revokeUserPermissions(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			userId, // A value for revokeUserPermissions's userId input parameter
	 * 			permissions, // A value for revokeUserPermissions's permissions input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param userId Parameter for the revokeUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param permissions Parameter for the revokeUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeUserPermissions", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> revokeUserPermissions(String queryResponseDef, Long userId,
		List<PermissionKind> permissions, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation 'revokeUserPermissions': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse =
			getRevokeUserPermissionsResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return revokeUserPermissionsWithBindValues(objectResponse, userId, permissions,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Revokes permissions from a user. The specified permissions are removed from the user; other permissions remain
	 * intact.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getRevokeUserPermissionsGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.revokeUserPermissionsWithBindValues(preparedRequest, userId, // A value for
	 * 																								// revokeUserPermissions's
	 * 																								// userId input
	 * 																								// parameter
	 * 			permissions, // A value for revokeUserPermissions's permissions input parameter
	 * 			params);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getRevokeUserPermissionsGraphQLRequest(String)} method.
	 * @param userId Parameter for the revokeUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param permissions Parameter for the revokeUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeUserPermissions", graphQLTypeSimpleName = "User", javaClass = User.class)

	public Mono<Optional<User>> revokeUserPermissionsWithBindValues(ObjectResponse objectResponse, Long userId,
		List<PermissionKind> permissions, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation 'revokeUserPermissions' with parameters: {}, {} ", userId, permissions); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'revokeUserPermissions'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();
		parametersLocal.put("mutationRevokeUserPermissionsUserId", userId); //$NON-NLS-1$
		parametersLocal.put("mutationRevokeUserPermissionsPermissions", permissions); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.getRevokeUserPermissions() == null) ? Optional.empty()
				: Optional.of(t.getRevokeUserPermissions()));
	}

	/**
	 * Revokes permissions from a user. The specified permissions are removed from the user; other permissions remain
	 * intact.<br/>
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.getRevokeUserPermissionsGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<User> mono = executor.revokeUserPermissions(preparedRequest, userId, // A value for
	 * 																					// revokeUserPermissions's
	 * 																					// userId input parameter
	 * 			permissions, // A value for revokeUserPermissions's permissions input parameter
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		User field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link getRevokeUserPermissionsGraphQLRequest(String)} method.
	 * @param userId Parameter for the revokeUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param permissions Parameter for the revokeUserPermissions field of Mutation, as defined in the GraphQL schema
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "revokeUserPermissions", graphQLTypeSimpleName = "User", javaClass = User.class)
	public Mono<Optional<User>> revokeUserPermissions(ObjectResponse objectResponse, Long userId,
		List<PermissionKind> permissions, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation 'revokeUserPermissions' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation 'revokeUserPermissions' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("mutationRevokeUserPermissionsUserId", userId); //$NON-NLS-1$
		parameters.put("mutationRevokeUserPermissionsPermissions", permissions); //$NON-NLS-1$

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.getRevokeUserPermissions() == null) ? Optional.empty()
				: Optional.of(t.getRevokeUserPermissions()));
	}

	/**
	 * Revokes permissions from a user. The specified permissions are removed from the user; other permissions remain
	 * intact.<br/>
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the User, as expected by the
	 * revokeUserPermissions query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getRevokeUserPermissionsResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"revokeUserPermissions", RequestType.mutation //$NON-NLS-1$
			, InputParameter.newBindParameter("", "userId", "mutationRevokeUserPermissionsUserId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "permissions", "mutationRevokeUserPermissionsPermissions", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "PermissionKind", true, 1, true) //$NON-NLS-1$
		);
	}

	/**
	 * Revokes permissions from a user. The specified permissions are removed from the user; other permissions remain
	 * intact.<br/>
	 * Get the {@link GraphQLReactiveRequest} for the revokeUserPermissions REACTIVE_EXECUTOR, created with the given
	 * Partial request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest getRevokeUserPermissionsGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {
		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation,
			"revokeUserPermissions" //$NON-NLS-1$
			, InputParameter.newBindParameter("", "userId", "mutationRevokeUserPermissionsUserId", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "ID", true, 0, false) //$NON-NLS-1$
			, InputParameter.newBindParameter("", "permissions", "mutationRevokeUserPermissionsPermissions", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				InputParameterType.MANDATORY, "PermissionKind", true, 1, true) //$NON-NLS-1$
		);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Map<String, Object> params = new HashMap<>();
	 * 		params.put("param", paramValue); // param is optional, as it is marked by a "?" in the request
	 * 		params.put("skip", Boolean.FALSE); // skip is mandatory, as it is marked by a "&" in the request
	 * 
	 * 		Mono<String> mono = executor.__typenameWithBindValues(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			params);
	 * 		String field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation. The given
	 * queryResponseDef describes the format of the response of the server response, that is the expected fields of the
	 * {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this type.
	 * Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query, in the native GraphQL format (see here above)
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "__typename", graphQLTypeSimpleName = "String", javaClass = String.class)
	public Mono<Optional<String>> __typenameWithBindValues(String queryResponseDef, Map<String, Object> parameters)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation '__typename': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = get__typenameResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return __typenameWithBindValues(objectResponse, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	@Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	void myMethod() {
	 * 		Mono<String> mono = executor.__typename(
	 * 			"{subfield1 @aDirectiveToDemonstrateBindVariables(if: &skip, param: ?param) subfield2 {id name}}",
	 * 			"param", paramValue, // param is optional, as it is marked by a "?" in the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		String field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query/mutation name, and the parameter(s) for the query/mutation . The
	 * given queryResponseDef describes the format of the response of the server response, that is the expected fields
	 * of the {@link Character} GraphQL type. It can be something like "{ id name }", if you want these fields of this
	 * type. Please take a look at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * @param queryResponseDef The response definition of the query/mutation, in the native GraphQL format (see here
	 * above)
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException When an error occurs during the request preparation, typically when
	 * building the {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "__typename", graphQLTypeSimpleName = "String", javaClass = String.class)
	public Mono<Optional<String>> __typename(String queryResponseDef, Object... paramsAndValues)
		throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing mutation '__typename': {} ", queryResponseDef); //$NON-NLS-1$
		ObjectResponse objectResponse = get__typenameResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return __typenameWithBindValues(objectResponse,
			this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.get__typenameGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<String> mono = executor.__typenameWithBindValues(preparedRequest, params);
	 * 		String field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link get__typenameGraphQLRequest(String)} method.
	 * @param parameters The list of values, for the bind variables defined in the query/mutation. If there is no bind
	 * variable in the defined query/mutation, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "__typename", graphQLTypeSimpleName = "String", javaClass = String.class)

	public Mono<Optional<String>> __typenameWithBindValues(ObjectResponse objectResponse,
		Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing mutation '__typename' with parameters: "); //$NON-NLS-1$
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation '__typename'"); //$NON-NLS-1$
		}

		// Given values for the BindVariables
		Map<String, Object> parametersLocal = (parameters != null) ? parameters : new HashMap<>();

		return objectResponse //
			.execReactive(Mutation.class, parametersLocal) //
			.map(t -> (t.get__typename() == null) ? Optional.empty() : Optional.of(t.get__typename()));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * &#64;Component // This class must be a spring component
	 * public class MyClass {
	 * 
	 * 	&#64;Autowired
	 * 	MutationExecutor executor;
	 * 
	 * 	GraphQLRequest preparedRequest;
	 * 
	 * 	@PostConstruct
	 * 	public void setup() {
	 * 		// Preparation of the query, so that it is prepared once then executed several times
	 * 		preparedRequest = executor.get__typenameGraphQLRequest(
	 * 			"mutation { sampleQueryOrMutationField(param: ?param)  {subfield1 @skip(if: &skip) subfield2 {id name}}}");
	 * 	}
	 * 
	 * 	void myMethod() {
	 * 		Mono<String> mono = executor.__typename(preparedRequest, "param", paramValue, // param is optional, as it
	 * 																						// is marked by a "?" in
	 * 																						// the request
	 * 			"skip", Boolean.FALSE // skip is mandatory, as it is marked by a "&" in the request
	 * 		);
	 * 		String field = mono.block();
	 * 	}
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse The definition of the response format, that describes what the GraphQL server is expected
	 * to return<br/>
	 * Note: the <code>ObjectResponse</code> type of this parameter is defined for backward compatibility. In new
	 * implementations, the expected type is the generated GraphQLRequest POJO, as returned by the
	 * {@link get__typenameGraphQLRequest(String)} method.
	 * @param paramsAndValues This parameter contains all the name and values for the Bind Variables defined in the
	 * objectResponse parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 * ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 * This parameter contains an even number of parameters: it must be a series of name and values : (paramName1,
	 * paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException When an error occurs during the request execution, typically a network
	 * error, an error from the GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "__typename", graphQLTypeSimpleName = "String", javaClass = String.class)
	public Mono<Optional<String>> __typename(ObjectResponse objectResponse, Object... paramsAndValues)
		throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuilder sb = new StringBuilder();
			sb.append("Executing mutation '__typename' with bind variables: "); //$NON-NLS-1$
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", "); //$NON-NLS-1$
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing mutation '__typename' (with bind variables)"); //$NON-NLS-1$
		}

		Map<String, Object> parameters = this.graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);

		return objectResponse //
			.execReactive(Mutation.class, parameters) //
			.map(t -> (t.get__typename() == null) ? Optional.empty() : Optional.of(t.get__typename()));
	}

	/**
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the String, as expected by the __typename
	 * query/mutation.
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder get__typenameResponseBuilder()
		throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(this.graphQlClient, GraphQLReactiveRequest.class,
			"__typename", RequestType.mutation //$NON-NLS-1$
		);
	}

	/**
	 * Get the {@link GraphQLReactiveRequest} for the __typename REACTIVE_EXECUTOR, created with the given Partial
	 * request.
	 * @param partialRequest The Partial GraphQL request, as explained in the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 * documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLReactiveRequest get__typenameGraphQLRequest(String partialRequest)
		throws GraphQLRequestPreparationException {

		return new GraphQLReactiveRequest(this.graphQlClient, partialRequest, RequestType.mutation, "__typename"); //$NON-NLS-1$

	}

}
