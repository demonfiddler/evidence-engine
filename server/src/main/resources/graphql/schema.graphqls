# ----------------------------------------------------------------------------------------------------------------------
# Evidence Engine: A system for managing evidence on arbitrary scientific topics.
# Comprises an SQL database, GraphQL public API, Java app server, Java and web clients.
# Copyright Â© 2024-25 Adrian Price. All rights reserved.
#
# This file is part of Evidence Engine.
#
# Evidence Engine is free software: you can redistribute it and/or modify it under the terms of the
# GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License,
# or (at your option) any later version.
#
# Evidence Engine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License along with Evidence Engine.
# If not, see <https://www.gnu.org/licenses/>. 
# ----------------------------------------------------------------------------------------------------------------------

#==================================================
# DIRECTIVES & CUSTOM SCALARS

"Indicates where the target is defined online."
directive @specifiedBy(url: String!) on SCALAR
"""
Indicates the authority(s) required to execute a query/operation or access a field.
Multiple values are ORed, i.e., any of the listed authorities suffices to authorise.
Default just means authentication is required but no specific authority is necessary.
"""
directive @auth(authority: [AuthorityKind!]) on OBJECT | FIELD_DEFINITION
"A label for an enum literal, typically used as a display string"
directive @label(label: String!) on ENUM_VALUE

# Custom scalar types used in this schema
scalar Country @specifiedBy(url: "https://www.iso.org/obp/ui/#search")
scalar Date @specifiedBy(url: "https://www.iso.org/iso-8601-date-and-time-format.html")
scalar DateTime @specifiedBy(url: "https://www.iso.org/iso-8601-date-and-time-format.html")
scalar ISSN @specifiedBy(url: "https://www.issn.org/understanding-the-issn/what-is-an-issn/")
scalar Long @specifiedBy(url: "https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/Long.html")
scalar URI @specifiedBy(url: "http://www.ietf.org/rfc/rfc2396.txt")
scalar URL @specifiedBy(url: "http://www.ietf.org/rfc/rfc2396.txt")
scalar Void @specifiedBy(url: "https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/Void.html")

#==================================================
# NON-DOMAIN PARAMETER TYPES

# These types are based on Spring Data's Pageable, Sort, Order, Direction and NullHandling types respectively.
"An input to specify the page number, size and sort order."
input PageableInput {
    "0-based page number, must be >= 0. Omit or set to 0 for first page."
    pageNumber: Int
    "The number of records to return. Omit or set to 0 for unpaginated."
    pageSize: Int
    "How to sort the results. Default is to use native database order."
    sort: SortInput
}

"An input to specify output sort order."
input SortInput {
    "A list of field sort specifiers."
    orders: [OrderInput!]!
}

"An input to specify how to sort results on a given field."
input OrderInput {
    "The field name."
    property: String!
    "The sort direction."
    direction: DirectionKind = ASC
    "Whether to ignore case."
    ignoreCase: Boolean = false
    # could implement with a pseudo-column e.g. ORDER BY IF(col is \N,1,0),col
    "Defines ordering of ```null``` vs non-```null``` values."
    nullHandling: NullHandlingKind = NATIVE
}

"Specifies lexical or numeric sort direction."
enum DirectionKind {
    "Ascending direction."
    ASC @label(label: "Ascending")
    "Descending direction."
    DESC @label(label: "Descending")
}

"Specifies how null values are sorted."
enum NullHandlingKind {
    "No special treatment, rely on native database null handling."
    NATIVE @label(label: "Native")
    "Nulls sort first when ascending, last when descending."
    NULLS_FIRST @label(label: "Nulls first")
    "Nulls sort last when ascending, first when descending."
    NULLS_LAST @label(label: "Nulls last")
}

#==================================================
# DOMAIN INTERFACES

"Interface for entities with a unique system-generated identifier."
interface IBaseEntity {
    "The record identifier, unique within the entity type."
    id: ID!
}

"Interface for entities with a tracked lifecycle."
interface ITrackedEntity {
    "The entity kind."
    entityKind(
        "How to format the result. SHORT format is per ```EntityKind``` enum."
        format: FormatKind = LONG
    ): String
    "The entity status."
    status(
        "How to format the result. SHORT format is per ```StatusKind``` enum."
        format: FormatKind = LONG
    ): String
    "A five-star rating for the entity, interpretation depends on entity kind."
    rating: Int
    # TODO: support date/time formatting
    "When the record was created."
    created: DateTime
    "The user who created the record."
    createdByUser: User @auth
    # TODO: support date/time formatting
    "When the record was last updated."
    updated: DateTime
    "The user who last updated the record."
    updatedByUser: User @auth
    "Log of transactions involving the record."
    log(
        "Filters results."
        filter: LogQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): LogPage!
    "Comments associated with the record."
    comments(
        "Filters results."
        filter: CommentQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): CommentPage
}

"Interface for entities that can be linked together."
interface ILinkableEntity {
    "Outbound links for which the receiver is the 'linked-from' entity"
    fromEntityLinks(
        "Filters results."
        filter: LinkableEntityQueryFilter,
        "Sorts and paginates results"
        pageSort: PageableInput
    ): EntityLinkPage
    "Inbound links for which the receiver is the 'linked-to' entity"
    toEntityLinks(
        "Filters results."
        filter: LinkableEntityQueryFilter,
        "Sorts and paginates results"
        pageSort: PageableInput
    ): EntityLinkPage
}

"Interface for returning paged results."
interface IPage {
    "Dummy ID required for @Entity classes"
    dummy: ID
    "Whether the page has content."
    hasContent: Boolean!
    "Whether the page is empty (no content)."
    isEmpty: Boolean!
    "The current page number (zero-based)."
    number: Int!
    "The page size."
    size: Int!
    "The number of elements on this page."
    numberOfElements: Int!
    "The total number of pages available."
    totalPages: Int!
    "The total number of records."
    totalElements: Long!
    "Whether this is the first page."
    isFirst: Boolean!
    "Whether this is the last page."
    isLast: Boolean!
    "Whether there is next page."
    hasNext: Boolean!
    "Whether there is previous page."
    hasPrevious: Boolean!
}

#==================================================
# DOMAIN TYPES

#"Polymorphism support. Using this construct results in the generation of an empty interface"
#union TopicalEntity = Claim | Declaration | Person | Publication | Quotation

"How to aggregate granted authorities."
enum AggregationKind {
    "Return just the authorities granted directly to the user."
    OWN @label(label: "Own authorities")
    "Return all authorities both granted directly to the user and indirectly via group memberships."
    ALL @label(label: "All authorities")
}

"A claim made in respect of given topic(s)."
type Claim implements IBaseEntity & ITrackedEntity & ILinkableEntity {
    "The unique claim identifier."
    id: ID!
    "The entity kind."
    entityKind(
        "How to format the result. SHORT format is per ```EntityKind``` enum."
        format: FormatKind = LONG
    ): String
    "The entity status."
    status(
        "How to format the result. SHORT format is per ```StatusKind``` enum."
        format: FormatKind = LONG
    ): String
    "A five-star rating for the claim, indicative of significance, credibility, evidence base, etc."
    rating: Int
    # TODO: support date/time formatting
    "When the record was created."
    created: DateTime
    "The user who created the record."
    createdByUser: User @auth
    # TODO: support date/time formatting
    "When the record was last updated."
    updated: DateTime
    "The user who last updated the record."
    updatedByUser: User @auth
    "Log of transactions involving the record."
    log(
        "Filters results."
        filter: LogQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): LogPage!
    "Comments associated with the record."
    comments(
        "Filters results."
        filter: CommentQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): CommentPage
    "Outbound links for which the receiver is the 'linked-from' entity"
    fromEntityLinks(
        "Filters results."
        filter: LinkableEntityQueryFilter,
        "Sorts and paginates results"
        pageSort: PageableInput
    ): EntityLinkPage
    "Inbound links for which the receiver is the 'linked-to' entity"
    toEntityLinks(
        "Filters results."
        filter: LinkableEntityQueryFilter,
        "Sorts and paginates results"
        pageSort: PageableInput
    ): EntityLinkPage
    "The text of the claim."
    text: String
    # TODO: support date formatting
    "The date the claim was made."
    date: Date
    "Added notes about the claim."
    notes: String
}

"An input for creating or updating a claim."
input ClaimInput {
    "The claim identifier, required if updating an existing record."
    id: ID
    "A five-star rating for the claim, indicative of significance, credibility, evidence base, etc."
    rating: Int
    "The text of the claim."
    text: String!
    "The date the claim was made."
    date: Date
    "Added notes about the claim."
    notes: String
}

"Returns paginated claim query results."
type ClaimPage implements IPage {
    "Dummy ID required for @Entity classes"
    dummy: ID
    "Whether the page has content."
    hasContent: Boolean!
    "Whether the page is empty (no content)."
    isEmpty: Boolean!
    "The current page number."
    number: Int!
    "The page size."
    size: Int!
    "The number of elements on this page."
    numberOfElements: Int!
    "The total number of pages available."
    totalPages: Int!
    "The total number of records."
    totalElements: Long!
    "Whether this is the first page."
    isFirst: Boolean!
    "Whether this is the last page."
    isLast: Boolean!
    "Whether there is next page."
    hasNext: Boolean!
    "Whether there is previous page."
    hasPrevious: Boolean!
    "The requested pageful of records."
    content: [Claim!]!
}

"A comment associated with a tracked entity."
type Comment implements IBaseEntity & ITrackedEntity {
    "The unique claim identifier."
    id: ID!
    "The entity kind."
    entityKind(
        "How to format the result. SHORT format is per ```EntityKind``` enum."
        format: FormatKind = LONG
    ): String
    "The entity status."
    status(
        "How to format the result. SHORT format is per ```StatusKind``` enum."
        format: FormatKind = LONG
    ): String
    "A five-star rating for the claim, indicative of significance, credibility, evidence base, etc."
    rating: Int
    # TODO: support date/time formatting
    "When the record was created."
    created: DateTime
    "The user who created the record."
    createdByUser: User @auth
    # TODO: support date/time formatting
    "When the record was last updated."
    updated: DateTime
    "The user who last updated the record."
    updatedByUser: User @auth
    "Log of transactions involving the record."
    log(
        "Filters results."
        filter: LogQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): LogPage!
    "Replies to this comment."
    comments(
        "Filters results."
        filter: CommentQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): CommentPage
    "The entity to which this comment is attached."
    target: ITrackedEntity
    "The parent comment to which this is a reply."
    parent: Comment
    "The text of the comment."
    text: String
}

"An input for creating or updating a comment."
input CommentInput {
    "The comment identifier, required if updating an existing record."
    id: ID
    "A five-star rating for the comment, indicative of significance, credibility, evidence base, etc."
    rating: Int
    "The ID of the target entity with which this comment is associated."
    targetId: ID!
    "The ID of the parent comment to which this comment is a reply."
    parentId: ID
    "The text of the comment."
    text: String!
}

"For filtering comment records."
input CommentQueryFilter {
    "Return only records with these status codes (default: ALL)."
    status: [StatusKind!]
    "Free text search string."
    text: String
    "Whether to search ```text``` in advanced (boolean) mode."
    advancedSearch: Boolean = false
    "The identifier of the single record to return."
    recordId: ID
    "Restrict to specific target entity kind."
    targetKind: EntityKind
    "Restrict to specific target entity ID."
    targetId: ID
    "Restrict to replies to a specific comment."
    parentId: ID
    "Restrict to comments created by a specific user."
    userId: ID
    "Timestamp of first comment to include."
    from: DateTime
    "Timestamp of last comment to include."
    to: DateTime
}

"Returns paginated comment query results."
type CommentPage implements IPage {
    "Dummy ID required for @Entity classes"
    dummy: ID
    "Whether the page has content."
    hasContent: Boolean!
    "Whether the page is empty (no content)."
    isEmpty: Boolean!
    "The current page number."
    number: Int!
    "The page size."
    size: Int!
    "The number of elements on this page."
    numberOfElements: Int!
    "The total number of pages available."
    totalPages: Int!
    "The total number of records."
    totalElements: Long!
    "Whether this is the first page."
    isFirst: Boolean!
    "Whether this is the last page."
    isLast: Boolean!
    "Whether there is next page."
    hasNext: Boolean!
    "Whether there is previous page."
    hasPrevious: Boolean!
    "The requested pageful of records."
    content: [Comment!]!
}

"Enumeration that allows selection of country format."
enum CountryFormatKind {
    "ISO-3166-1 alpha-2 two-character code."
    ALPHA_2 @label(label: "Alpha-2 code")
    "ISO-3166-1 alpha-3 three-character code."
    ALPHA_3 @label(label: "Alpha-3 code")
    "ISO-3166-1 numeric three-digit code."
    NUMERIC @label(label: "Numeric code")
    "ISO-3166-1 official country name."
    ISO_NAME @label(label: "ISO name")
    "Common name for the country."
    COMMON_NAME @label(label: "Common name")
}

"A public declaration or open letter made in respect of given topic(s)."
type Declaration implements IBaseEntity & ITrackedEntity & ILinkableEntity {
    "The unique declaration identifier."
    id: ID!
    "The entity kind."
    entityKind(
        "How to format the result. SHORT format is per ```EntityKind``` enum."
        format: FormatKind = LONG
    ): String
    "The entity status."
    status(
        "How to format the result. SHORT format is per ```StatusKind``` enum."
        format: FormatKind = LONG
    ): String
    "A five-star rating for the declaration, indicative of significance, signatory eminence/count, etc."
    rating: Int
    # TODO: support date/time formatting
    "When the record was created."
    created: DateTime
    "The user who created the record."
    createdByUser: User @auth
    # TODO: support date/time formatting
    "When the record was last updated."
    updated: DateTime
    "The user who last updated the record."
    updatedByUser: User @auth
    "Log of transactions involving the record."
    log(
        "Filters results."
        filter: LogQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): LogPage!
    "Comments associated with the record."
    comments(
        "Filters results."
        filter: CommentQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): CommentPage
    "Outbound links for which the receiver is the 'linked-from' entity"
    fromEntityLinks(
        "Filters results."
        filter: LinkableEntityQueryFilter,
        "Sorts and paginates results"
        pageSort: PageableInput
    ): EntityLinkPage
    "Inbound links for which the receiver is the 'linked-to' entity"
    toEntityLinks(
        "Filters results."
        filter: LinkableEntityQueryFilter,
        "Sorts and paginates results"
        pageSort: PageableInput
    ): EntityLinkPage
    "The kind of declaration."
    kind(
        "How to format the result. SHORT format is per ```DeclarationKind``` enum."
        format: FormatKind = LONG
    ): String
    "The declaration name or title."
    title: String
    # TODO: support date formatting
    "The date the declaration was published."
    date: Date
    "The country to which the declaration relates."
    country(
        "How to format the result."
        format: CountryFormatKind = COMMON_NAME
    ): String
    "The URL for the declaration online."
    url: URL
    "Flag to indicate that url content is cached on this application server."
    cached: Boolean
    "Names of persons who signed the declaration, one per line."
    signatories: String
    "The number of signatories."
    signatoryCount: Int
    "Added notes about the declaration."
    notes: String
    # For now, these are all supported by parameterised top-level queries.
#    "Claims made by the declaration."
#    claims: [Claim]
#    "Persons who signed the declaration."
#    persons: [Person!]
#    "Quotations from the declaration."
#    quotations: [Quotation!]
}

"An input for creating or updating a declaration."
input DeclarationInput {
    "The declaration identifier, required if updating an existing record."
    id: ID
    "A five-star rating for the declaration, indicative of significance, signatory eminence/count, etc."
    rating: Int
    "The kind of declaration."
    kind: DeclarationKind!
    "The declaration title."
    title: String
    "The date the declaration was published."
    date: Date
    "The ISO-3166-1 alpha-2 code for the country to which the declaration relates."
    country: Country
    "The URL for the declaration online."
    url: URL
    "Names of persons who signed the declaration, one per line."
    signatories: String
    "Added notes about the declaration."
    notes: String
}

"Returns paginated declaration query results."
type DeclarationPage implements IPage {
    "Dummy ID required for @Entity classes"
    dummy: ID
    "Whether the page has content."
    hasContent: Boolean!
    "Whether the page is empty (no content)."
    isEmpty: Boolean!
    "The current page number."
    number: Int!
    "The page size."
    size: Int!
    "The number of elements on this page."
    numberOfElements: Int!
    "The total number of pages available."
    totalPages: Int!
    "The total number of records."
    totalElements: Long!
    "Whether this is the first page."
    isFirst: Boolean!
    "Whether this is the last page."
    isLast: Boolean!
    "Whether there is next page."
    hasNext: Boolean!
    "Whether there is previous page."
    hasPrevious: Boolean!
    "The requested pageful of records."
    content: [Declaration!]!
}

"Enumeration of permitted declaration kinds."
enum DeclarationKind {
    "Public declaration."
    DECL @label(label: "Declaration")
    "Open letter."
    OPLE @label(label: "Open letter")
    "Petition."
    PETN @label(label: "Petition")
}

"Enumeration for entity kind."
enum EntityKind {
    "Claim."
    CLA @label(label: "Claim")
    "Comment."
    COM @label(label: "Comment")
    "Country."
    COU @label(label: "Country")
    "Declaration."
    DEC @label(label: "Declaration")
    "Group."
    GRP @label(label: "Group")
    "Journal."
    JOU @label(label: "Journal")
    "Link."
    LNK @label(label: "Link")
    "Person."
    PER @label(label: "Person")
    "Publication."
    PUB @label(label: "Publication")
    "Publisher."
    PBR @label(label: "Publisher")
    "Quotation."
    QUO @label(label: "Quotation")
    "Topic."
    TOP @label(label: "Topic")
    "User."
    USR @label(label: "User")
}

"An association between two entity records."
type EntityLink implements IBaseEntity & ITrackedEntity {
    "The unique declaration identifier."
    id: ID!
    "The entity kind."
    entityKind(
        "How to format the result. SHORT format is per ```EntityKind``` enum."
        format: FormatKind = LONG
    ): String
    "The entity status."
    status(
        "How to format the result. SHORT format is per ```StatusKind``` enum."
        format: FormatKind = LONG
    ): String
    "A five-star rating for the link, indicative of significancce, credibility, evidence base, etc."
    rating: Int
    # TODO: support date/time formatting
    "When the record was created."
    created: DateTime
    "The user who created the record."
    createdByUser: User @auth
    # TODO: support date/time formatting
    "When the record was last updated."
    updated: DateTime
    "The user who last updated the record."
    updatedByUser: User @auth
    "Log of transactions involving the record."
    log(
        "Filters results."
        filter: LogQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): LogPage!
    "Comments associated with the record."
    comments(
        "Filters results."
        filter: CommentQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): CommentPage
    "The 'linked-from' entity."
    fromEntity: ILinkableEntity
    "The locations within the 'linked-from' record, one per line."
    fromEntityLocations: String
    "The 'linked-to' entity."
    toEntity: ILinkableEntity
    "The locations within the 'linked-to' record, one per line."
    toEntityLocations: String
}

"An input for linking two entities."
input EntityLinkInput {
    "The entity link identifier, required if updating an existing record."
    id: ID
    "A five-star rating for the link, indicative of significancce, credibility, evidence base, etc."
    rating: Int
    "The ID of the 'linked-from' entity."
    fromEntityId: ID!
    "The locations within the 'linked-from' record, one per line."
    fromEntityLocations: String
    "The ID of the 'linked-to' entity."
    toEntityId: ID!
    "The locations within the 'linked-to' record, one per line."
    toEntityLocations: String
}

"Returns paginated entity link query results."
type EntityLinkPage implements IPage {
    "Dummy ID required for @Entity classes"
    dummy: ID
    "Whether the page has content."
    hasContent: Boolean!
    "Whether the page is empty (no content)."
    isEmpty: Boolean!
    "The current page number."
    number: Int!
    "The page size."
    size: Int!
    "The number of elements on this page."
    numberOfElements: Int!
    "The total number of pages available."
    totalPages: Int!
    "The total number of records."
    totalElements: Long!
    "Whether this is the first page."
    isFirst: Boolean!
    "Whether this is the last page."
    isLast: Boolean!
    "Whether there is next page."
    hasNext: Boolean!
    "Whether there is previous page."
    hasPrevious: Boolean!
    "The requested pageful of records."
    content: [EntityLink!]!
}

"Parameters to filter an entity link query."
input EntityLinkQueryFilter {
    "The ID of the 'linked-from' (master) entity."
    fromEntityId: ID
    # Do we actually need this field? Certainly not if fromEntityId is specified but what if it isn't? Would that mean select target records if they are linked from by any entity of this kind? Is that even a useful/meaningful query? NO!
    "The kind of the 'linked-from' entity."
    fromEntityKind: EntityKind
    "The ID of the 'linked-to' entity."
    toEntityId: ID
    # Do we actually need this field? Certainly not if toEntityId is specified but what if it isn't? Would that mean select target records of the specified type if they are linked from by fromEntityid? That is a useful/meaningful query.
    "The kind of the 'linked-to' entity."
    toEntityKind: EntityKind
    "Return only records with these status codes (default: ALL)."
    status: [StatusKind!]
    "Free text search string (applied to the 'linked-to' entity)."
    text: String
    "Whether to search ```text``` in advanced (boolean) mode."
    advancedSearch: Boolean = false
}

"""
Enumeration to specify whether to return the short (abbreviated) or long (full) value.
Applied, for example, to publication kind and journal title, both of which have short and long versions, (e.g., code and label).
"""
enum FormatKind {
    "Short form, abbreviated/coded, e.g. enum literal."
    SHORT @label(label: "Short")
    "Long form, human readadble, e.g. enum label."
    LONG @label(label: "Long")
}

"Journal details including abbreviation, publisher, etc."
type Journal implements IBaseEntity & ITrackedEntity {
    "The unique journal identifier."
    id: ID!
    "The entity kind."
    entityKind(
        "How to format the result. SHORT format is per ```EntityKind``` enum."
        format: FormatKind = LONG
    ): String
    "The entity status."
    status(
        "How to format the result. SHORT format is per ```StatusKind``` enum."
        format: FormatKind = LONG
    ): String
    "A five-star rating for the journal, indicative of prestige, impact, circulation, etc."
    rating: Int
    # TODO: support date/time formatting
    "When the record was created."
    created: DateTime
    "The user who created the record."
    createdByUser: User @auth
    # TODO: support date/time formatting
    "When the record was last updated."
    updated: DateTime
    "The user who last updated the record."
    updatedByUser: User @auth
    "Log of transactions involving the record."
    log(
        "Filters results."
        filter: LogQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): LogPage!
    "Comments associated with the record."
    comments(
        "Filters results."
        filter: CommentQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): CommentPage
    "The full journal title."
    title: String
    "The official ISO 4 abbreviation."
    abbreviation: String
    "Web link to the journal's home page."
    url: URL
    "The International Standard Serial Number."
    issn: ISSN
    "The journal publisher."
    publisher: Publisher
    "Notes about the journal."
    notes: String
}

"An input for creating or updating a journal."
input JournalInput {
    "The journal identifier, required if updating an existing record."
    id: ID
    "A five-star rating for the journal, indicative of prestige, impact, circulation, etc."
    rating: Int
    "The full journal title."
    title: String!
    "The official ISO 4 abbreviation."
    abbreviation: String!
    url: URL
    "The International Standard Serial Number."
    issn: ISSN
    "The ID of the journal publisher."
    publisherId: Long
    "Notes about the journal."
    notes: String
}

"Returns paginated query results."
type JournalPage implements IPage {
    "Dummy ID required for @Entity classes"
    dummy: ID
    "Whether the page has content."
    hasContent: Boolean!
    "Whether the page is empty (no content)."
    isEmpty: Boolean!
    "The current page number."
    number: Int!
    "The page size."
    size: Int!
    "The number of elements on this page."
    numberOfElements: Int!
    "The total number of pages available."
    totalPages: Int!
    "The total number of records."
    totalElements: Long!
    "Whether this is the first page."
    isFirst: Boolean!
    "Whether this is the last page."
    isLast: Boolean!
    "Whether there is next page."
    hasNext: Boolean!
    "Whether there is previous page."
    hasPrevious: Boolean!
    "The requested pageful of records."
    content: [Journal!]!
}

"Parameters to filter an linkable entity query."
input LinkableEntityQueryFilter {
    "The topic identifier, mandatory when querying the master list or when master = NONE."
    topicId: ID
    "Whether queries including a topicId should be executed recursively."
    recursive: Boolean
    "The ID of the 'linked-from' (master) entity."
    fromEntityId: ID
    # Do we actually need this field? Certainly not if fromEntityId is specified but what if it isn't? Would that mean select target records if they are linked from by any entity of this kind? Is that even a useful/meaningful query? NO!
    "The kind of the 'linked-from' entity."
    fromEntityKind: EntityKind
    "The ID of the 'linked-to' entity."
    toEntityId: ID
    # Do we actually need this field? Certainly not if toEntityId is specified but what if it isn't? Would that mean select target records of the specified type if they are linked from by fromEntityid? That is a useful/meaningful query.
    "The kind of the 'linked-to' entity."
    toEntityKind: EntityKind
    "Return only records with these status codes (default: ALL)."
    status: [StatusKind!]
    "Free text search string (applied to the 'linked-to' entity)."
    text: String
    "Whether to search ```text``` in advanced (boolean) mode."
    advancedSearch: Boolean = false
    "The identifier of the single record to return."
    recordId: ID
}

# TODO: See whether GraphQL has any hook points to perform logging
"A log entry to show who changed what and when."
type Log implements IBaseEntity {
    "The unique identifier for the log entry."
    id: ID!
    # TODO: support date/time formatting
    "The date-time stamp."
    timestamp: DateTime
    "The user who made the change."
    user: User @auth
    "The kind of transaction."
    transactionKind(
        "How to format the result. SHORT format is per ```TransactionKind``` enum."
        format: FormatKind = LONG
    ): String
    "The kind of entity affected."
    entityKind(
        "How to format the result. SHORT format is per ```EntityKind``` enum."
        format: FormatKind = LONG
    ): String
    "The ID of the entity affected."
    entityId: Long
    "The kind of entity linked/unlinked (where applicable)."
    linkedEntityKind(
        "How to format the result. SHORT format is per ```EntityKind``` enum."
        format: FormatKind = LONG
    ): String
    "The ID of the entity linked/unlinked (where applicable)."
    linkedEntityId: Long
}

"For filtering log records."
input LogQueryFilter {
    "Restrict to specific entity kind."
    entityKind: EntityKind
    "Restrict to specific entity ID."
    entityId: ID
    "Restrict to transactions performed by a specific user."
    userId: ID
    "Restrict to specific transaction kinds."
    transactionKinds: [TransactionKind!]
    "Timestamp of first log entry to include."
    from: DateTime
    "Timestamp of last log entry to include."
    to: DateTime
}

"Returns paginated log query results."
type LogPage implements IPage {
    "Dummy ID required for @Entity classes"
    dummy: ID
    "Whether the page has content."
    hasContent: Boolean!
    "Whether the page is empty (no content)."
    isEmpty: Boolean!
    "The current page number."
    number: Int!
    "The page size."
    size: Int!
    "The number of elements on this page."
    numberOfElements: Int!
    "The total number of pages available."
    totalPages: Int!
    "The total number of records."
    totalElements: Long!
    "Whether this is the first page."
    isFirst: Boolean!
    "Whether this is the last page."
    isLast: Boolean!
    "Whether there is next page."
    hasNext: Boolean!
    "Whether there is previous page."
    hasPrevious: Boolean!
    "The requested pageful of records."
    content: [Log!]!
}

"User/Group access authorities."
enum AuthorityKind {
    "Use administrative functions."
    ADM @label(label: "Administer")
    "Comment on records."
    COM @label(label: "Comment")
    "Insert new record."
    CRE @label(label: "Create")
    "Delete existing record."
    DEL @label(label: "Delete")
    "Link/unlink existing records."
    LNK @label(label: "Link")
    "Read existing record."
    REA @label(label: "Read")
    "Update existing record."
    UPD @label(label: "Update")
    "Upload file."
    UPL @label(label: "Upload")
}

"A person associated with given topic(s)."
type Person implements IBaseEntity & ITrackedEntity & ILinkableEntity {
    "The unique person identifier."
    id: ID!
    "The entity kind."
    entityKind(
        "How to format the result. SHORT format is per ```EntityKind``` enum."
        format: FormatKind = LONG
    ): String
    "The entity status."
    status(
        "How to format the result. SHORT format is per ```StatusKind``` enum."
        format: FormatKind = LONG
    ): String
    "A five-star rating for the person, intended to reflect eminence, credibility, experience, qualifications, publications, etc."
    rating: Int
    # TODO: support date/time formatting
    "When the record was created."
    created: DateTime
    "The user who created the record."
    createdByUser: User @auth
    # TODO: support date/time formatting
    "When the record was last updated."
    updated: DateTime
    "The user who last updated the record."
    updatedByUser: User @auth
    "Log of transactions involving the record."
    log(
        "Filters results."
        filter: LogQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): LogPage!
    "Comments associated with the record."
    comments(
        "Filters results."
        filter: CommentQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): CommentPage
    "Outbound links for which the receiver is the 'linked-from' entity"
    fromEntityLinks(
        "Filters results."
        filter: LinkableEntityQueryFilter,
        "Sorts and paginates results"
        pageSort: PageableInput
    ): EntityLinkPage
    "Inbound links for which the receiver is the 'linked-to' entity"
    toEntityLinks(
        "Filters results."
        filter: LinkableEntityQueryFilter,
        "Sorts and paginates results"
        pageSort: PageableInput
    ): EntityLinkPage
    "The person's title(s)."
    title: String
    "The person's first name(s)."
    firstName: String
    "The person's nickname."
    nickname: String
    "The prefix to the person's last name."
    prefix: String
    "The person's last name."
    lastName: String
    "The suffix to the person's name."
    suffix: String
    "Last name alias."
    alias: String
    "Brief biography, notes, etc."
    notes: String
    "Academic qualifications."
    qualifications: String
    "The primary country associated with the person."
    country(
        "How to format the result."
        format: CountryFormatKind = COMMON_NAME
    ): String
    "Whether the person's credentials have been checked."
    checked: Boolean
    "Whether the person has authored any peer-reviewed publications."
    published: Boolean
}

"An input for creating or updating a person."
input PersonInput {
    "The person identifier, required if updating an existing record."
    id: ID
    "A five-star rating for the person, intended to reflect eminence, credibility, experience, qualifications, publications, etc."
    rating: Int
    "The person's title(s)."
    title: String
    "The person's first name(s)."
    firstName: String!
    "The person's nickname."
    nickname: String
    "The prefix to the person's last name."
    prefix: String
    "The person's last name."
    lastName: String!
    "The suffix to the person's name."
    suffix: String
    "Alias name."
    alias: String
    "Person's description and biographical details."
    notes: String
    "Person's academic qualifications."
    qualifications: String
    "The ISO-3166-1 alpha-2 code for the primary country associated with the person."
    country: Country
    "Whether the person's credentials have been checked."
    checked: Boolean
    "Whether the person has authored any peer-reviewed publications."
    published: Boolean
}

"Returns paginated person query results."
type PersonPage implements IPage {
    "Dummy ID required for @Entity classes"
    dummy: ID
    "Whether the page has content."
    hasContent: Boolean!
    "Whether the page is empty (no content)."
    isEmpty: Boolean!
    "The current page number."
    number: Int!
    "The page size."
    size: Int!
    "The number of elements on this page."
    numberOfElements: Int!
    "The total number of pages available."
    totalPages: Int!
    "The total number of records."
    totalElements: Long!
    "Whether this is the first page."
    isFirst: Boolean!
    "Whether this is the last page."
    isLast: Boolean!
    "Whether there is next page."
    hasNext: Boolean!
    "Whether there is previous page."
    hasPrevious: Boolean!
    "The requested pageful of records."
    content: [Person!]!
}

"A publication associated with given topics."
type Publication implements IBaseEntity & ITrackedEntity & ILinkableEntity {
    "The unique publication identifier."
    id: ID!
    "The entity kind."
    entityKind(
        "How to format the result. SHORT format is per ```EntityKind``` enum."
        format: FormatKind = LONG
    ): String
    "The entity status."
    status(
        "How to format the result. SHORT format is per ```StatusKind``` enum."
        format: FormatKind = LONG
    ): String
    "A five-star rating for the publication, indicative of impact, quality, credibility, citations, etc."
    rating: Int
    # TODO: support date/time formatting
    "When the record was created."
    created: DateTime
    "The user who created the record."
    createdByUser: User @auth
    # TODO: support date/time formatting
    "When the record was last updated."
    updated: DateTime
    "The user who last updated the record."
    updatedByUser: User @auth
    "Log of transactions involving the record."
    log(
        "Filters results."
        filter: LogQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): LogPage!
    "Comments associated with the record."
    comments(
        "Filters results."
        filter: CommentQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): CommentPage
    "Outbound links for which the receiver is the 'linked-from' entity"
    fromEntityLinks(
        "Filters results."
        filter: LinkableEntityQueryFilter,
        "Sorts and paginates results"
        pageSort: PageableInput
    ): EntityLinkPage
    "Inbound links for which the receiver is the 'linked-to' entity"
    toEntityLinks(
        "Filters results."
        filter: LinkableEntityQueryFilter,
        "Sorts and paginates results"
        pageSort: PageableInput
    ): EntityLinkPage
    "The publication title."
    title: String
    "The names of the authors, one per line."
    authors: String
    "The journal in which the publication appeared."
    journal: Journal
    "The publication kind."
    kind(
        "How to format the result. SHORT format is per ```PublicationKind``` enum."
        format: FormatKind = LONG
    ): String
    # TODO: support date formatting
    "The publication date."
    date: Date
    "The publication year."
    year: Int
    "The publication abstract."
    abstract: String
    "User notes about the publication."
    notes: String
    "Whether the publication has been peer reviewed."
    peerReviewed: Boolean
    "The Digital Object Identifier."
    doi: String
    "The International Standard Book Number."
    isbn: String
    "The U.S. National Library of Medicine's PubMedID."
    pmid: String
    "The Corporation for National Research Initiatives's Handle System ID."
    hsid: String
    "Cornell University Library's arXiv.org ID."
    arxivid: String
    "Cold Spring Harbor Laboratory's bioRxiv.org ID."
    biorxivid: String
    "Cold Spring Harbor Laboratory's medRxiv.org ID."
    medrxivid: String
    "U.S. Department of Education's ERIC database ID (niche)."
    ericid: String
    "CERN's INSPIRE-HEP ID."
    ihepid: String
    "Open Archives Initiative's OAI-PMH ID."
    oaipmhid: String
    "CNRS (France)'s HAL ID."
    halid: String
    "CERN's Zenodo Record ID."
    zenodoid: String
    "Elsevier's SCOPUS database EID (proprietary)."
    scopuseid: String
    "Clarivate's Web of Science Accession Number (UT) (proprietary)."
    wsan: String
    "American Psychological Association's PsycINFO Accession Number (proprietary/niche)."
    pinfoan: String
    "The URL for the publication online."
    url: URL
    "Flag to indicate that url content is cached on this application server."
    cached: Boolean
    # TODO: support date formatting
    "The date the publication was accessed when compiling the database."
    accessed: Date
}

"An input for creating or updating a publication."
input PublicationInput {
    "The publication identifier, required if updating an existing record."
    id: ID
    "A five-star rating for the publication, indicative of impact, quality, credibility, citations, etc."
    rating: Int
    "The names of the author, one per line."
    authorNames: String
    "The identifier(s) of the author(s) of the publication."
    authorIds: [ID!]
    "The publication title."
    title: String!
    "The journal in which the publication appeared."
    journalId: Long
    "The publication type."
    kind: PublicationKind!
    "The publication date."
    date: Date
    "The publication year."
    year: Int
    "The publication abstract."
    abstract: String
    "User notes about the publication."
    notes: String
    "Whether the publication has been peer reviewed."
    peerReviewed: Boolean
    "The digital object identifier."
    doi: String
    "The International Standard Book Number."
    isbn: String
    "The U.S. National Library of Medicine's PubMedID."
    pmid: String
    "The Corporation for National Research Initiatives's Handle System ID."
    hsid: String
    "Cornell University Library's arXiv.org ID."
    arxivid: String
    "Cold Spring Harbor Laboratory's bioRxiv.org ID."
    biorxivid: String
    "Cold Spring Harbor Laboratory's medRxiv.org ID."
    medrxivid: String
    "U.S. Department of Education's ERIC database ID (niche)."
    ericid: String
    "CERN's INSPIRE-HEP ID."
    ihepid: String
    "Open Archives Initiative's OAI-PMH ID."
    oaipmhid: String
    "CNRS (France)'s HAL ID."
    halid: String
    "CERN's Zenodo Record ID."
    zenodoid: String
    "Elsevier's SCOPUS database EID (proprietary)."
    scopuseid: String
    "Clarivate's Web of Science Accession Number (UT) (proprietary)."
    wsan: String
    "American Psychological Association's PsycINFO Accession Number (proprietary/niche)."
    pinfoan: String
    "The URL for the publication online."
    url: URL
    "The date the publication was accessed when compiling the database."
    accessed: Date
    "Flag to indicate that url content is cached on this application server."
    cached: Boolean
}

"Enumeration of publication type codes, per TY field of the RIS specification."
enum PublicationKind {
    "Abstract."
    ABST
    "Audiovisual material."
    ADVS
    "Aggregated database."
    AGGR
    "Ancient text."
    ANCIENT
    "Art work."
    ART
    "Bill/resolution."
    BILL
    "Blog."
    BLOG
    "Book, whole."
    BOOK
    "Case"
    CASE
    "Book section."
    CHAP
    "Chart."
    CHART
    "Classical work."
    CLSWK
    "Computer program."
    COMP
    "Conference proceeding."
    CONF
    "Conference paper."
    CPAPER
    "Catalogue."
    CTLG
    "Dataset."
    DATA
    "Online database."
    DBASE
    "Dictionary."
    DICT
    "Electronic book."
    EBOOK
    "Electronic book section."
    ECHAP
    "Edited book."
    EDBOOK
    "Electronic article."
    EJOUR
    "Electronic citation."
    ELEC
    "Encyclopaedia article."
    ENCYC
    "Equation."
    EQUA
    "Figure."
    FIGURE
    "Generic."
    GEN
    "Government document."
    GOVDOC
    "Grant."
    GRANT
    "Hearing."
    HEAR
    "Internet communication."
    ICOMM
    "In Press."
    INPR
    "Journal (full)."
    JFULL
    "Journal."
    JOUR
    "Legal rule or regulation."
    LEGAL
    "Manuscript."
    MANSCPT
    "Map."
    MAP
    "Magazine article."
    MGZN
    "Motion picture."
    MPCT
    "Online multimedia."
    MULTI
    "Music score."
    MUSIC
    "Newspaper."
    NEWS
    "Pamphlet."
    PAMP
    "Patent."
    PAT
    "Personal communication."
    PCOMM
    "Report."
    RPRT
    "Serial publication."
    SER
    "Slide presentation."
    SLIDE
    "Sound recording."
    SOUND
    "Standard."
    STAND
    "Statute."
    STAT
    "Thesis/dissertation."
    THES
    "Unenacted bill/resolution."
    UNBILL
    "Unpublished work."
    UNPB
    "Video recording."
    VIDEO
    "Web page."
    WEB
}

"Returns paginated publication query results."
type PublicationPage implements IPage {
    "Dummy ID required for @Entity classes"
    dummy: ID
    "Whether the page has content."
    hasContent: Boolean!
    "Whether the page is empty (no content)."
    isEmpty: Boolean!
    "The current page number."
    number: Int!
    "The page size."
    size: Int!
    "The number of elements on this page."
    numberOfElements: Int!
    "The total number of pages available."
    totalPages: Int!
    "The total number of records."
    totalElements: Long!
    "Whether this is the first page."
    isFirst: Boolean!
    "Whether this is the last page."
    isLast: Boolean!
    "Whether there is next page."
    hasNext: Boolean!
    "Whether there is previous page."
    hasPrevious: Boolean!
    "The requested pageful of records."
    content: [Publication!]!
}

"Book, journal, etc. publisher details."
type Publisher implements IBaseEntity & ITrackedEntity {
    "The unique publisher identifier."
    id: ID!
    "The entity kind."
    entityKind(
        "How to format the result. SHORT format is per ```EntityKind``` enum."
        format: FormatKind = LONG
    ): String
    "The entity status."
    status(
        "How to format the result. SHORT format is per ```StatusKind``` enum."
        format: FormatKind = LONG
    ): String
    "A five-star rating for the publisher, indicative of prestige, reputation, impact, quality, etc."
    rating: Int
    # TODO: support date/time formatting
    "When the record was created."
    created: DateTime
    "The user who created the record."
    createdByUser: User @auth
    # TODO: support date/time formatting
    "When the record was last updated."
    updated: DateTime
    "The user who last updated the record."
    updatedByUser: User @auth
    "Log of transactions involving the record."
    log(
        "Filters results."
        filter: LogQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): LogPage!
    "Comments associated with the record."
    comments(
        "Filters results."
        filter: CommentQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): CommentPage
    "The publisher name."
    name: String
    "The publisher location."
    location: String
    "The publisher country."
    country(
        "How to format the result."
        format: CountryFormatKind = COMMON_NAME
    ): String
    "URL of publisher's home page."
    url: URL
    "The number of journals published."
    journalCount: Int
}

"An input for creating or updating a publisher."
input PublisherInput {
    "The unique publisher identifier."
    id: ID
    "A five-star rating for the publisher, indicative of prestige, reputation, impact, quality, etc."
    rating: Int
    "The publisher name."
    name: String!
    "The publisher location."
    location: String
    "The ISO-3166-1 alpha-2 code for the publisher's country."
    country: Country
    "URL of publisher's home page."
    url: URL
    "The number of journals published."
    journalCount: Int
}

"Returns paginated publisher query results."
type PublisherPage implements IPage {
    "Dummy ID required for @Entity classes"
    dummy: ID
    "Whether the page has content."
    hasContent: Boolean!
    "Whether the page is empty (no content)."
    isEmpty: Boolean!
    "The current page number."
    number: Int!
    "The page size."
    size: Int!
    "The number of elements on this page."
    numberOfElements: Int!
    "The total number of pages available."
    totalPages: Int!
    "The total number of records."
    totalElements: Long!
    "Whether this is the first page."
    isFirst: Boolean!
    "Whether this is the last page."
    isLast: Boolean!
    "Whether there is next page."
    hasNext: Boolean!
    "Whether there is previous page."
    hasPrevious: Boolean!
    "The requested pageful of records."
    content: [Publisher!]!
}

"A quotation associated with given topics."
type Quotation implements IBaseEntity & ITrackedEntity & ILinkableEntity {
    "The unique quotation identifier."
    id: ID!
    "The entity kind."
    entityKind(
        "How to format the result. SHORT format is per ```EntityKind``` enum."
        format: FormatKind = LONG
    ): String
    "The entity status."
    status(
        "How to format the result. SHORT format is per ```StatusKind``` enum."
        format: FormatKind = LONG
    ): String
    "A five-star rating for the quotation, indicative of impact, credibility, etc."
    rating: Int
    # TODO: support date/time formatting
    "When the record was created."
    created: DateTime
    "The user who created the record."
    createdByUser: User @auth
    # TODO: support date/time formatting
    "When the record was last updated."
    updated: DateTime
    "The user who last updated the record."
    updatedByUser: User @auth
    "Log of transactions involving the record."
    log(
        "Filters results."
        filter: LogQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): LogPage!
    "Comments associated with the record."
    comments(
        "Filters results."
        filter: CommentQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): CommentPage
    "Outbound links for which the receiver is the 'linked-from' entity"
    fromEntityLinks(
        "Filters results."
        filter: LinkableEntityQueryFilter,
        "Sorts and paginates results"
        pageSort: PageableInput
    ): EntityLinkPage
    "Inbound links for which the receiver is the 'linked-to' entity"
    toEntityLinks(
        "Filters results."
        filter: LinkableEntityQueryFilter,
        "Sorts and paginates results"
        pageSort: PageableInput
    ): EntityLinkPage
    "The text of the quotation."
    text: String
    "The person(s) who made the quotation."
    quotee: String
    # TODO: support date formatting
    "The quotation date."
    date: Date
    "The quotation source."
    source: String
    "The URL for the quotation online."
    url: URL
    "Notes on the quotation."
    notes: String
}

"An input for creating or updating a quotation."
input QuotationInput {
    "The quotation identifier, required if updating an existing record."
    id: ID
    "A five-star rating for the quotation, indicative of impact, credibility, etc."
    rating: Int
    "The text of the quotation."
    text: String!
    "The identifier of the quotee."
    quotee: String!
    "The quotation date."
    date: Date!
    "The quotation source."
    source: String
    "The URL for the quotation online."
    url: URL
    "Notes on the quotation."
    notes: String
}

"Returns paginated quotation query results."
type QuotationPage implements IPage {
    "Dummy ID required for @Entity classes"
    dummy: ID
    "Whether the page has content."
    hasContent: Boolean!
    "Whether the page is empty (no content)."
    isEmpty: Boolean!
    "The current page number."
    number: Int!
    "The page size."
    size: Int!
    "The number of elements on this page."
    numberOfElements: Int!
    "The total number of pages available."
    totalPages: Int!
    "The total number of records."
    totalElements: Long!
    "Whether this is the first page."
    isFirst: Boolean!
    "Whether this is the last page."
    isLast: Boolean!
    "Whether there is next page."
    hasNext: Boolean!
    "Whether there is previous page."
    hasPrevious: Boolean!
    "The requested pageful of records."
    content: [Quotation!]!
}

# "Enumeration of lexical or numeric sort orders."
# enum SortKind {
#     "Ascending order."
#     ASC
#     "Descending order."
#     DESC
# }

"Statistics about a given entity kind."
type EntityStatistics {
    "The entity kind."
    entityKind(
        "How to format the result. SHORT format is per ```EntityKind``` enum."
        format: FormatKind = LONG
    ): String
    "The number of entities of that kind."
    count: Long
}

"Statistics about a given topic."
type TopicStatistics {
    "The topic in question."
    topic: Topic
    "Statistics for the requested entities."
    entityStatistics: [EntityStatistics!]
    "Statistics for the immediate sub-topics."
    children: [TopicStatistics!]
}

"Parameters to filter a statstics query."
input StatisticsQueryFilter {
    "Include only entities with these statuses."
    status: [StatusKind!]
}

"Enumeration of ITrackedEntity status codes."
enum StatusKind {
    "Record is draft/new."
    DRA @label(label: "Draft")
    "Record is published/active."
    PUB @label(label: "Published")
    "Record is suspended/disabled/hidden."
    SUS @label(label: "Suspended")
    "Record is deleted."
    DEL @label(label: "Deleted")
}

"A node in the topic hierarchy tree."
type Topic implements IBaseEntity & ITrackedEntity & ILinkableEntity {
    "The unique topic identifier."
    id: ID!
    "The entity kind"
    entityKind(
        "How to format the result. SHORT format is per ```EntityKind``` enum."
        format: FormatKind = LONG
    ): String
    "The entity status."
    status(
        "How to format the result. SHORT format is per ```StatusKind``` enum."
        format: FormatKind = LONG
    ): String
    "A five-star rating for the topic, indicative of significance, evidence base, etc."
    rating: Int
    # TODO: support date/time formatting
    "When the record was created."
    created: DateTime
    "The user who created the record."
    createdByUser: User @auth
    # TODO: support date/time formatting
    "When the record was last updated."
    updated: DateTime
    "The user who last updated the record."
    updatedByUser: User @auth
    "Log of transactions involving the record."
    log(
        "Filters results."
        filter: LogQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): LogPage!
    "Comments associated with the record."
    comments(
        "Filters results."
        filter: CommentQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): CommentPage
    "The topic label for display in the user interface."
    label: String
    "The topic description."
    description: String
    "The parent topic."
    parent: Topic
    "The sub-topics."
    children: [Topic!]
    "Outbound links for which the receiver is the 'linked-from' entity"
    fromEntityLinks(
        "Filters results."
        filter: LinkableEntityQueryFilter,
        "Sorts and paginates results"
        pageSort: PageableInput
    ): EntityLinkPage
    "Inbound links for which the receiver is the 'linked-to' entity. N.B. always empty for topics"
    toEntityLinks(
        "Filters results."
        filter: LinkableEntityQueryFilter,
        "Sorts and paginates results"
        pageSort: PageableInput
    ): EntityLinkPage
}

"An input for creating or updating a topic."
input TopicInput {
    "The unique topic identifier."
    id: ID
    "A five-star rating for the topic, indicative of significance, evidence base, etc."
    rating: Int
    "The topic label for display in the user interface."
    label: String!
    "The topic description."
    description: String
    "The identifier of the parent topic."
    parentId: Long
}

"Parameters to filter a topic query."
input TopicQueryFilter {
    "The parent topic identifier. Specify to get sub-topics, use -1 for top-level topics."
    parentId: ID
    "Whether to return all sub-topics, recursively."
    recursive: Boolean = false
    "Return only topics with these status codes (default: ALL)."
    status: [StatusKind!]
    "Free text search string."
    text: String
    "Whether to search ```text``` in advanced (boolean) mode."
    advancedSearch: Boolean = false
    "The identifier of the single record to return."
    recordId: ID
}

"Returns paginated topic query results."
type TopicPage implements IPage {
    "Dummy ID required for @Entity classes"
    dummy: ID
    "Whether the page has content."
    hasContent: Boolean!
    "Whether the page is empty (no content)."
    isEmpty: Boolean!
    "The current page number."
    number: Int!
    "The page size."
    size: Int!
    "The number of elements on this page."
    numberOfElements: Int!
    "The total number of pages available."
    totalPages: Int!
    "The total number of records."
    totalElements: Long!
    "Whether this is the first page."
    isFirst: Boolean!
    "Whether this is the last page."
    isLast: Boolean!
    "Whether there is next page."
    hasNext: Boolean!
    "Whether there is previous page."
    hasPrevious: Boolean!
    "The requested pageful of records."
    content: [Topic!]!
}

"Parameters to filter an ```ITrackedEntity``` query."
input TrackedEntityQueryFilter {
    "Return only records with these status codes (default: ALL)."
    status: [StatusKind!]
    "Free text search string."
    text: String
    "Whether to search ```text``` in advanced (boolean) mode."
    advancedSearch: Boolean = false
    "The identifier of the single record to return."
    recordId: ID
}

"Enumeration of the possible transaction kinds."
enum TransactionKind {
    "Record created."
    CRE @label(label: "Created")
    "Record updated."
    UPD @label(label: "Updated")
    "Record deleted."
    DEL @label(label: "Deleted")
    "Records linked."
    LNK @label(label: "Linked")
    "Records unlinked."
    UNL @label(label: "Unlinked")
    "Record commented upon."
    COM @label(label: "Commented")
}

"Describes a user of the system."
type User implements IBaseEntity & ITrackedEntity @auth {
    "The immutable, unique user identifier (system-assigned)."
    id: ID!
    "The entity kind."
    entityKind(
        "How to format the result. SHORT format is per ```EntityKind``` enum."
        format: FormatKind = LONG
    ): String
    "The entity status."
    status(
        "How to format the result. SHORT format is per ```StatusKind``` enum."
        format: FormatKind = LONG
    ): String
    "A five-star rating for the user, indicative of contributions, quality, etc."
    rating: Int
    # TODO: support date/time formatting
    "When the record was created."
    created: DateTime
    "The user who created the record."
    createdByUser: User @auth(authority: [ADM])
    # TODO: support date/time formatting
    "When the record was last updated."
    updated: DateTime
    "The user who last updated the record."
    updatedByUser: User @auth(authority: [ADM])
    "Log of transactions involving the record."
    log(
        "Filters results."
        filter: LogQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): LogPage!
    "Comments associated with the record."
    comments(
        "Filters results."
        filter: CommentQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): CommentPage
    "The (mutable?) unique user name (user-assigned)."
    username: String
    "The user's first name."
    firstName: String
    "The user's last name."
    lastName: String
    "The user's email address."
    email: String @auth(authority: [ADM])
    # TODO: consider whether to reveal this through the GraphQL API.
    "A hash of the user's password."
    password: String @auth(authority: [ADM])
    "The user's country of residence."
    country(
        "How to format the result."
        format: CountryFormatKind = COMMON_NAME
    ): String
    "Added notes about the user."
    notes: String
    "The authorities granted to the user."
    authorities(
        "How to aggregate authorities."
        aggregation: AggregationKind = OWN
        "How to format the results. SHORT format is per ```AuthorityKind``` enum."
        format: FormatKind = LONG
    ): [String!]! @auth(authority: [ADM])
    "The groups of which the user is a member."
    groups: [Group!] @auth(authority: [ADM])
}

"Input for creating or updating a user of the system."
input UserInput {
    "The immutable, unique user identifier (system-assigned)."
    id: ID
    "A five-star rating for the user, indicative of contributions, quality, etc."
    rating: Int
    "The (mutable?) unique user name (user-assigned)."
    username: String!
    "The user's first name."
    firstName: String!
    "The user's last name."
    lastName: String!
    "The user's email address."
    email: String!
    "A bcrypt hash of the user's password."
    password: String
    "The user's country of residence (ISO-3166-1 alpha-2 code)."
    country: String
    "Added notes about the user."
    notes: String
    "The authorities to grant to the user."
    authorities: [AuthorityKind!]!
}

"Input for updating a user's password."
input UserPasswordInput {
    "The immutable, unique user identifier (system-assigned)."
    id: ID!
    "A bcrypt hash of the user's password."
    password: String!
}

"Input for updating an existing user of the system."
input UserProfileInput {
    "The immutable, unique user identifier (system-assigned)."
    id: ID!
    "The user's first name."
    firstName: String!
    "The user's last name."
    lastName: String!
    "The user's email address."
    email: String!
    "The user's country of residence (ISO-3166-1 alpha-2 code)."
    country: String!
    "Added notes about the user."
    notes: String
}

"Returns paginated user query results."
type UserPage implements IPage {
    "Dummy ID required for @Entity classes"
    dummy: ID
    "Whether the page has content."
    hasContent: Boolean!
    "Whether the page is empty (no content)."
    isEmpty: Boolean!
    "The current page number."
    number: Int!
    "The page size."
    size: Int!
    "The number of elements on this page."
    numberOfElements: Int!
    "The total number of pages available."
    totalPages: Int!
    "The total number of records."
    totalElements: Long!
    "Whether this is the first page."
    isFirst: Boolean!
    "Whether this is the last page."
    isLast: Boolean!
    "Whether there is next page."
    hasNext: Boolean!
    "Whether there is previous page."
    hasPrevious: Boolean!
    "The requested pageful of records."
    content: [User!]!
}

type Group implements IBaseEntity & ITrackedEntity @auth {
    "The immutable, unique user identifier (system-assigned)."
    id: ID!
    "The entity kind."
    entityKind(
        "How to format the result. SHORT format is per ```EntityKind``` enum."
        format: FormatKind = LONG
    ): String
    "The entity status."
    status(
        "How to format the result. SHORT format is per ```StatusKind``` enum."
        format: FormatKind = LONG
    ): String
    "A five-star rating for the group, though as yet unsure whether/how to use this."
    rating: Int
    # TODO: support date/time formatting
    "When the record was created."
    created: DateTime
    "The user who created the record."
    createdByUser: User @auth(authority: [ADM])
    # TODO: support date/time formatting
    "When the record was last updated."
    updated: DateTime
    "The user who last updated the record."
    updatedByUser: User @auth(authority: [ADM])
    "Log of transactions involving the record."
    log(
        "Filters results."
        filter: LogQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): LogPage!
    "Comments associated with the record."
    comments(
        "Filters results."
        filter: CommentQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): CommentPage
    "The (mutable?) unique group name."
    groupname: String
    "The authorities granted to the group."
    authorities(
        "How to format the results. SHORT format is per ```AuthorityKind``` enum."
        format: FormatKind = LONG
    ): [String!]! @auth(authority: [ADM])
    "The members of the group."
    members: [User!] @auth(authority: [ADM])
}

input GroupInput {
    "The immutable, unique group identifier (system-assigned)."
    id: ID
    "A five-star rating for the group, though as yet unsure whether/how to use this."
    rating: Int
    "The (mutable?) unique group name (user-assigned)."
    groupname: String!
    "The authorities to grant to the group."
    authorities: [AuthorityKind!]!
}

"Returns paginated group query results."
type GroupPage implements IPage {
    "Dummy ID required for @Entity classes"
    dummy: ID
    "Whether the page has content."
    hasContent: Boolean!
    "Whether the page is empty (no content)."
    isEmpty: Boolean!
    "The current page number."
    number: Int!
    "The page size."
    size: Int!
    "The number of elements on this page."
    numberOfElements: Int!
    "The total number of pages available."
    totalPages: Int!
    "The total number of records."
    totalElements: Long!
    "Whether this is the first page."
    isFirst: Boolean!
    "Whether this is the last page."
    isLast: Boolean!
    "Whether there is next page."
    hasNext: Boolean!
    "Whether there is previous page."
    hasPrevious: Boolean!
    "The requested pageful of records."
    content: [Group!]!
}

"Authentication return value, including a JSON Web Token."
type AuthPayload {
    "The JWT authentication token."
    token: String!
    "The authenticated user."
    user: User!
}

#==================================================
# API ENTRY POINTS

"Available queries."
type Query {
    "Returns a paged list of claims."
    claims(
        "Filters results."
        filter: LinkableEntityQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): ClaimPage!
    "Returns a claim given its identifier."
    claimById(id: ID!): Claim

    "Returns a paged list of comments."
    comments(
        "Filters results."
        filter: CommentQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): CommentPage!
    "Returns a comment given its identifier."
    commentById(id: ID!): Comment

    "Returns a paged list of declarations."
    declarations(
        "Filters results."
        filter: LinkableEntityQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): DeclarationPage!
    "Returns a declaration given its identifier."
    declarationById(id: ID!): Declaration

    "Returns a paged list of entity links."
    entityLinks(
        "Filters results."
        filter: EntityLinkQueryFilter,
        "Sorts and paginates results"
        pageSort: PageableInput
    ): EntityLinkPage
    "Returns an entity link given its identifier."
    entityLinkById(id: ID!): EntityLink
    "Returns an entity link given its from- and to-entity identifiers."
    entityLinkByEntityIds(fromEntityId: ID!, toEntityId: ID!): EntityLink

    "Returns a paged list of journals."
    journals(
        "Filters results."
        filter: TrackedEntityQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): JournalPage!
    "Returns a journal given its identifier."
    journalById(id: ID!): Journal

    "Returns a paged list of log entries."
    log(
        "Filters results."
        filter: LogQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): LogPage!

    "Returns a paged list of persons."
    persons(
        "Filters results."
        filter: LinkableEntityQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): PersonPage!
    "Returns a person given its identifier."
    personById(id: ID!): Person

    "Returns a paged list of publications."
    publications(
        "Filters results."
        filter: LinkableEntityQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): PublicationPage!
    "Returns a publication given its identifier."
    publicationById(id: ID!): Publication

    "Returns a paged list of publishers."
    publishers(
        "Filters results."
        filter: TrackedEntityQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): PublisherPage!
    "Returns a publisher given its identifier."
    publisherById(id: ID!): Publisher

    "Returns a paged list of quotations."
    quotations(
        "Filters results."
        filter: LinkableEntityQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): QuotationPage!
    "Returns a quotation given its identifier."
    quotationById(id: ID!): Quotation

    "Returns a paged list of topics or sub-topics."
    topics(
        "Filters results."
        filter: TopicQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): TopicPage!
    "Returns a topic given its identifier."
    topicById(id: ID!): Topic

    "Returns a paged list of users."
    users(
        "Filters results."
        filter: TrackedEntityQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): UserPage! @auth(authority: [ADM])
    "Returns a user given its identifier."
    userById(id: ID!): User @auth(authority: [ADM])
    "Returns a user given its username."
    userByUsername(username: String!): User @auth(authority: [ADM])
    "Returns the currently logged-in user."
    currentUser: User

    "Returns a paged list of groups."
    groups(
        "Filters results."
        filter: TrackedEntityQueryFilter,
        "Sorts and/or paginates results."
        pageSort: PageableInput
    ): GroupPage! @auth(authority: [ADM])
    "Returns a group given its identifier."
    groupById(id: ID!): Group @auth(authority: [ADM])
    "Returns a group given its groupname."
    groupByGroupname(groupname: String!): Group @auth(authority: [ADM])

    "Returns statistics on the specified entity kinds."
    entityStatistics(
        "Selects the entities to include."
        filter: StatisticsQueryFilter
    ): [EntityStatistics!]
    "Returns statistics on entities linked to the specified topic(s)."
    topicStatistics(
        "Selects the entities to include."
        filter: StatisticsQueryFilter
    ): [TopicStatistics!]
}

"Available mutations."
type Mutation {
    "Authenticates the client using JSON Web Token (JWT)."
    login(username: String!, password: String!) : AuthPayload

    "Creates a new claim."
    createClaim(claim: ClaimInput!): Claim @auth(authority: [CRE])
    "Updates an existing claim."
    updateClaim(claim: ClaimInput!): Claim @auth(authority: [UPD])
    "Deletes an existing claim."
    deleteClaim(claimId: ID!): Claim @auth(authority: [DEL])

    "Creates a new comment."
    createComment(comment: CommentInput!): Comment @auth(authority: [COM])
    "Updates an existing comment."
    updateComment(comment: CommentInput!): Comment @auth(authority: [COM])
    "Deletes an existing comment."
    deleteComment(commentId: ID!): Comment @auth(authority: [COM])

    "Creates a new declaration."
    createDeclaration(declaration: DeclarationInput!): Declaration @auth(authority: [CRE])
    "Updates an existing declaration."
    updateDeclaration(declaration: DeclarationInput!): Declaration @auth(authority: [UPD])
    "Deletes an existing declaration."
    deleteDeclaration(declarationId: ID!): Declaration @auth(authority: [DEL])

    "Creates an entity link."
    createEntityLink(entityLink: EntityLinkInput!) : EntityLink @auth(authority: [LNK])
    "Updates an existing entity link."
    updateEntityLink(entityLink: EntityLinkInput!): EntityLink @auth(authority: [LNK])
    "Deletes an entity link."
    deleteEntityLink(entityLinkId: ID!) : EntityLink @auth(authority: [LNK])

    "Create a new journal."
    createJournal(journal: JournalInput!): Journal @auth(authority: [CRE])
    "Updates an existing journal."
    updateJournal(journal: JournalInput!): Journal @auth(authority: [UPD])
    "Deletes an existing journal."
    deleteJournal(journalId: ID!): Journal @auth(authority: [DEL])

    "Creates a new person."
    createPerson(person: PersonInput!): Person @auth(authority: [CRE])
    "Updates an existing person."
    updatePerson(person: PersonInput!): Person @auth(authority: [UPD])
    "Deletes an existing person."
    deletePerson(personId: ID!): Person @auth(authority: [DEL])

    "Creates a new publication."
    createPublication(publication: PublicationInput!): Publication @auth(authority: [CRE])
    "Updates an existing publication."
    updatePublication(publication: PublicationInput!): Publication @auth(authority: [UPD])
    "Deletes an existing publication."
    deletePublication(publicationId: ID!): Publication @auth(authority: [DEL])

    "Creates a new publisher."
    createPublisher(publisher: PublisherInput!): Publisher @auth(authority: [CRE])
    "Updates an existing publisher."
    updatePublisher(publisher: PublisherInput!): Publisher @auth(authority: [UPD])
    "Deletes an existing publisher."
    deletePublisher(publisherId: ID!): Publisher @auth(authority: [DEL])

    "Creates a new quotation."
    createQuotation(quotation: QuotationInput!): Quotation @auth(authority: [CRE])
    "Updates an existing quotation."
    updateQuotation(quotation: QuotationInput!): Quotation @auth(authority: [UPD])
    "Deletes an existing quotation."
    deleteQuotation(quotationId: ID!): Quotation @auth(authority: [DEL])

    "Creates a new topic."
    createTopic(topic: TopicInput!): Topic @auth(authority: [CRE])
    "Updates an existing topic."
    updateTopic(topic: TopicInput!): Topic @auth(authority: [UPD])
    "Deletes an existing topic."
    deleteTopic(topicId: ID!): Topic @auth(authority: [DEL])

    "Sets entity status."
    setEntityStatus(entityId: ID!, status: StatusKind!) : Boolean @auth(authority: [UPD])

    "Creates a new user."
    createUser(user: UserInput!): User @auth(authority: [ADM])
    "Updates an existing user."
    updateUser(user: UserInput!): User @auth(authority: [ADM])
    "Updates an existing user's password."
    updateUserPassword(user: UserPasswordInput!): User @auth(authority: [ADM])
    "Updates an existing user's profile."
    updateUserProfile(user: UserProfileInput!): User @auth(authority: [ADM])
    "Deletes an existing user."
    deleteUser(userId: ID!): User @auth(authority: [ADM])
    "Grants authorities to a user. The specified authorities are added to any existing ones."
    grantUserAuthorities(userId: ID!, authorities: [AuthorityKind!]!): User @auth(authority: [ADM])
    "Revokes authorities from a user. The specified authorities are removed from the user; other authorities remain intact."
    revokeUserAuthorities(userId: ID!, authorities: [AuthorityKind!]!): User @auth(authority: [ADM])

    "Creates a new group."
    createGroup(group: GroupInput!): Group @auth(authority: [ADM])
    "Updates an existing group."
    updateGroup(group: GroupInput!): Group @auth(authority: [ADM])
    "Deletes an existing group."
    deleteGroup(groupId: ID!): Group @auth(authority: [ADM])
    "Adds a user to a group."
    addGroupMember(groupId: ID!, userId: ID!): Group @auth(authority: [ADM])
    "Removes a user from a group."
    removeGroupMember(groupId: ID!, userId: ID!): Group @auth(authority: [ADM])
    "Grants authorities to a group. The specified authorities are added to any existing ones."
    grantGroupAuthorities(groupId: ID!, authorities: [AuthorityKind!]!): Group @auth(authority: [ADM])
    "Revokes authorities from a group. The specified authorities are removed from the group; other authorities remain intact."
    revokeGroupAuthorities(groupId: ID!, authorities: [AuthorityKind!]!): Group @auth(authority: [ADM])
}
