/*----------------------------------------------------------------------------------------------------------------------
 * Evidence Engine: A system for managing evidence on arbitrary scientific topics.
 * Comprises an SQL database, GraphQL public API, Java app server, Java and web clients.
 * Copyright Â© 2024 Adrian Price. All rights reserved.
 *
 * This file is part of Evidence Engine.
 *
 * Evidence Engine is free software: you can redistribute it and/or modify it under the terms of the
 * GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * Evidence Engine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License along with Evidence Engine.
 * If not, see <https://www.gnu.org/licenses/>.
 *--------------------------------------------------------------------------------------------------------------------*/

package io.github.demonfiddler.ee.server.controller;

import java.util.List;
import java.util.NoSuchElementException;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.graphql.data.method.annotation.Argument;
import org.springframework.graphql.data.method.annotation.SchemaMapping;
import org.springframework.stereotype.Controller;

import com.graphql_java_generator.server.util.GraphqlServerUtils;
import com.graphql_java_generator.util.GraphqlUtils;

import graphql.schema.DataFetchingEnvironment;
import io.github.demonfiddler.ee.server.datafetcher.DataFetchersDelegateMutation;
import io.github.demonfiddler.ee.server.model.ClaimInput;
import io.github.demonfiddler.ee.server.model.DeclarationInput;
import io.github.demonfiddler.ee.server.model.EntityKind;
import io.github.demonfiddler.ee.server.model.JournalInput;
import io.github.demonfiddler.ee.server.model.LinkEntitiesInput;
import io.github.demonfiddler.ee.server.model.PermissionKind;
import io.github.demonfiddler.ee.server.model.PersonInput;
import io.github.demonfiddler.ee.server.model.PublicationInput;
import io.github.demonfiddler.ee.server.model.PublisherInput;
import io.github.demonfiddler.ee.server.model.QuotationInput;
import io.github.demonfiddler.ee.server.model.StatusKind;
import io.github.demonfiddler.ee.server.model.TopicInput;
import io.github.demonfiddler.ee.server.model.TopicRefInput;
import io.github.demonfiddler.ee.server.model.UserInput;

/**
 * @author generated by graphql-java-generator
 * @see <a href=
 * "https://github.com/graphql-java-generator/graphql-java-generator">https://github.com/graphql-java-generator/graphql-java-generator</a>
 */
@Controller
@SchemaMapping(typeName = "Mutation")
public class MutationController {

	@Autowired
	protected DataFetchersDelegateMutation dataFetchersDelegateMutation;

	@Autowired
	protected GraphqlServerUtils graphqlServerUtils;

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.createClaim. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param claim The parameter that will receive the field argument of the same name for the current data to fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "createClaim")
	public Object createClaim(DataFetchingEnvironment dataFetchingEnvironment, @Argument("claim") ClaimInput claim) {
		return this.dataFetchersDelegateMutation.createClaim(dataFetchingEnvironment, claim);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.updateClaim. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param claim The parameter that will receive the field argument of the same name for the current data to fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "updateClaim")
	public Object updateClaim(DataFetchingEnvironment dataFetchingEnvironment, @Argument("claim") ClaimInput claim) {
		return this.dataFetchersDelegateMutation.updateClaim(dataFetchingEnvironment, claim);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.deleteClaim. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param claimId The parameter that will receive the field argument of the same name for the current data to fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "deleteClaim")
	public Object deleteClaim(DataFetchingEnvironment dataFetchingEnvironment, @Argument("claimId") Long claimId) {
		return this.dataFetchersDelegateMutation.deleteClaim(dataFetchingEnvironment, claimId);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.createDeclaration. It returns an Object: the data
	 * fetcher implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param declaration The parameter that will receive the field argument of the same name for the current data to
	 * fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "createDeclaration")
	public Object createDeclaration(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("declaration") DeclarationInput declaration) {

		return this.dataFetchersDelegateMutation.createDeclaration(dataFetchingEnvironment, declaration);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.updateDeclaration. It returns an Object: the data
	 * fetcher implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param declaration The parameter that will receive the field argument of the same name for the current data to
	 * fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "updateDeclaration")
	public Object updateDeclaration(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("declaration") DeclarationInput declaration) {

		return this.dataFetchersDelegateMutation.updateDeclaration(dataFetchingEnvironment, declaration);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.deleteDeclaration. It returns an Object: the data
	 * fetcher implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param declarationId The parameter that will receive the field argument of the same name for the current data to
	 * fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "deleteDeclaration")
	public Object deleteDeclaration(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("declarationId") Long declarationId) {

		return this.dataFetchersDelegateMutation.deleteDeclaration(dataFetchingEnvironment, declarationId);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.createJournal. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param journal The parameter that will receive the field argument of the same name for the current data to fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "createJournal")
	public Object createJournal(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("journal") JournalInput journal) {

		return this.dataFetchersDelegateMutation.createJournal(dataFetchingEnvironment, journal);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.updateJournal. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param journal The parameter that will receive the field argument of the same name for the current data to fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "updateJournal")
	public Object updateJournal(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("journal") JournalInput journal) {

		return this.dataFetchersDelegateMutation.updateJournal(dataFetchingEnvironment, journal);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.deleteJournal. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param journalId The parameter that will receive the field argument of the same name for the current data to
	 * fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "deleteJournal")
	public Object deleteJournal(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("journalId") Long journalId) {

		return this.dataFetchersDelegateMutation.deleteJournal(dataFetchingEnvironment, journalId);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.createPerson. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param person The parameter that will receive the field argument of the same name for the current data to fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "createPerson")
	public Object createPerson(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("person") PersonInput person) {

		return this.dataFetchersDelegateMutation.createPerson(dataFetchingEnvironment, person);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.updatePerson. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param person The parameter that will receive the field argument of the same name for the current data to fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "updatePerson")
	public Object updatePerson(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("person") PersonInput person) {

		return this.dataFetchersDelegateMutation.updatePerson(dataFetchingEnvironment, person);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.deletePerson. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param personId The parameter that will receive the field argument of the same name for the current data to fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "deletePerson")
	public Object deletePerson(DataFetchingEnvironment dataFetchingEnvironment, @Argument("personId") Long personId) {
		return this.dataFetchersDelegateMutation.deletePerson(dataFetchingEnvironment, personId);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.createPublication. It returns an Object: the data
	 * fetcher implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param publication The parameter that will receive the field argument of the same name for the current data to
	 * fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "createPublication")
	public Object createPublication(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("publication") PublicationInput publication) {

		return this.dataFetchersDelegateMutation.createPublication(dataFetchingEnvironment, publication);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.updatePublication. It returns an Object: the data
	 * fetcher implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param publication The parameter that will receive the field argument of the same name for the current data to
	 * fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "updatePublication")
	public Object updatePublication(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("publication") PublicationInput publication) {

		return this.dataFetchersDelegateMutation.updatePublication(dataFetchingEnvironment, publication);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.deletePublication. It returns an Object: the data
	 * fetcher implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param publicationId The parameter that will receive the field argument of the same name for the current data to
	 * fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "deletePublication")
	public Object deletePublication(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("publicationId") Long publicationId) {

		return this.dataFetchersDelegateMutation.deletePublication(dataFetchingEnvironment, publicationId);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.createPublisher. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param publisher The parameter that will receive the field argument of the same name for the current data to
	 * fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "createPublisher")
	public Object createPublisher(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("publisher") PublisherInput publisher) {

		return this.dataFetchersDelegateMutation.createPublisher(dataFetchingEnvironment, publisher);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.updatePublisher. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param publisher The parameter that will receive the field argument of the same name for the current data to
	 * fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "updatePublisher")
	public Object updatePublisher(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("publisher") PublisherInput publisher) {

		return this.dataFetchersDelegateMutation.updatePublisher(dataFetchingEnvironment, publisher);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.deletePublisher. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param publisherId The parameter that will receive the field argument of the same name for the current data to
	 * fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "deletePublisher")
	public Object deletePublisher(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("publisherId") Long publisherId) {

		return this.dataFetchersDelegateMutation.deletePublisher(dataFetchingEnvironment, publisherId);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.createQuotation. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param quotation The parameter that will receive the field argument of the same name for the current data to
	 * fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "createQuotation")
	public Object createQuotation(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("quotation") io.github.demonfiddler.ee.server.model.QuotationInput quotation) {

		return this.dataFetchersDelegateMutation.createQuotation(dataFetchingEnvironment, quotation);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.updateQuotation. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param quotation The parameter that will receive the field argument of the same name for the current data to
	 * fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "updateQuotation")
	public Object updateQuotation(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("quotation") QuotationInput quotation) {

		return this.dataFetchersDelegateMutation.updateQuotation(dataFetchingEnvironment, quotation);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.deleteQuotation. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param quotationId The parameter that will receive the field argument of the same name for the current data to
	 * fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "deleteQuotation")
	public Object deleteQuotation(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("quotationId") Long quotationId) {

		return this.dataFetchersDelegateMutation.deleteQuotation(dataFetchingEnvironment, quotationId);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.createTopic. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param topic The parameter that will receive the field argument of the same name for the current data to fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "createTopic")
	public Object createTopic(DataFetchingEnvironment dataFetchingEnvironment, @Argument("topic") TopicInput topic) {
		return this.dataFetchersDelegateMutation.createTopic(dataFetchingEnvironment, topic);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.updateTopic. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param topic The parameter that will receive the field argument of the same name for the current data to fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "updateTopic")
	public Object updateTopic(DataFetchingEnvironment dataFetchingEnvironment, @Argument("topic") TopicInput topic) {
		return this.dataFetchersDelegateMutation.updateTopic(dataFetchingEnvironment, topic);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.deleteTopic. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param topicId The parameter that will receive the field argument of the same name for the current data to fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "deleteTopic")
	public Object deleteTopic(DataFetchingEnvironment dataFetchingEnvironment, @Argument("topicId") Long topicId) {
		return this.dataFetchersDelegateMutation.deleteTopic(dataFetchingEnvironment, topicId);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.addTopicRef. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param topicRef The parameter that will receive the field argument of the same name for the current data to fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "addTopicRef")
	public Object addTopicRef(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("topicRef") TopicRefInput topicRef) {

		return this.dataFetchersDelegateMutation.addTopicRef(dataFetchingEnvironment, topicRef);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.removeTopicRef. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param topicRef The parameter that will receive the field argument of the same name for the current data to fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "removeTopicRef")
	public Object removeTopicRef(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("topicRef") TopicRefInput topicRef) {

		return this.dataFetchersDelegateMutation.removeTopicRef(dataFetchingEnvironment, topicRef);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.linkEntities. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param link The parameter that will receive the field argument of the same name for the current data to fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "linkEntities")
	public Object linkEntities(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("link") LinkEntitiesInput link) {

		return this.dataFetchersDelegateMutation.linkEntities(dataFetchingEnvironment, link);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.unlinkEntities. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param link The parameter that will receive the field argument of the same name for the current data to fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "unlinkEntities")
	public Object unlinkEntities(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("link") LinkEntitiesInput link) {

		return this.dataFetchersDelegateMutation.unlinkEntities(dataFetchingEnvironment, link);
	}

	@SchemaMapping(field = "setEntityStatus")
	public Object setEntityStatus(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("entityKind") EntityKind entityKind, @Argument("entityId") Long entityId,
		@Argument("status") StatusKind status) {

		return this.dataFetchersDelegateMutation.setEntityStatus(dataFetchingEnvironment, entityKind, entityId, status);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.createUser. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param user The parameter that will receive the field argument of the same name for the current data to fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "createUser")
	public Object createUser(DataFetchingEnvironment dataFetchingEnvironment, @Argument("user") UserInput user) {
		return this.dataFetchersDelegateMutation.createUser(dataFetchingEnvironment, user);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.updateUser. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param user The parameter that will receive the field argument of the same name for the current data to fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "updateUser")
	public Object updateUser(DataFetchingEnvironment dataFetchingEnvironment, @Argument("user") UserInput user) {
		return this.dataFetchersDelegateMutation.updateUser(dataFetchingEnvironment, user);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.deleteUser. It returns an Object: the data fetcher
	 * implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param userId The parameter that will receive the field argument of the same name for the current data to fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "deleteUser")
	public Object deleteUser(DataFetchingEnvironment dataFetchingEnvironment, @Argument("userId") Long userId) {
		return this.dataFetchersDelegateMutation.deleteUser(dataFetchingEnvironment, userId);
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.grantUserPermissions. It returns an Object: the data
	 * fetcher implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param userId The parameter that will receive the field argument of the same name for the current data to fetch
	 * @param permissions The parameter that will receive the field argument of the same name for the current data to
	 * fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "grantUserPermissions")
	@SuppressWarnings("unchecked")
	public Object grantUserPermissions(DataFetchingEnvironment dataFetchingEnvironment, @Argument("userId") Long userId,
		@Argument("permissions") List<String> permissions) {

		return this.dataFetchersDelegateMutation.grantUserPermissions(dataFetchingEnvironment, userId,
			(List<PermissionKind>)GraphqlUtils.graphqlUtils.stringToEnumValue(permissions, PermissionKind.class));
	}

	/**
	 * This method loads the data for ${dataFetcher.graphQLType}.revokeUserPermissions. It returns an Object: the data
	 * fetcher implementation may return any type that is accepted by a spring-graphql controller<BR/>
	 * @param dataFetchingEnvironment The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full
	 * GraphQL context for this DataFetcher
	 * @param origin The object from which the field is fetch. In other word: the aim of this data fetcher is to fetch
	 * the author attribute of the <I>origin</I>, which is an instance of {ObjectType {name:Post, fields:{Field{name:id,
	 * type:ID!, params:[]},Field{name:date, type:Date!, params:[]},Field{name:author, type:Member,
	 * params:[]},Field{name:publiclyAvailable, type:Boolean, params:[]},Field{name:title, type:String!,
	 * params:[]},Field{name:content, type:String!, params:[]},Field{name:authorId, type:ID,
	 * params:[]},Field{name:topicId, type:ID, params:[]}}, comments ""}. It depends on your data modle, but it
	 * typically contains the id to use in the query.
	 * @throws NoSuchElementException This method may return a {@link NoSuchElementException} exception. In this case,
	 * the exception is trapped by the calling method, and the return is consider as null. This allows to use the
	 * {@link Optional#get()} method directly, without caring of whether or not there is a value. The generated code
	 * will take care of the {@link NoSuchElementException} exception.
	 * @param userId The parameter that will receive the field argument of the same name for the current data to fetch
	 * @param permissions The parameter that will receive the field argument of the same name for the current data to
	 * fetch
	 * @return It may return any value that is valid for a spring-graphql controller, annotated by the
	 * <code>@SchemaMapping</code> annotation
	 */
	@SchemaMapping(field = "revokeUserPermissions")
	@SuppressWarnings("unchecked")
	public Object revokeUserPermissions(DataFetchingEnvironment dataFetchingEnvironment,
		@Argument("userId") Long userId, @Argument("permissions") List<String> permissions) {

		return this.dataFetchersDelegateMutation.revokeUserPermissions(dataFetchingEnvironment, userId,
			(List<PermissionKind>)GraphqlUtils.graphqlUtils.stringToEnumValue(permissions, PermissionKind.class));
	}

}
